<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Airshu&#39;s Blog</title>
  
  <subtitle>Hello World</subtitle>
  <link href="http://airshu.github.io/atom.xml" rel="self"/>
  
  <link href="http://airshu.github.io/"/>
  <updated>2024-08-02T13:15:20.038Z</updated>
  <id>http://airshu.github.io/</id>
  
  <author>
    <name>airshu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>启动流程分析</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</id>
    <published>2024-08-02T13:15:20.038Z</published>
    <updated>2024-08-02T13:15:20.038Z</updated>
    
    <content type="html"><![CDATA[<p>需要的前置知识：</p><ul><li><a href="../../Dart/%E5%9F%BA%E7%A1%80/Mixin">Mixin用法</a></li></ul><h2 id="核心类和函数"><a href="#核心类和函数" class="headerlink" title="核心类和函数"></a>核心类和函数</h2><h3 id="PlatformDispatcher"><a href="#PlatformDispatcher" class="headerlink" title="PlatformDispatcher"></a>PlatformDispatcher</h3><p>平台事件转发器，单例对象。比如每一帧的渲染回调、系统语言切换等。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">单例对象</span></span></span><br><span class="line"><span class="keyword">static</span> PlatformDispatcher <span class="keyword">get</span> instance =&gt; _instance;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> PlatformDispatcher _instance = PlatformDispatcher._();</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">配置信息（是否使用24小时制、文本缩放大小、语言、主题等） 发生变化时回调onPlatformConfigurationChanged</span></span></span><br><span class="line">PlatformConfiguration <span class="keyword">get</span> configuration =&gt; _configuration;</span><br><span class="line">PlatformConfiguration _configuration = <span class="keyword">const</span> PlatformConfiguration();</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">当前视图列表，当它们发生变化时，回调onMetricsChanged</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">FlutterView对UI进行了封装</span></span></span><br><span class="line"><span class="built_in">Iterable</span>&lt;FlutterView&gt; <span class="keyword">get</span> views =&gt; _views.values;</span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">Object</span>, FlutterView&gt; _views = &lt;<span class="built_in">Object</span>, FlutterView&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">新的一帧开启时回调</span></span></span><br><span class="line">FrameCallback? <span class="keyword">get</span> onBeginFrame =&gt; _onBeginFrame;</span><br><span class="line">FrameCallback? _onBeginFrame;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">onBeginFrame完成后执行该回调</span></span></span><br><span class="line">VoidCallback? <span class="keyword">get</span> onDrawFrame =&gt; _onDrawFrame;</span><br><span class="line">VoidCallback? _onDrawFrame;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">手势交互回调，GestureBinding处理</span></span></span><br><span class="line">PointerDataPacketCallback? <span class="keyword">get</span> onPointerDataPacket =&gt; _onPointerDataPacket;</span><br><span class="line">PointerDataPacketCallback? _onPointerDataPacket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">平台消息回调</span></span></span><br><span class="line">PlatformMessageCallback? <span class="keyword">get</span> onPlatformMessage =&gt; _onPlatformMessage;</span><br><span class="line">PlatformMessageCallback? _onPlatformMessage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">执行后，onBeginFrame、onDrawFrame会执行，参考SchedulerBinding</span></span></span><br><span class="line"><span class="keyword">void</span> scheduleFrame() native <span class="string">&#x27;PlatformConfiguration_scheduleFrame&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">语言切换回调</span></span></span><br><span class="line">VoidCallback? <span class="keyword">get</span> onLocaleChanged =&gt; _onLocaleChanged;</span><br><span class="line">VoidCallback? _onLocaleChanged;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="FlutterView"><a href="#FlutterView" class="headerlink" title="FlutterView"></a>FlutterView</h3><p>FlutterView对象window是对PlatformDispatcher的封装，是与平台层的交互入口。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">要被绘制的UI对象</span></span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FlutterView</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// <span class="language-markdown">持有平台消息分发器</span></span></span><br><span class="line">    PlatformDispatcher <span class="keyword">get</span> platformDispatcher;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="language-markdown">被系统挡住的屏幕物理像素，比如软键盘弹起，则EdgeInsets的bottom会大于0</span></span></span><br><span class="line">    WindowPadding <span class="keyword">get</span> viewInsets =&gt; viewConfiguration.viewInsets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="language-markdown">被系统UI挡住的屏幕物理像素，比如系统通知栏，iphone的底部功能键</span></span></span><br><span class="line">    WindowPadding <span class="keyword">get</span> viewPadding =&gt; viewConfiguration.viewPadding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="language-markdown">max(0.0, FlutterView.viewPadding - FlutterView.viewInsets)</span></span></span><br><span class="line">    WindowPadding <span class="keyword">get</span> padding =&gt; viewConfiguration.padding;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="language-markdown">屏幕像素密度，物理像素和虚拟像素的比值</span></span></span><br><span class="line">    <span class="built_in">double</span> <span class="keyword">get</span> devicePixelRatio =&gt; viewConfiguration.devicePixelRatio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="language-markdown">通知底层进行渲染</span></span></span><br><span class="line">    <span class="keyword">void</span> render(Scene scene) =&gt; _render(scene, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">void</span> _render(Scene scene, FlutterView view) native <span class="string">&#x27;PlatformConfiguration_render&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlutterWindow</span> <span class="keyword">extends</span> <span class="title">FlutterView</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonFlutterWindow</span> <span class="keyword">extends</span> <span class="title">FlutterWindow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="language-markdown">对platformDispatcher中的回调方法进行了一层封装</span></span></span><br><span class="line"></span><br><span class="line">    VoidCallback? <span class="keyword">get</span> onMetricsChanged =&gt; platformDispatcher.onMetricsChanged;</span><br><span class="line">    <span class="keyword">set</span> onMetricsChanged(VoidCallback? callback) &#123;</span><br><span class="line">        platformDispatcher.onMetricsChanged = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VoidCallback? <span class="keyword">get</span> onLocaleChanged =&gt; platformDispatcher.onLocaleChanged;</span><br><span class="line">    <span class="keyword">set</span> onLocaleChanged(VoidCallback? callback) &#123;</span><br><span class="line">        platformDispatcher.onLocaleChanged = callback;</span><br><span class="line">    &#125;</span><br><span class="line">    VoidCallback? <span class="keyword">get</span> onLocaleChanged =&gt; platformDispatcher.onLocaleChanged;</span><br><span class="line">    <span class="keyword">set</span> onLocaleChanged(VoidCallback? callback) &#123;</span><br><span class="line">        platformDispatcher.onLocaleChanged = callback;</span><br><span class="line">    &#125;</span><br><span class="line">    VoidCallback? <span class="keyword">get</span> onLocaleChanged =&gt; platformDispatcher.onLocaleChanged;</span><br><span class="line">    <span class="keyword">set</span> onLocaleChanged(VoidCallback? callback) &#123;</span><br><span class="line">        platformDispatcher.onLocaleChanged = callback;</span><br><span class="line">    &#125;</span><br><span class="line">    VoidCallback? <span class="keyword">get</span> onLocaleChanged =&gt; platformDispatcher.onLocaleChanged;</span><br><span class="line">    <span class="keyword">set</span> onLocaleChanged(VoidCallback? callback) &#123;</span><br><span class="line">        platformDispatcher.onLocaleChanged = callback;</span><br><span class="line">    &#125;</span><br><span class="line">        VoidCallback? <span class="keyword">get</span> onLocaleChanged =&gt; platformDispatcher.onLocaleChanged;</span><br><span class="line">    <span class="keyword">set</span> onLocaleChanged(VoidCallback? callback) &#123;</span><br><span class="line">        platformDispatcher.onLocaleChanged = callback;</span><br><span class="line">    &#125;</span><br><span class="line">        VoidCallback? <span class="keyword">get</span> onLocaleChanged =&gt; platformDispatcher.onLocaleChanged;</span><br><span class="line">    <span class="keyword">set</span> onLocaleChanged(VoidCallback? callback) &#123;</span><br><span class="line">        platformDispatcher.onLocaleChanged = callback;</span><br><span class="line">    &#125;</span><br><span class="line">    VoidCallback? <span class="keyword">get</span> onLocaleChanged =&gt; platformDispatcher.onLocaleChanged;</span><br><span class="line">    <span class="keyword">set</span> onLocaleChanged(VoidCallback? callback) &#123;</span><br><span class="line">        platformDispatcher.onLocaleChanged = callback;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="入口函数及相关类"><a href="#入口函数及相关类" class="headerlink" title="入口函数及相关类"></a>入口函数及相关类</h2><p>main入口调用runApp函数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> runApp(Widget app) &#123;</span><br><span class="line">  WidgetsFlutterBinding.ensureInitialized()<span class="comment">//初始化操作</span></span><br><span class="line">    ..scheduleAttachRootWidget(app)<span class="comment">//将传入的Widget包装进RenderObjectToWidgetAdapter</span></span><br><span class="line">    ..scheduleWarmUpFrame();<span class="comment">//SchedulerBinding进行绘制</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetsFlutterBinding</span> <span class="keyword">extends</span> <span class="title">BindingBase</span> <span class="title">with</span> <span class="title">GestureBinding</span>, <span class="title">SchedulerBinding</span>, <span class="title">ServicesBinding</span>, <span class="title">PaintingBinding</span>, <span class="title">SemanticsBinding</span>, <span class="title">RendererBinding</span>, <span class="title">WidgetsBinding</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> WidgetsBinding ensureInitialized() &#123;</span><br><span class="line">    <span class="keyword">if</span> (WidgetsBinding.instance == <span class="keyword">null</span>)</span><br><span class="line">      WidgetsFlutterBinding();</span><br><span class="line">    <span class="keyword">return</span> WidgetsBinding.instance!;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>BindingBase：绑定的基类</li><li>WidgetsBinding：绑定组件树，提供onLocalChanged、onBuildScheduled等回调</li><li>RendererBinding：绑定渲染树，提供window.onMetricsChanged、window.onTextScaleDactorChanged等回调</li><li>SemanticsBinding（绑定语义树）</li><li>PaintingBinding（图片缓存操作）</li><li>ServicesBinding：绑定平台服务消息，注册Dart层和C++层的消息传输服务，提供window.onPlatformMessage回调</li><li>SchedulerBinding：绑定帧绘制回调函数，以及widget生命周期相关事件，提供window.onBeginFrame和window.onDrawFrame回调</li><li>GestureBinding：绑定手势事件，用于检测应用的各种手势相关操作，提供window.onPointerDataPacket回调</li></ul><h3 id="BindingBase"><a href="#BindingBase" class="headerlink" title="BindingBase"></a>BindingBase</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BindingBase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="language-markdown">绑定的主视图</span></span></span><br><span class="line">    ui.SingletonFlutterWindow <span class="keyword">get</span> <span class="built_in">window</span> =&gt; ui.<span class="built_in">window</span>;</span><br><span class="line">    <span class="comment">/// <span class="language-markdown">持有平台事件分发器</span></span></span><br><span class="line">    ui.PlatformDispatcher <span class="keyword">get</span> platformDispatcher =&gt; ui.PlatformDispatcher.instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// <span class="language-markdown">混入的方式初始化不同的Binding对象</span></span></span><br><span class="line">    <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">        <span class="keyword">assert</span>(!_debugInitialized);</span><br><span class="line">        <span class="keyword">assert</span>(() &#123;</span><br><span class="line">        _debugInitialized = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="RenderBinding"><a href="#RenderBinding" class="headerlink" title="RenderBinding"></a>RenderBinding</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> RendererBinding <span class="keyword">on</span> BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, SemanticsBinding, HitTestable &#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 管理RenderObject对象</span></span><br><span class="line">    _pipelineOwner = PipelineOwner(</span><br><span class="line">      onNeedVisualUpdate: ensureVisualUpdate,</span><br><span class="line">      onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,</span><br><span class="line">      onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 监听平台事件的回调</span></span><br><span class="line">    <span class="built_in">window</span></span><br><span class="line">      ..onMetricsChanged = handleMetricsChanged</span><br><span class="line">      ..onTextScaleFactorChanged = handleTextScaleFactorChanged</span><br><span class="line">      ..onPlatformBrightnessChanged = handlePlatformBrightnessChanged</span><br><span class="line">      ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged</span><br><span class="line">      ..onSemanticsAction = _handleSemanticsAction;</span><br><span class="line">    <span class="comment">// 生成RenderView作为根节点，RenderView继承自RenderObject</span></span><br><span class="line">    initRenderView();</span><br><span class="line">    _handleSemanticsEnabledChanged();</span><br><span class="line">    <span class="keyword">assert</span>(renderView != <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 监听帧刷新回调，Flutter侧进行布局、绘制</span></span><br><span class="line">    addPersistentFrameCallback(_handlePersistentFrameCallback);</span><br><span class="line">    <span class="comment">// 手势处理</span></span><br><span class="line">    initMouseTracker();</span><br><span class="line">    <span class="keyword">if</span> (kIsWeb) &#123;</span><br><span class="line">      addPostFrameCallback(_handleWebFirstFrame);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(renderView != <span class="keyword">null</span>);</span><br><span class="line">    pipelineOwner.flushLayout();<span class="comment">//布局</span></span><br><span class="line">    pipelineOwner.flushCompositingBits();<span class="comment">//</span></span><br><span class="line">    pipelineOwner.flushPaint();<span class="comment">//绘制</span></span><br><span class="line">    <span class="keyword">if</span> (sendFramesToEngine) &#123;</span><br><span class="line">      renderView.compositeFrame(); <span class="comment">// this sends the bits to the GPU</span></span><br><span class="line">      pipelineOwner.flushSemantics(); <span class="comment">// this also sends the semantics to the OS.</span></span><br><span class="line">      _firstFrameSent = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">事件传递</span></span></span><br><span class="line">  <span class="meta">@override</span> <span class="comment">// from GestureBinding</span></span><br><span class="line">  <span class="keyword">void</span> dispatchEvent(PointerEvent event, HitTestResult? hitTestResult) &#123;</span><br><span class="line">    _mouseTracker!.updateWithEvent(</span><br><span class="line">      event,</span><br><span class="line">      <span class="comment">// Enter and exit events should be triggered with or without buttons</span></span><br><span class="line">      <span class="comment">// pressed. When the button is pressed, normal hit test uses a cached</span></span><br><span class="line">      <span class="comment">// result, but MouseTracker requires that the hit test is re-executed to</span></span><br><span class="line">      <span class="comment">// update the hovering events.</span></span><br><span class="line">      () =&gt; (hitTestResult == <span class="keyword">null</span> || event <span class="keyword">is</span> PointerMoveEvent) ? renderView.hitTestMouseTrackers(event.position) : hitTestResult,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">super</span>.dispatchEvent(event, hitTestResult);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PaintingBinding"><a href="#PaintingBinding" class="headerlink" title="PaintingBinding"></a>PaintingBinding</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> PaintingBinding <span class="keyword">on</span> BindingBase, ServicesBinding &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    _imageCache = createImageCache();<span class="comment">//图片缓存，1000张图片，最大内存100MiB</span></span><br><span class="line">    shaderWarmUp?.execute();<span class="comment">//异步方法，初始化了一个默认的着色器，避免需要着色器的时候再初始化出现掉帧现象。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">内存警告回调，清理图片缓存</span></span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> handleMemoryPressure() &#123;</span><br><span class="line">    <span class="keyword">super</span>.handleMemoryPressure();</span><br><span class="line">    imageCache?.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ServiceBinding"><a href="#ServiceBinding" class="headerlink" title="ServiceBinding"></a>ServiceBinding</h3><p>主要用来接收MethodChannel和SystemChannels传递过来的消息</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> ServicesBinding <span class="keyword">on</span> BindingBase, SchedulerBinding &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">跟平台通信的消息管理器</span></span></span><br><span class="line">  BinaryMessenger <span class="keyword">get</span> defaultBinaryMessenger =&gt; _defaultBinaryMessenger;</span><br><span class="line">  <span class="keyword">late</span> <span class="keyword">final</span> BinaryMessenger _defaultBinaryMessenger;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 创建MethodChannel</span></span><br><span class="line">    _defaultBinaryMessenger = createBinaryMessenger();</span><br><span class="line">    <span class="comment">// RestorationManager用于恢复界面数据的功能</span></span><br><span class="line">    _restorationManager = createRestorationManager();</span><br><span class="line">    <span class="comment">// 初始化键盘</span></span><br><span class="line">    _initKeyboard();</span><br><span class="line">    initLicenses();</span><br><span class="line">    <span class="comment">//系统消息回调监听</span></span><br><span class="line">    SystemChannels.system.setMessageHandler((<span class="built_in">dynamic</span> message) =&gt; handleSystemMessage(message <span class="keyword">as</span> <span class="built_in">Object</span>));</span><br><span class="line">    SystemChannels.lifecycle.setMessageHandler(_handleLifecycleMessage);</span><br><span class="line">    SystemChannels.platform.setMethodCallHandler(_handlePlatformMessage);</span><br><span class="line">    <span class="comment">// 读取当前的生命周期状态，处理则是在SchedulerBinding这个mixin中。</span></span><br><span class="line">    readInitialLifecycleStateFromNativeWindow();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SchedulerBinding"><a href="#SchedulerBinding" class="headerlink" title="SchedulerBinding"></a>SchedulerBinding</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">调度阶段 绘制调度、task调度</span></span></span><br><span class="line"><span class="keyword">enum</span> SchedulerPhase &#123;</span><br><span class="line">    idle,<span class="comment">// 处理task、microtask、timer回调，用户输入和手势等</span></span><br><span class="line">    transientCallbacks,<span class="comment">//处理动画状态的计算和更新</span></span><br><span class="line">    midFrameMicrotasks,<span class="comment">//处理transientCallbacks阶段触发的microtasks</span></span><br><span class="line">    persistentCallbacks,<span class="comment">//处理build、layout、paint</span></span><br><span class="line">    postFrameCallbacks,<span class="comment">//当前阶段结束时的清理工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="keyword">mixin</span> SchedulerBinding <span class="keyword">on</span> BindingBase &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">永久callback，一经添加无法移除，由WidgetsBinding.instance.addPersitentFrameCallback()注册，这个回调处理了布局与绘制工作。</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;FrameCallback&gt; _persistentCallbacks = &lt;FrameCallback&gt;[];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">只会调用一次，调用后会被系统移除，可由WidgetsBinding.instance.addPostFrameCallback()注册，该回调一般用于State的更新。</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;FrameCallback&gt; _postFrameCallbacks = &lt;FrameCallback&gt;[];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">通过Ticker的scheduleTick添加回调，一般用于动画的回调</span></span></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">int</span>, _FrameCallbackEntry&gt; _transientCallbacks = &lt;<span class="built_in">int</span>, _FrameCallbackEntry&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">应用生命周期发生变化时回调</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">可以使用WidgetsBindingObserver.didChangeAppLifecycleState监听来实现自己的业务逻辑</span></span></span><br><span class="line">  <span class="keyword">void</span> handleAppLifecycleStateChanged(AppLifecycleState state) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(state != <span class="keyword">null</span>);</span><br><span class="line">    _lifecycleState = state;</span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">      <span class="keyword">case</span> AppLifecycleState.resumed:</span><br><span class="line">      <span class="keyword">case</span> AppLifecycleState.inactive:</span><br><span class="line">        _setFramesEnabledState(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> AppLifecycleState.paused:</span><br><span class="line">      <span class="keyword">case</span> AppLifecycleState.detached:</span><br><span class="line">        _setFramesEnabledState(<span class="keyword">false</span>);<span class="comment">//停止刷新界面</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> _framesEnabled = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">void</span> _setFramesEnabledState(<span class="built_in">bool</span> enabled) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_framesEnabled == enabled)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    _framesEnabled = enabled;</span><br><span class="line">    <span class="keyword">if</span> (enabled)</span><br><span class="line">      scheduleFrame();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> scheduleFrame() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_hasScheduledFrame || !framesEnabled)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      <span class="keyword">if</span> (debugPrintScheduleFrameStacks)</span><br><span class="line">        debugPrintStack(label: <span class="string">&#x27;scheduleFrame() called. Current phase is <span class="subst">$schedulerPhase</span>.&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">    <span class="comment">//确保向window注册了onBeginFrame和onDrawFrame</span></span><br><span class="line">    ensureFrameCallbacksRegistered();</span><br><span class="line">    <span class="comment">// 向平台层发送刷新请求，进行下一轮帧刷新</span></span><br><span class="line">    <span class="built_in">window</span>.scheduleFrame();</span><br><span class="line">    _hasScheduledFrame = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> ensureFrameCallbacksRegistered() &#123;</span><br><span class="line">    <span class="built_in">window</span>.onBeginFrame ??= _handleBeginFrame;</span><br><span class="line">    <span class="built_in">window</span>.onDrawFrame ??= _handleDrawFrame;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> handleBeginFrame(<span class="built_in">Duration?</span> rawTimeStamp) &#123;</span><br><span class="line">    _frameTimelineTask?.start(<span class="string">&#x27;Frame&#x27;</span>, arguments: timelineArgumentsIndicatingLandmarkEvent);</span><br><span class="line">    _firstRawTimeStampInEpoch ??= rawTimeStamp;</span><br><span class="line">    _currentFrameTimeStamp = _adjustForEpoch(rawTimeStamp ?? _lastRawTimeStamp);</span><br><span class="line">    <span class="keyword">if</span> (rawTimeStamp != <span class="keyword">null</span>)</span><br><span class="line">      _lastRawTimeStamp = rawTimeStamp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span>(schedulerPhase == SchedulerPhase.idle);</span><br><span class="line">    _hasScheduledFrame = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// TRANSIENT FRAME CALLBACKS</span></span><br><span class="line">      _frameTimelineTask?.start(<span class="string">&#x27;Animate&#x27;</span>, arguments: timelineArgumentsIndicatingLandmarkEvent);</span><br><span class="line">      _schedulerPhase = SchedulerPhase.transientCallbacks;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">int</span>, _FrameCallbackEntry&gt; callbacks = _transientCallbacks;</span><br><span class="line">      _transientCallbacks = &lt;<span class="built_in">int</span>, _FrameCallbackEntry&gt;&#123;&#125;;</span><br><span class="line">      callbacks.forEach((<span class="built_in">int</span> id, _FrameCallbackEntry callbackEntry) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_removedIds.contains(id))</span><br><span class="line">          _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp!, callbackEntry.debugStack);</span><br><span class="line">      &#125;);</span><br><span class="line">      _removedIds.clear();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      _schedulerPhase = SchedulerPhase.midFrameMicrotasks;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> handleDrawFrame() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_schedulerPhase == SchedulerPhase.midFrameMicrotasks);</span><br><span class="line">    _frameTimelineTask?.finish(); <span class="comment">// end the &quot;Animate&quot; phase</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// PERSISTENT FRAME CALLBACKS</span></span><br><span class="line">      _schedulerPhase = SchedulerPhase.persistentCallbacks;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> FrameCallback callback <span class="keyword">in</span> _persistentCallbacks)</span><br><span class="line">        _invokeFrameCallback(callback, _currentFrameTimeStamp!);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// POST-FRAME CALLBACKS</span></span><br><span class="line">      _schedulerPhase = SchedulerPhase.postFrameCallbacks;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">List</span>&lt;FrameCallback&gt; localPostFrameCallbacks =</span><br><span class="line">          <span class="built_in">List</span>&lt;FrameCallback&gt;.of(_postFrameCallbacks);</span><br><span class="line">      _postFrameCallbacks.clear();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> FrameCallback callback <span class="keyword">in</span> localPostFrameCallbacks)</span><br><span class="line">        _invokeFrameCallback(callback, _currentFrameTimeStamp!);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      _schedulerPhase = SchedulerPhase.idle;</span><br><span class="line">      _frameTimelineTask?.finish(); <span class="comment">// end the Frame</span></span><br><span class="line">      <span class="keyword">assert</span>(() &#123;</span><br><span class="line">        <span class="keyword">if</span> (debugPrintEndFrameBanner)</span><br><span class="line">          debugPrint(<span class="string">&#x27;▀&#x27;</span> * _debugBanner!.length);</span><br><span class="line">        _debugBanner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;());</span><br><span class="line">      _currentFrameTimeStamp = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">Frame即每一帧的绘制过程，engine通过VSync信号不断地触发Frame的绘制，实际上就是调用SchedulerBinding类中的<span class="emphasis">_handleBeginFrame()和_</span>handleDrawFrame()这两个方法，这个过程中会完成动画、布局、绘制等工作。</span></span></span><br><span class="line">  <span class="keyword">void</span> scheduleWarmUpFrame() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_warmUpFrame || schedulerPhase != SchedulerPhase.idle)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    _warmUpFrame = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> TimelineTask timelineTask = TimelineTask()..start(<span class="string">&#x27;Warm-up frame&#x27;</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span> hadScheduledFrame = _hasScheduledFrame;</span><br><span class="line">    <span class="comment">// We use timers here to ensure that microtasks flush in between.</span></span><br><span class="line">    Timer.run(() &#123;</span><br><span class="line">      <span class="keyword">assert</span>(_warmUpFrame);</span><br><span class="line">      handleBeginFrame(<span class="keyword">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    Timer.run(() &#123;</span><br><span class="line">      <span class="keyword">assert</span>(_warmUpFrame);</span><br><span class="line">      handleDrawFrame();</span><br><span class="line">      resetEpoch();</span><br><span class="line">      _warmUpFrame = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (hadScheduledFrame)</span><br><span class="line">        scheduleFrame();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    lockEvents(() <span class="keyword">async</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> endOfFrame;</span><br><span class="line">      timelineTask.finish();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="GestureBinding"><a href="#GestureBinding" class="headerlink" title="GestureBinding"></a>GestureBinding</h3><p>处理用户的交互</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> GestureBinding <span class="keyword">on</span> BindingBase <span class="keyword">implements</span> HitTestable, HitTestDispatcher, HitTestTarget &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">window</span>.onPointerDataPacket = _handlePointerDataPacket;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handlePointerDataPacket(ui.PointerDataPacket packet) &#123;</span><br><span class="line">    <span class="comment">// We convert pointer data to logical pixels so that e.g. the touch slop can be</span></span><br><span class="line">    <span class="comment">// defined in a device-independent manner.</span></span><br><span class="line">    _pendingPointerEvents.addAll(PointerEventConverter.expand(packet.data, <span class="built_in">window</span>.devicePixelRatio));</span><br><span class="line">    <span class="keyword">if</span> (!locked)</span><br><span class="line">      _flushPointerEventQueue();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> _flushPointerEventQueue() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(!locked);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (_pendingPointerEvents.isNotEmpty)</span><br><span class="line">      handlePointerEvent(_pendingPointerEvents.removeFirst());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> handlePointerEvent(PointerEvent event) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(!locked);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resamplingEnabled) &#123;</span><br><span class="line">      _resampler.addOrDispatch(event);</span><br><span class="line">      _resampler.sample(samplingOffset, _samplingClock);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop resampler if resampling is not enabled. This is a no-op if</span></span><br><span class="line">    <span class="comment">// resampling was never enabled.</span></span><br><span class="line">    _resampler.stop();</span><br><span class="line">    _handlePointerEventImmediately(event);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _handlePointerEventImmediately(PointerEvent event) &#123;</span><br><span class="line">    HitTestResult? hitTestResult;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">is</span> PointerDownEvent || event <span class="keyword">is</span> PointerSignalEvent || event <span class="keyword">is</span> PointerHoverEvent) &#123;</span><br><span class="line">      <span class="keyword">assert</span>(!_hitTests.containsKey(event.pointer));</span><br><span class="line">      hitTestResult = HitTestResult();<span class="comment">//记录事件传递所经过的节点</span></span><br><span class="line">      hitTest(hitTestResult, event.position);</span><br><span class="line">      <span class="keyword">if</span> (event <span class="keyword">is</span> PointerDownEvent) &#123;</span><br><span class="line">        _hitTests[event.pointer] = hitTestResult;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">assert</span>(() &#123;</span><br><span class="line">        <span class="keyword">if</span> (debugPrintHitTestResults)</span><br><span class="line">          debugPrint(<span class="string">&#x27;<span class="subst">$event</span>: <span class="subst">$hitTestResult</span>&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">is</span> PointerUpEvent || event <span class="keyword">is</span> PointerCancelEvent) &#123;</span><br><span class="line">      hitTestResult = _hitTests.remove(event.pointer);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.down) &#123;</span><br><span class="line">      hitTestResult = _hitTests[event.pointer];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      <span class="keyword">if</span> (debugPrintMouseHoverEvents &amp;&amp; event <span class="keyword">is</span> PointerHoverEvent)</span><br><span class="line">        debugPrint(<span class="string">&#x27;<span class="subst">$event</span>&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">    <span class="keyword">if</span> (hitTestResult != <span class="keyword">null</span> ||</span><br><span class="line">        event <span class="keyword">is</span> PointerAddedEvent ||</span><br><span class="line">        event <span class="keyword">is</span> PointerRemovedEvent) &#123;</span><br><span class="line">      <span class="keyword">assert</span>(event.position != <span class="keyword">null</span>);</span><br><span class="line">      dispatchEvent(event, hitTestResult);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span> <span class="comment">// from HitTestable</span></span><br><span class="line">  <span class="keyword">void</span> hitTest(HitTestResult result, Offset position) &#123;</span><br><span class="line">    result.add(HitTestEntry(<span class="keyword">this</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">事件分发流程</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">先调用RenderBinding中的dispatchEvent，遍历renderView的所有widget，将hitTestResult返回</span></span></span><br><span class="line">  <span class="keyword">void</span> dispatchEvent(PointerEvent event, HitTestResult? hitTestResult) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(!locked);</span><br><span class="line">    <span class="keyword">if</span> (hitTestResult == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">assert</span>(event <span class="keyword">is</span> PointerAddedEvent || event <span class="keyword">is</span> PointerRemovedEvent);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        pointerRouter.route(event);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> HitTestEntry entry <span class="keyword">in</span> hitTestResult.path) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        entry.target.handleEvent(event.transformed(entry.transform), entry);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">手势竞技场进行处理</span></span></span><br><span class="line">  <span class="meta">@override</span> <span class="comment">// from HitTestTarget</span></span><br><span class="line">  <span class="keyword">void</span> handleEvent(PointerEvent event, HitTestEntry entry) &#123;</span><br><span class="line">    pointerRouter.route(event);</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">is</span> PointerDownEvent) &#123;</span><br><span class="line">      gestureArena.close(event.pointer);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">is</span> PointerUpEvent) &#123;</span><br><span class="line">      gestureArena.sweep(event.pointer);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">is</span> PointerSignalEvent) &#123;</span><br><span class="line">      pointerSignalResolver.resolve(event);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="WidgetsBinding"><a href="#WidgetsBinding" class="headerlink" title="WidgetsBinding"></a>WidgetsBinding</h3><p>处理widget树的逻辑</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">mixin</span> WidgetsBinding <span class="keyword">on</span> BindingBase, ServicesBinding, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">光标管理器</span></span></span><br><span class="line">  FocusManager <span class="keyword">get</span> focusManager =&gt; _buildOwner!.focusManager;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">应用生命周期回调，回到App、回到桌面、内存不足、语言切换、主题切换、文字大小切换等</span></span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;WidgetsBindingObserver&gt; _observers = &lt;WidgetsBindingObserver&gt;[];</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initInstances();</span><br><span class="line">    _instance = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      _debugAddStackFilters();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialization of [_buildOwner] has to be done after</span></span><br><span class="line">    <span class="comment">// [super.initInstances] is called, as it requires [ServicesBinding] to</span></span><br><span class="line">    <span class="comment">// properly setup the [defaultBinaryMessenger] instance.</span></span><br><span class="line">    <span class="comment">// 初始化BuildOwner，用来执行widget树的build任务</span></span><br><span class="line">    _buildOwner = BuildOwner();</span><br><span class="line">    buildOwner!.onBuildScheduled = _handleBuildScheduled;</span><br><span class="line">    <span class="comment">//语言切换回调</span></span><br><span class="line">    <span class="built_in">window</span>.onLocaleChanged = handleLocaleChanged;</span><br><span class="line">    <span class="built_in">window</span>.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged;</span><br><span class="line">    SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation);<span class="comment">//系统路由监听？</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="scheduleAttachRootWidget"><a href="#scheduleAttachRootWidget" class="headerlink" title="scheduleAttachRootWidget"></a>scheduleAttachRootWidget</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> scheduleAttachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">      Timer.run(() &#123;</span><br><span class="line">          attachRootWidget(rootWidget);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> attachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span> isBootstrapFrame = renderViewElement == <span class="keyword">null</span>;</span><br><span class="line">    _readyToProduceFrames = <span class="keyword">true</span>;</span><br><span class="line">    _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;(</span><br><span class="line">      container: renderView,<span class="comment">//RenderBinding构建的根节点</span></span><br><span class="line">      debugShortDescription: <span class="string">&#x27;[root]&#x27;</span>,</span><br><span class="line">      child: rootWidget,<span class="comment">//rootWidget是我们自己的AppWidget</span></span><br><span class="line">    ).attachToRenderTree(buildOwner!, renderViewElement <span class="keyword">as</span> RenderObjectToWidgetElement&lt;RenderBox&gt;?);</span><br><span class="line">    <span class="keyword">if</span> (isBootstrapFrame) &#123;</span><br><span class="line">      SchedulerBinding.instance!.ensureVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObjectToWidgetAdapter</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">RenderObject</span>&gt; <span class="keyword">extends</span> <span class="title">RenderObjectWidget</span> </span>&#123;</span><br><span class="line">  RenderObjectToWidgetElement&lt;T&gt; attachToRenderTree(BuildOwner owner, [ RenderObjectToWidgetElement&lt;T&gt;? element ]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element == <span class="keyword">null</span>) &#123;</span><br><span class="line">      owner.lockState(() &#123;</span><br><span class="line">        element = createElement();<span class="comment">//创建RenderObjectElement的子类RenderObjectToWidgetElement</span></span><br><span class="line">        <span class="keyword">assert</span>(element != <span class="keyword">null</span>);</span><br><span class="line">        element!.assignOwner(owner);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">//BuildOwner</span></span><br><span class="line">      owner.buildScope(element!, () &#123;</span><br><span class="line">        element!.mount(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element._newWidget = <span class="keyword">this</span>;</span><br><span class="line">      element.markNeedsBuild();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element!;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObjectToWidgetElement</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">RenderObject</span>&gt; <span class="keyword">extends</span> <span class="title">RootRenderObjectElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element?</span> parent, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(parent == <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    _rebuild();</span><br><span class="line">    <span class="keyword">assert</span>(_child != <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _rebuild() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _child = updateChild(_child, widget.child, _rootChildSlot);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">      <span class="keyword">final</span> FlutterErrorDetails details = FlutterErrorDetails(</span><br><span class="line">        exception: exception,</span><br><span class="line">        stack: stack,</span><br><span class="line">        <span class="keyword">library</span>: <span class="string">&#x27;widgets library&#x27;</span>,</span><br><span class="line">        context: ErrorDescription(<span class="string">&#x27;attaching to the render tree&#x27;</span>),</span><br><span class="line">      );</span><br><span class="line">      FlutterError.reportError(details);</span><br><span class="line">      <span class="keyword">final</span> Widget error = ErrorWidget.builder(details);</span><br><span class="line">      _child = updateChild(<span class="keyword">null</span>, error, _rootChildSlot);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Element?</span> updateChild(<span class="built_in">Element?</span> child, Widget? newWidget, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newWidget == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">        deactivateChild(child);<span class="comment">//新widget为空，旧的存在，则需要销毁</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Element</span> newChild;</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="built_in">bool</span> hasSameSuperclass = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (hasSameSuperclass &amp;&amp; child.widget == newWidget) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child.slot != newSlot)</span><br><span class="line">          updateSlotForChild(child, newSlot);</span><br><span class="line">        newChild = child;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasSameSuperclass &amp;&amp; Widget.canUpdate(child.widget, newWidget)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child.slot != newSlot)</span><br><span class="line">          updateSlotForChild(child, newSlot);</span><br><span class="line">        <span class="keyword">if</span> (!kReleaseMode &amp;&amp; debugProfileBuildsEnabled) &#123;</span><br><span class="line">          <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; debugTimelineArguments = timelineArgumentsIndicatingLandmarkEvent;</span><br><span class="line">          Timeline.startSync(</span><br><span class="line">            <span class="string">&#x27;<span class="subst">$&#123;newWidget.runtimeType&#125;</span>&#x27;</span>,</span><br><span class="line">            arguments: debugTimelineArguments,</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">        child.update(newWidget);</span><br><span class="line">        <span class="keyword">if</span> (!kReleaseMode &amp;&amp; debugProfileBuildsEnabled)</span><br><span class="line">          Timeline.finishSync();</span><br><span class="line">        newChild = child;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        deactivateChild(child);</span><br><span class="line">        <span class="keyword">assert</span>(child._parent == <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!kReleaseMode &amp;&amp; debugProfileBuildsEnabled) &#123;</span><br><span class="line">          <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; debugTimelineArguments = timelineArgumentsIndicatingLandmarkEvent;</span><br><span class="line">          Timeline.startSync(</span><br><span class="line">            <span class="string">&#x27;<span class="subst">$&#123;newWidget.runtimeType&#125;</span>&#x27;</span>,</span><br><span class="line">            arguments: debugTimelineArguments,</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">        newChild = inflateWidget(newWidget, newSlot);</span><br><span class="line">        <span class="keyword">if</span> (!kReleaseMode &amp;&amp; debugProfileBuildsEnabled)</span><br><span class="line">          Timeline.finishSync();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!kReleaseMode &amp;&amp; debugProfileBuildsEnabled) &#123;</span><br><span class="line">        <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; debugTimelineArguments = timelineArgumentsIndicatingLandmarkEvent;</span><br><span class="line">        Timeline.startSync(</span><br><span class="line">          <span class="string">&#x27;<span class="subst">$&#123;newWidget.runtimeType&#125;</span>&#x27;</span>,</span><br><span class="line">          arguments: debugTimelineArguments,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      newChild = inflateWidget(newWidget, newSlot);<span class="comment">//child为null，则需要填充新视图</span></span><br><span class="line">      <span class="keyword">if</span> (!kReleaseMode &amp;&amp; debugProfileBuildsEnabled)</span><br><span class="line">        Timeline.finishSync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newChild;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Element</span> inflateWidget(Widget newWidget, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">final</span> Key? key = newWidget.key;</span><br><span class="line">    <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Element?</span> newChild = _retakeInactiveElement(key, newWidget);</span><br><span class="line">      <span class="keyword">if</span> (newChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">        newChild._activateWithParent(<span class="keyword">this</span>, newSlot);</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">Element?</span> updatedChild = updateChild(newChild, newWidget, newSlot);</span><br><span class="line">        <span class="keyword">assert</span>(newChild == updatedChild);</span><br><span class="line">        <span class="keyword">return</span> updatedChild!;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Element</span> newChild = newWidget.createElement();<span class="comment">//创建新的Element</span></span><br><span class="line">    newChild.mount(<span class="keyword">this</span>, newSlot);<span class="comment">//递归mount</span></span><br><span class="line">    <span class="keyword">return</span> newChild;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObjectElement</span> <span class="keyword">extends</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element?</span> parent, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      _debugDoingBuild = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">    _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">    attachRenderObject(newSlot);<span class="comment">//挂载到RenderObject树</span></span><br><span class="line">    _dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> <span class="keyword">implements</span> <span class="title">BuildContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element?</span> parent, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_lifecycleState == _ElementLifecycle.initial);</span><br><span class="line">    <span class="keyword">assert</span>(widget != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">assert</span>(_parent == <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">assert</span>(parent == <span class="keyword">null</span> || parent._lifecycleState == _ElementLifecycle.active);</span><br><span class="line">    <span class="keyword">assert</span>(slot == <span class="keyword">null</span>);</span><br><span class="line">    _parent = parent;<span class="comment">//Element树当前节点的父节点</span></span><br><span class="line">    _slot = newSlot;<span class="comment">//插槽</span></span><br><span class="line">    _lifecycleState = _ElementLifecycle.active;</span><br><span class="line">    _depth = _parent != <span class="keyword">null</span> ? _parent!.depth + <span class="number">1</span> : <span class="number">1</span>;<span class="comment">//节点深度</span></span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Only assign ownership if the parent is non-null. If parent is null</span></span><br><span class="line">      <span class="comment">// (the root node), the owner should have already been assigned.</span></span><br><span class="line">      <span class="comment">// See RootRenderObjectElement.assignOwner().</span></span><br><span class="line">      _owner = parent.owner;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span>(owner != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">final</span> Key? key = widget.key;</span><br><span class="line">    <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;</span><br><span class="line">      owner!._registerGlobalKey(key, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _updateInheritance();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="scheduleWarmUpFrame"><a href="#scheduleWarmUpFrame" class="headerlink" title="scheduleWarmUpFrame"></a>scheduleWarmUpFrame</h2><p>ScheduleBinding中调用handleBeginFrame和handleDrawFrame绘制一帧并传递给GPU去渲染。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>runApp启动程序；</li><li>WidgetFlutterBinding初始化；WidgetsFlutterBinding混入了GestureBinding, SchedulerBinding, ServicesBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding。<br>  2.1. WidgetsBinding中创建BuildOwner，其用于处理widget树的build任务；<br>  2.2. RendererBinding创建PipelineOwner，其用于管理RenderObject对象；</li><li>用FlutterView将runApp的参数包裹起来，里面还包裹了_MediaQueryFromView，其可以返回MediaQueryData来获取屏幕的大小等值；</li><li>scheduleAttachRootWidget调用attachRootWidget，创建Widget Tree的根节点RenderObjectToWidgetAdapter，它的createElement创建Element Tree的根节点（RenderObjectToWidgetElement），createRenderObject返回的是PipelineOwner中的rootNode；</li><li>BuildOwner调用buildScope执行build流程，mount的时候调用createRenderObject构建Render Tree；</li><li>scheduleWarmUpFrame尽可能触发一次帧渲染</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://gityuan.com/2019/06/22/flutter_booting/">深入理解Flutter引擎启动</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;需要的前置知识：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;../../Dart/%E5%9F%BA%E7%A1%80/Mixin&quot;&gt;Mixin用法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;核心类和函数&quot;&gt;&lt;a href=&quot;#核心类和函数&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>绘制原理</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/</id>
    <published>2024-08-02T13:15:20.038Z</published>
    <updated>2024-08-02T13:15:20.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h2><ul><li>Canvas：封装了Flutter Skia各种绘制指令，比如画线、画圆、画矩形等指令。</li><li>Layer：分为容器类和绘制类两种；暂时可以理解为是绘制产物的载体，比如调用 Canvas 的绘制 API 后，相应的绘制产物被保存在 PictureLayer.picture 对象中。</li><li>Scene：屏幕上将要要显示的元素。在上屏前，我们需要将Layer中保存的绘制产物关联到 Scene 上。</li><li>Picture：是一系列的图形绘制操作指令。</li></ul><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/layer_1.png"></p><ul><li>Container Layer：管理Layers，是唯一可以拥有child layer的Layer；</li><li>非Container Layer：真正用于承载渲染结果的layer，在Layer Tree中属于叶子结点。比如PictureLayer承载的是图片的渲染结果，TextureLayer承载的是纹理的渲染结果；</li></ul><h2 id="绘制流程"><a href="#绘制流程" class="headerlink" title="绘制流程"></a>绘制流程</h2><h3 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h3><ol><li>构建一个 Canvas，用于绘制；同时还需要创建一个绘制指令记录器，因为绘制指令最终是要传递给 Skia 的，而 Canvas 可能会连续发起多条绘制指令，指令记录器用于收集 Canvas 在一段时间内所有的绘制指令，因此Canvas 构造函数第一个参数必须传递一个 PictureRecorder 实例。</li><li>Canvas 绘制完成后，通过 PictureRecorder 获取绘制产物，然后将其保存在 Layer 中。</li><li>renderView.compositeFrame构建 Scene 对象，将 layer 的绘制产物和 Scene 关联起来。</li><li>上屏；调用window.render API 将Scene上的绘制产物发送给GPU。</li></ol><h3 id="精细流程"><a href="#精细流程" class="headerlink" title="精细流程"></a>精细流程</h3><p>第一次绘制时，从上到下递归绘制子节点，每当遇到一个边界节点，判断如果该节点的layer属性是否为空，是就创建一个新的OffsetLayer并赋值给它；不是则使用。然后将layer传递给子节点，接下来：</p><ol><li>如果子节点是非边界节点，且需要绘制，则：<ul><li>第一次绘制：创建一个Canvas对象和一个PictureLayer，然后将它们绑定，后续调用Canvas绘制都会落到和其绑定的PictureLayer上，接着这个PictureLayer会加入到边界节点的layer中；</li><li>不是第一次绘制：复用已有的边界节点和Canvas对象；</li></ul></li><li>如果子节点是边界节点，则对子节点递归上述过程。当子树递归完成后，就要将子节点的layer添加到父级layer中。</li></ol><p>RenderObject调用markNeedsRepaint来发起重绘：</p><ol><li>从当前节点一直往父级查找，直到找到一个<strong>绘制边界点</strong>时终止查找，然后会将该绘制边界点添加到其PiplineOwner的_nodesNeedingPaint列表中。</li><li>在查找的过程中，会将自己到绘制边界点路径上所有节点的_needPaint属性设置为true，表示需要重绘。</li><li>请求新的frame，执行重绘流程。下一个frame就会走drawFrame流程，涉及到flushCompositingBits、flushPaint 和 compositeFrame 三个函数。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://w4lle.com/2020/11/09/flutter-ui-overview/">Flutter UI 渲染浅析（一）总览</a></li><li><a href="http://w4lle.com/2020/11/11/flutter-ui-vsync/">Flutter UI 渲染浅析（二）VSync 注册</a></li><li><a href="http://w4lle.com/2020/11/13/flutter-ui-animate/">Flutter UI 渲染浅析（三）Animation 原理</a></li><li><a href="http://w4lle.com/2020/11/16/flutter-ui-build/">Flutter UI 渲染浅析（四）Build</a></li><li><a href="http://w4lle.com/2021/01/15/flutter-ui-layout/">Flutter UI 渲染浅析（五）Layout</a></li><li><a href="http://w4lle.com/2021/02/01/flutter-ui-paint/">Flutter UI 渲染浅析（六）Paint</a></li><li><a href="http://w4lle.com/2021/02/02/flutter-ui-composite/">Flutter UI 渲染浅析（七）Composite</a></li><li><a href="https://juejin.cn/post/6844903791427321863">《Flutter框架分析（一）– 总览和Window》</a></li><li><a href="https://juejin.cn/post/6844903792006135821">《Flutter框架分析（二）– 初始化》</a></li><li><a href="https://juejin.cn/post/6844903794703073287">《Flutter框架分析（三）– Widget，Element和RenderObject》</a></li><li><a href="https://juejin.cn/post/6844903797387444232">《Flutter框架分析（四）– Flutter框架的运行》</a></li><li><a href="https://juejin.cn/post/6844903842371354637">《Flutter框架分析（五）– 动画》</a></li><li><a href="https://juejin.cn/post/6844903848922841095">《Flutter框架分析（六）– 布局》</a></li><li><a href="https://juejin.cn/post/6844903856623599630">《Flutter框架分析（七）– 绘制》</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;相关类&quot;&gt;&lt;a href=&quot;#相关类&quot; class=&quot;headerlink&quot; title=&quot;相关类&quot;&gt;&lt;/a&gt;相关类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Canvas：封装了Flutter Skia各种绘制指令，比如画线、画圆、画矩形等指令。&lt;/li&gt;
&lt;li&gt;Layer：</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Sliver布局模型</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Sliver%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Sliver%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-08-02T13:15:20.037Z</published>
    <updated>2024-08-02T13:15:20.037Z</updated>
    
    <content type="html"><![CDATA[<p>在Flutter中，列表的每个Item被称为Sliver。</p><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Sliver%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B/scroll.png"></p><p>Flutter常见的列表类最终都有Scrollable类实现，而该类内部包含RawGestureDetector等一系列负责处理手势、响应滑动的类。</p><h2 id="RenderViewport布局流程分析"><a href="#RenderViewport布局流程分析" class="headerlink" title="RenderViewport布局流程分析"></a>RenderViewport布局流程分析</h2><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Sliver%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B/renderviewport.png"></p><p>RenderViewport关键类及其关系</p><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Sliver%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B/sliver1.png"></p><p>Viewport的大小（主轴方法）为1250（每个Sliver的大小为250），即图中深灰色部分。Viewport前后存在一定长度的缓冲区，用于提升列表滑动的流畅度，即图中浅灰色部分，大小为250。center参数被设置为第4个子节点，但是因为anchor为0.2，所以子节点会向下偏移1&#x2F;5主轴长度的距离，因此图中第1个显示的为sliver-3.</p><p>下面分析RenderViewport的布局过程</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderViewport</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> performLayout() &#123;</span><br><span class="line">    <span class="keyword">switch</span> (axis) &#123;<span class="comment">//1、记录Viewport在主轴方向的大小</span></span><br><span class="line">      <span class="keyword">case</span> Axis.vertical:</span><br><span class="line">        offset.applyViewportDimension(size.height);</span><br><span class="line">      <span class="keyword">case</span> Axis.horizontal:</span><br><span class="line">        offset.applyViewportDimension(size.width);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (center == <span class="keyword">null</span>) &#123;<span class="comment">//2、判断Viewport中是否有列表内容</span></span><br><span class="line">      <span class="keyword">assert</span>(firstChild == <span class="keyword">null</span>);</span><br><span class="line">      _minScrollExtent = <span class="number">0.0</span>;</span><br><span class="line">      _maxScrollExtent = <span class="number">0.0</span>;</span><br><span class="line">      _hasVisualOverflow = <span class="keyword">false</span>;</span><br><span class="line">      offset.applyContentDimensions(<span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">double</span> mainAxisExtent;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">double</span> crossAxisExtent;</span><br><span class="line">    <span class="keyword">switch</span> (axis) &#123;<span class="comment">//3、计算当前Viewport在主轴和交叉轴方向的大小</span></span><br><span class="line">      <span class="keyword">case</span> Axis.vertical:</span><br><span class="line">        mainAxisExtent = size.height;</span><br><span class="line">        crossAxisExtent = size.width;</span><br><span class="line">      <span class="keyword">case</span> Axis.horizontal:</span><br><span class="line">        mainAxisExtent = size.width;</span><br><span class="line">        crossAxisExtent = size.height;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/// <span class="language-markdown">以上逻辑分为4步：</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">1、记录Viewport在主轴方向的大小</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">2、center默认为第1个子节点，如果不存在，则说明该Viewport中没有列表内容</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">3、计算当前Viewport在主轴和交叉轴方向的大小</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">4、解析完Viewport本身的信息之后，开始进行子节点的布局</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">double</span> centerOffsetAdjustment = center!.centerOffsetAdjustment;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">double</span> correction;</span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      correction = _attemptLayout(mainAxisExtent, crossAxisExtent, offset.pixels + centerOffsetAdjustment);<span class="comment">//真正的列表布局逻辑</span></span><br><span class="line">      <span class="keyword">if</span> (correction != <span class="number">0.0</span>) &#123;<span class="comment">//需要校正，一般在SliverList等动态创建Sliver时进行</span></span><br><span class="line">        offset.correctBy(correction);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (offset.applyContentDimensions(</span><br><span class="line">              math.min(<span class="number">0.0</span>, _minScrollExtent + mainAxisExtent * anchor),</span><br><span class="line">              math.max(<span class="number">0.0</span>, _maxScrollExtent - mainAxisExtent * (<span class="number">1.0</span> - anchor)),</span><br><span class="line">           )) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      count += <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (count &lt; _maxLayoutCycles);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">子节点的布局流程</span></span></span><br><span class="line">  <span class="built_in">double</span> _attemptLayout(<span class="built_in">double</span> mainAxisExtent, <span class="built_in">double</span> crossAxisExtent, <span class="built_in">double</span> correctedOffset) &#123;</span><br><span class="line">    _minScrollExtent = <span class="number">0.0</span>;</span><br><span class="line">    _maxScrollExtent = <span class="number">0.0</span>;</span><br><span class="line">    _hasVisualOverflow = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">double</span> centerOffset = mainAxisExtent * anchor - correctedOffset;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">double</span> reverseDirectionRemainingPaintExtent = clampDouble(centerOffset, <span class="number">0.0</span>, mainAxisExtent);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">double</span> forwardDirectionRemainingPaintExtent = clampDouble(mainAxisExtent - centerOffset, <span class="number">0.0</span>, mainAxisExtent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cacheExtentStyle) &#123;</span><br><span class="line">      <span class="keyword">case</span> CacheExtentStyle.pixel:</span><br><span class="line">        _calculatedCacheExtent = cacheExtent;</span><br><span class="line">      <span class="keyword">case</span> CacheExtentStyle.viewport:</span><br><span class="line">        _calculatedCacheExtent = mainAxisExtent * _cacheExtent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">double</span> fullCacheExtent = mainAxisExtent + <span class="number">2</span> * _calculatedCacheExtent!;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">double</span> centerCacheOffset = centerOffset + _calculatedCacheExtent!;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">double</span> reverseDirectionRemainingCacheExtent = clampDouble(centerCacheOffset, <span class="number">0.0</span>, fullCacheExtent);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">double</span> forwardDirectionRemainingCacheExtent = clampDouble(fullCacheExtent - centerCacheOffset, <span class="number">0.0</span>, fullCacheExtent);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">以上逻辑主要是开始正式布局前进行相关字段计算。correctedOffset通常就是用户的滑动距离offset.pixels，centerOffset时center相对Viewport顶部的偏移值（sliver-3的大小）。</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">reverseDirectionRemainingPaintExtent表示反（reverse）方向的剩余可绘制长度</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">forwardDirectionRemaningPaintExtent表示正（forwar）方向的剩余可绘制长度</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> RenderSliver? leadingNegativeChild = childBefore(center!);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leadingNegativeChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// negative scroll offsets</span></span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">double</span> result = layoutChildSequence(<span class="comment">//布局反方向的子节点</span></span><br><span class="line">        child: leadingNegativeChild,</span><br><span class="line">        scrollOffset: math.max(mainAxisExtent, centerOffset) - mainAxisExtent,</span><br><span class="line">        overlap: <span class="number">0.0</span>,</span><br><span class="line">        layoutOffset: forwardDirectionRemainingPaintExtent,</span><br><span class="line">        remainingPaintExtent: reverseDirectionRemainingPaintExtent,</span><br><span class="line">        mainAxisExtent: mainAxisExtent,</span><br><span class="line">        crossAxisExtent: crossAxisExtent,</span><br><span class="line">        growthDirection: GrowthDirection.reverse,</span><br><span class="line">        advance: childBefore,</span><br><span class="line">        remainingCacheExtent: reverseDirectionRemainingCacheExtent,</span><br><span class="line">        cacheOrigin: clampDouble(mainAxisExtent - centerOffset, -_calculatedCacheExtent!, <span class="number">0.0</span>),</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (result != <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// positive scroll offsets</span></span><br><span class="line">    <span class="keyword">return</span> layoutChildSequence(<span class="comment">//布局正方向的子节点</span></span><br><span class="line">      child: center, <span class="comment">//表示当前的Sliver节点</span></span><br><span class="line">      scrollOffset: math.max(<span class="number">0.0</span>, -centerOffset), <span class="comment">//表示center Sliver划过Viewport顶部的距离</span></span><br><span class="line">      overlap: leadingNegativeChild == <span class="keyword">null</span> ? math.min(<span class="number">0.0</span>, -centerOffset) : <span class="number">0.0</span>,</span><br><span class="line">      layoutOffset: centerOffset &gt;= mainAxisExtent ? centerOffset: reverseDirectionRemainingPaintExtent,</span><br><span class="line">      remainingPaintExtent: forwardDirectionRemainingPaintExtent,</span><br><span class="line">      mainAxisExtent: mainAxisExtent,</span><br><span class="line">      crossAxisExtent: crossAxisExtent,</span><br><span class="line">      growthDirection: GrowthDirection.forward,</span><br><span class="line">      advance: childAfter,</span><br><span class="line">      remainingCacheExtent: forwardDirectionRemainingCacheExtent,</span><br><span class="line">      cacheOrigin: clampDouble(centerOffset, -_calculatedCacheExtent!, <span class="number">0.0</span>),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Sliver%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B/sliver2.png"></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderViewportBase</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">计算SliverConstraints实例，并调用child.layout驱动子节点完成布局</span></span></span><br><span class="line">  <span class="built_in">double</span> layoutChildSequence(&#123;</span><br><span class="line">    <span class="keyword">required</span> RenderSliver? child,</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">double</span> scrollOffset,</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">double</span> overlap,</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">double</span> layoutOffset,</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">double</span> remainingPaintExtent,</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">double</span> mainAxisExtent,</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">double</span> crossAxisExtent,</span><br><span class="line">    <span class="keyword">required</span> GrowthDirection growthDirection,</span><br><span class="line">    <span class="keyword">required</span> RenderSliver? <span class="built_in">Function</span>(RenderSliver child) advance,</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">double</span> remainingCacheExtent,</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">double</span> cacheOrigin,</span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">double</span> initialLayoutOffset = layoutOffset;</span><br><span class="line">    <span class="keyword">final</span> ScrollDirection adjustedUserScrollDirection =</span><br><span class="line">        applyGrowthDirectionToScrollDirection(offset.userScrollDirection, growthDirection);</span><br><span class="line">    <span class="built_in">double</span> maxPaintOffset = layoutOffset + overlap;</span><br><span class="line">    <span class="built_in">double</span> precedingScrollExtent = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">double</span> sliverScrollOffset = scrollOffset &lt;= <span class="number">0.0</span> ? <span class="number">0.0</span> : scrollOffset;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">double</span> correctedCacheOrigin = math.max(cacheOrigin, -sliverScrollOffset);</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">double</span> cacheExtentCorrection = cacheOrigin - correctedCacheOrigin;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">assert</span>(sliverScrollOffset &gt;= correctedCacheOrigin.abs());</span><br><span class="line">      <span class="keyword">assert</span>(correctedCacheOrigin &lt;= <span class="number">0.0</span>);</span><br><span class="line">      <span class="keyword">assert</span>(sliverScrollOffset &gt;= <span class="number">0.0</span>);</span><br><span class="line">      <span class="keyword">assert</span>(cacheExtentCorrection &lt;= <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">      child.layout(SliverConstraints(<span class="comment">//触发子节点的布局</span></span><br><span class="line">        axisDirection: axisDirection,</span><br><span class="line">        growthDirection: growthDirection,</span><br><span class="line">        userScrollDirection: adjustedUserScrollDirection,</span><br><span class="line">        scrollOffset: sliverScrollOffset,</span><br><span class="line">        precedingScrollExtent: precedingScrollExtent,</span><br><span class="line">        overlap: maxPaintOffset - layoutOffset,</span><br><span class="line">        remainingPaintExtent: math.max(<span class="number">0.0</span>, remainingPaintExtent - layoutOffset + initialLayoutOffset),</span><br><span class="line">        crossAxisExtent: crossAxisExtent,</span><br><span class="line">        crossAxisDirection: crossAxisDirection,</span><br><span class="line">        viewportMainAxisExtent: mainAxisExtent,</span><br><span class="line">        remainingCacheExtent: math.max(<span class="number">0.0</span>, remainingCacheExtent + cacheExtentCorrection),</span><br><span class="line">        cacheOrigin: correctedCacheOrigin,</span><br><span class="line">      ), parentUsesSize: <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> SliverGeometry childLayoutGeometry = child.geometry!;</span><br><span class="line">      <span class="comment">// If there is a correction to apply, we&#x27;ll have to start over.</span></span><br><span class="line">      <span class="keyword">if</span> (childLayoutGeometry.scrollOffsetCorrection != <span class="keyword">null</span>) &#123;<span class="comment">//如果需要校正，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> childLayoutGeometry.scrollOffsetCorrection!;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We use the child&#x27;s paint origin in our coordinate system as the</span></span><br><span class="line">      <span class="comment">// layoutOffset we store in the child&#x27;s parent data.</span></span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">double</span> effectiveLayoutOffset = layoutOffset + childLayoutGeometry.paintOrigin;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (childLayoutGeometry.visible || scrollOffset &gt; <span class="number">0</span>) &#123;<span class="comment">//判断当前Sliver可见或者在Viewport上面</span></span><br><span class="line">        updateChildLayoutOffset(child, effectiveLayoutOffset, growthDirection);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        updateChildLayoutOffset(child, -scrollOffset + initialLayoutOffset, growthDirection);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      maxPaintOffset = math.max(effectiveLayoutOffset + childLayoutGeometry.paintExtent, maxPaintOffset);</span><br><span class="line">      scrollOffset -= childLayoutGeometry.scrollExtent;</span><br><span class="line">      precedingScrollExtent += childLayoutGeometry.scrollExtent;</span><br><span class="line">      layoutOffset += childLayoutGeometry.layoutExtent;</span><br><span class="line">      <span class="keyword">if</span> (childLayoutGeometry.cacheExtent != <span class="number">0.0</span>) &#123;</span><br><span class="line">        remainingCacheExtent -= childLayoutGeometry.cacheExtent - cacheExtentCorrection;</span><br><span class="line">        cacheOrigin = math.min(correctedCacheOrigin + childLayoutGeometry.cacheExtent, <span class="number">0.0</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      updateOutOfBandData(growthDirection, childLayoutGeometry);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// move on to the next child</span></span><br><span class="line">      child = advance(child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we made it without a correction, whee!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SliverConstraints</span> </span>&#123;</span><br><span class="line">  <span class="comment">//表示列表中forwar Sliver的增长方向，最常用的事AxisDirection.down，表示列表从上到下递增，此时scrollOffset向上增加，remainingPaintExtent向下增加</span></span><br><span class="line">  <span class="keyword">final</span> AxisDirection axisDirection;</span><br><span class="line"><span class="comment">// 表示Sliver增长的方向，forward表示与axisDirection方向相同，是center Sliver之后的节点；reverse表示与axisDirection方向相反，时center Sliver之前的节点</span></span><br><span class="line">  <span class="keyword">final</span> GrowthDirection growthDirection;</span><br><span class="line">  <span class="comment">//滑动方向</span></span><br><span class="line">  <span class="keyword">final</span> ScrollDirection userScrollDirection;</span><br><span class="line">  <span class="comment">//表示center Sliver滑过Viewport的距离，以AxisDirection.down为例，滑过Viewport顶部的距离即scrollOffset</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> scrollOffset;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> precedingScrollExtent;</span><br><span class="line">  <span class="comment">//表示上一个Sliver覆盖下一个Sliver的大小</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> overlap;</span><br><span class="line">  <span class="comment">// 表示对当前节点而言，剩余绘制区域大小</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> remainingPaintExtent;</span><br><span class="line">  <span class="comment">//交叉轴方向的大小</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> crossAxisExtent;</span><br><span class="line">  <span class="comment">//交叉轴方向的布局顺序</span></span><br><span class="line">  <span class="keyword">final</span> AxisDirection crossAxisDirection;</span><br><span class="line">  <span class="comment">//主轴方向的大小</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> viewportMainAxisExtent;</span><br><span class="line">  <span class="comment">//剩余缓冲区大小</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> remainingCacheExtent;</span><br><span class="line">  <span class="comment">//表示当前Sliver可使用的Viewport顶部缓冲区的大小</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> cacheOrigin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Sliver%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B/sliver3.png"></p><p>以上便是Viewport布局的核心流程，确定每个子节点的大小和偏移值，下一个子节点基于此计算自己的大小和偏移值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SliverGeometry</span> <span class="title">with</span> <span class="title">Diagnosticable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> scrollExtent;<span class="comment">//当前Sliver在列表中的可滚动长度，一般就是Sliver本身的长度</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> paintOrigin;<span class="comment">//当前Sliver开始绘制的起点，相对当前Sliver的布局起点而言</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> paintExtent;<span class="comment">//当前Sliver需要绘制在可视区域Viewport中的长度</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> layoutExtent;<span class="comment">//当前Sliver需要布局的长度，默认为paintExtent</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> maxPaintExtent;<span class="comment">//当前Sliver的最大绘制长度</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> maxScrollObstructionExtent;<span class="comment">//当Sliver被固定在Viewport边缘时占据的最大长度</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> hitTestExtent;<span class="comment">//相应点击的区域长度，默认值为paintExtent</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> visible;<span class="comment">//当前Sliver是否可见，不可见则paintExtent为0</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> hasVisualOverflow;<span class="comment">//当前Sliver是否溢出Viewport，通常是在滑入、滑出时发生</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double?</span> scrollOffsetCorrection;<span class="comment">//校正值</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">double</span> cacheExtent;<span class="comment">//当前Sliver消耗的缓冲区大小</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分析SLiver的ParentData实例的更新</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderViewport</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> updateChildLayoutOffset(RenderSliver child, <span class="built_in">double</span> layoutOffset, GrowthDirection growthDirection) &#123;</span><br><span class="line">    <span class="keyword">final</span> SliverPhysicalParentData childParentData = child.parentData! <span class="keyword">as</span> SliverPhysicalParentData;</span><br><span class="line">    childParentData.paintOffset = computeAbsolutePaintOffset(child, layoutOffset, growthDirection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">计算不同方向下的子节点偏移</span></span></span><br><span class="line">  Offset computeAbsolutePaintOffset(RenderSliver child, <span class="built_in">double</span> layoutOffset, GrowthDirection growthDirection) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (applyGrowthDirectionToAxisDirection(axisDirection, growthDirection)) &#123;</span><br><span class="line">      <span class="keyword">case</span> AxisDirection.up:</span><br><span class="line">        <span class="keyword">return</span> Offset(<span class="number">0.0</span>, size.height - (layoutOffset + child.geometry!.paintExtent));</span><br><span class="line">      <span class="keyword">case</span> AxisDirection.right:</span><br><span class="line">        <span class="keyword">return</span> Offset(layoutOffset, <span class="number">0.0</span>);</span><br><span class="line">      <span class="keyword">case</span> AxisDirection.down:</span><br><span class="line">        <span class="keyword">return</span> Offset(<span class="number">0.0</span>, layoutOffset);</span><br><span class="line">      <span class="keyword">case</span> AxisDirection.left:</span><br><span class="line">        <span class="keyword">return</span> Offset(size.width - (layoutOffset + child.geometry!.paintExtent), <span class="number">0.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">更新可滚动距离</span></span></span><br><span class="line">  <span class="keyword">void</span> updateOutOfBandData(GrowthDirection growthDirection, SliverGeometry childLayoutGeometry) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (growthDirection) &#123;</span><br><span class="line">      <span class="keyword">case</span> GrowthDirection.forward:</span><br><span class="line">        _maxScrollExtent += childLayoutGeometry.scrollExtent;</span><br><span class="line">      <span class="keyword">case</span> GrowthDirection.reverse:</span><br><span class="line">        _minScrollExtent -= childLayoutGeometry.scrollExtent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (childLayoutGeometry.hasVisualOverflow) &#123;</span><br><span class="line">      _hasVisualOverflow = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Sliver%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B/sliver4.png"></p><h2 id="RenderSliverToBoxAdapter布局流程分析"><a href="#RenderSliverToBoxAdapter布局流程分析" class="headerlink" title="RenderSliverToBoxAdapter布局流程分析"></a>RenderSliverToBoxAdapter布局流程分析</h2><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Sliver%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B/sliver5.png"></p><p>RenderSliver的子类分类：</p><ul><li>RenderSliverSingleBoxAdapter：可以封装一个子节点</li><li>RenderSliverMultiBoxAdaptor：可以封装多个子节点，比如SliverList、SliverGrid</li><li>RenderSliverPersistentHeader：它是SliverAppBar的底层实现，是对overlap属性的典型应用</li></ul><p>下面以RenderSliverToBoxAdapter为例，分析RenderSliver节点自身的布局，它可以将一个Box类型的Widget放在列表中使用，那么其中必然涉及SliverConstraints到BoxConstraints的转换，因为Box类型的RenderObject只接受BoxConstraints作为约束，此外Box类型的RenderObject返回的Size信息也需要转换为SliverGeometry，否则Viewport无法解析。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderSliverToBoxAdapter</span> <span class="keyword">extends</span> <span class="title">RenderSliverSingleBoxAdapter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> performLayout() &#123;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">      geometry = SliverGeometry.zero;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> SliverConstraints constraints = <span class="keyword">this</span>.constraints;<span class="comment">//1、将SliverConstraints转换为BoxConstraints</span></span><br><span class="line">    child!.layout(constraints.asBoxConstraints(), parentUsesSize: <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">double</span> childExtent;</span><br><span class="line">    <span class="keyword">switch</span> (constraints.axis) &#123;<span class="comment">//2、根据主轴方向确定子节点所占用的空间大小</span></span><br><span class="line">      <span class="keyword">case</span> Axis.horizontal:</span><br><span class="line">        childExtent = child!.size.width;</span><br><span class="line">      <span class="keyword">case</span> Axis.vertical:</span><br><span class="line">        childExtent = child!.size.height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、根据子节点在主轴占据的空间大小以及当前约束绘制大小</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">double</span> paintedChildSize = calculatePaintOffset(constraints, from: <span class="number">0.0</span>, to: childExtent);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">double</span> cacheExtent = calculateCacheOffset(constraints, from: <span class="number">0.0</span>, to: childExtent);</span><br><span class="line"></span><br><span class="line">    geometry = SliverGeometry(<span class="comment">//4、计算SliverGeometry</span></span><br><span class="line">      scrollExtent: childExtent,</span><br><span class="line">      paintExtent: paintedChildSize,</span><br><span class="line">      cacheExtent: cacheExtent,</span><br><span class="line">      maxPaintExtent: childExtent,</span><br><span class="line">      hitTestExtent: paintedChildSize,</span><br><span class="line">      hasVisualOverflow: childExtent &gt; constraints.remainingPaintExtent || constraints.scrollOffset &gt; <span class="number">0.0</span>,</span><br><span class="line">    );</span><br><span class="line">    setChildParentData(child!, constraints, geometry!);<span class="comment">//5、为子节点绘制偏移</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SliverConstraints转换为BoxConstraints"><a href="#SliverConstraints转换为BoxConstraints" class="headerlink" title="SliverConstraints转换为BoxConstraints"></a>SliverConstraints转换为BoxConstraints</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SliverConstraints</span> <span class="keyword">extends</span> <span class="title">Constraints</span> </span>&#123;</span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  BoxConstraints asBoxConstraints(&#123;</span><br><span class="line">    <span class="built_in">double</span> minExtent = <span class="number">0.0</span>,</span><br><span class="line">    <span class="built_in">double</span> maxExtent = <span class="built_in">double</span>.infinity,</span><br><span class="line">    <span class="built_in">double?</span> crossAxisExtent,</span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    crossAxisExtent ??= <span class="keyword">this</span>.crossAxisExtent;</span><br><span class="line">    <span class="keyword">switch</span> (axis) &#123;</span><br><span class="line">      <span class="keyword">case</span> Axis.horizontal:</span><br><span class="line">        <span class="keyword">return</span> BoxConstraints(</span><br><span class="line">          minHeight: crossAxisExtent,</span><br><span class="line">          maxHeight: crossAxisExtent,</span><br><span class="line">          minWidth: minExtent,</span><br><span class="line">          maxWidth: maxExtent,</span><br><span class="line">        );</span><br><span class="line">      <span class="keyword">case</span> Axis.vertical:</span><br><span class="line">        <span class="keyword">return</span> BoxConstraints(</span><br><span class="line">          minWidth: crossAxisExtent,</span><br><span class="line">          maxWidth: crossAxisExtent,</span><br><span class="line">          minHeight: minExtent,</span><br><span class="line">          maxHeight: maxExtent,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>paintedChildSize是如何计算的呢？</p><h3 id="setChildParentData"><a href="#setChildParentData" class="headerlink" title="setChildParentData"></a>setChildParentData</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderSliverSingleBoxAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">用于解决一些特殊的边界情况</span></span></span><br><span class="line">  <span class="keyword">void</span> setChildParentData(RenderObject child, SliverConstraints constraints, SliverGeometry geometry) &#123;</span><br><span class="line">    <span class="keyword">final</span> SliverPhysicalParentData childParentData = child.parentData! <span class="keyword">as</span> SliverPhysicalParentData;</span><br><span class="line">    <span class="keyword">switch</span> (applyGrowthDirectionToAxisDirection(constraints.axisDirection, constraints.growthDirection)) &#123;</span><br><span class="line">      <span class="keyword">case</span> AxisDirection.up:</span><br><span class="line">        childParentData.paintOffset = Offset(<span class="number">0.0</span>, -(geometry.scrollExtent - (geometry.paintExtent + constraints.scrollOffset)));</span><br><span class="line">      <span class="keyword">case</span> AxisDirection.right:</span><br><span class="line">        childParentData.paintOffset = Offset(-constraints.scrollOffset, <span class="number">0.0</span>);</span><br><span class="line">      <span class="keyword">case</span> AxisDirection.down:</span><br><span class="line">        childParentData.paintOffset = Offset(<span class="number">0.0</span>, -constraints.scrollOffset);</span><br><span class="line">      <span class="keyword">case</span> AxisDirection.left:</span><br><span class="line">        childParentData.paintOffset = Offset(-(geometry.scrollExtent - (geometry.paintExtent + constraints.scrollOffset)), <span class="number">0.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span> &amp;&amp; geometry!.visible) &#123;</span><br><span class="line">      <span class="keyword">final</span> SliverPhysicalParentData childParentData = child!.parentData! <span class="keyword">as</span> SliverPhysicalParentData;</span><br><span class="line">      context.paintChild(child!, offset + childParentData.paintOffset);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Sliver%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B/sliver6.png"></p><p>如图，对完全处于Viewport内的Sliver而言，constraints.scrollOffset为0，子节点的paintOffset为(0,0)。此时子节点从Sliver的左上角开始绘制。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href>Flutter源码内核剖析</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Flutter中，列表的每个Item被称为Sliver。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Sliver%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Widget</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Widget/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Widget/</id>
    <published>2024-08-02T13:15:20.037Z</published>
    <updated>2024-08-02T13:15:20.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@immutable</span> <span class="comment">// 不可变</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> </span>&#123; <span class="comment">//DiagnosticableTree提供调试信息</span></span><br><span class="line">  <span class="keyword">const</span> Widget(&#123; <span class="keyword">this</span>.key &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Key? key;<span class="comment">//canUpdate中判断前后的key是否相同，则使用新的Widget配置更新Element对象，否则创建新的Element对象</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@factory</span></span><br><span class="line">  <span class="built_in">Element</span> createElement();<span class="comment">//每个Widget都有对应的Element。Widget树根Element树对应</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toStringShort() &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> type = objectRuntimeType(<span class="keyword">this</span>, <span class="string">&#x27;Widget&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> key == <span class="keyword">null</span> ? type : <span class="string">&#x27;<span class="subst">$type</span>-<span class="subst">$key</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;</span><br><span class="line">    <span class="keyword">super</span>.debugFillProperties(properties);</span><br><span class="line">    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="meta">@nonVirtual</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">operator</span> ==(<span class="built_in">Object</span> other) =&gt; <span class="keyword">super</span> == other;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="meta">@nonVirtual</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> hashCode =&gt; <span class="keyword">super</span>.hashCode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否可以用newWidget修改前一帧oldWidget生成的Element，而不是创建新的Element</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class="line">    <span class="keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class="line">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Widget的特点：</p><ul><li>声明式UI，描述UI的层级结构、样式、布局过程</li><li>Widget都是不可变的，对于变化的部分通过Stateful Widget-State的方式实现，也就是我们开发中使用的StatefulWidget，操作逻辑在State中</li></ul><p>开发过程中，我们会使用<code>StatelessWidget</code>和<code>StatefulWidget</code>，这两个类都继承自<code>Widget</code>。而整个过程就是将Widget树转换成Element树，再转换成RenderObject树，最终通过底层skia绘制。</p><p>如果我们绘制的UI也是不可变的，那么我们可以使用<code>StatelessWidget</code>，这样在创建的时候绘制一次即可。如果UI需要根据状态发生变化，那么我们可以使用<code>StatefulWidget</code>。对于<code>StatefulWidget</code>，我们需要实现<code>State</code>类，这个类持有<code>Widget</code>和<code>Element</code>，用来管理<code>Widget</code>的状态。</p><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Widget/Widget.png"></p><p>Widget大致可以分为3类：</p><ul><li>Component Widget，组合类Widget，通过组合单一的Widget可以获得复杂的Widget</li><li>Proxy Widget，代理类Widget，本身不涉及Widget内部逻辑，只是为Child Widget提供一些附加的中间功能。比如InheritedWidget用于传递共享信息、ParentDataWidget用于配置布局信息</li><li>RenderObjectWidget，渲染类Widget，参与Layout、Paint流程，其有对应的RenderObject</li></ul><h2 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> FooWidget(&#123;<span class="keyword">super</span>.key&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下三种情况会被调用：</span></span><br><span class="line"><span class="comment">// 1. Widget第一次插入到树中时，mount时调用</span></span><br><span class="line"><span class="comment">// 2. Parent Widget修改了配置信息</span></span><br><span class="line"><span class="comment">// 3. InheritedWidget发生变化时</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const</span> Placeholder();<span class="comment">//通过不同Widget的组合来构建UI</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StatefulWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> StatefulWidget(&#123; Key key &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  StatefulElement createElement() =&gt; StatefulElement(<span class="keyword">this</span>);<span class="comment">//Element持有该Widget，回调State对应的生命周期方法</span></span><br><span class="line">    </span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  State createState();<span class="comment">//开发者通过不同的生命周期方法来管理Widget的状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span>&gt; <span class="title">with</span> <span class="title">Diagnosticable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  T <span class="keyword">get</span> widget =&gt; _widget!;<span class="comment">//持有Widget对象</span></span><br><span class="line">  T? _widget;</span><br><span class="line"></span><br><span class="line">  _StateLifecycle _debugLifecycleState = _StateLifecycle.created;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> _debugTypesAreRight(Widget widget) =&gt; widget <span class="keyword">is</span> T;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 持有对应Element</span></span><br><span class="line">  BuildContext <span class="keyword">get</span> context &#123;</span><br><span class="line">    <span class="keyword">return</span> _element!;</span><br><span class="line">  &#125;</span><br><span class="line">  StatefulElement? _element;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否挂载在树上</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> mounted =&gt; _element != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生命周期初始化方法</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// canUpdate返回true则会调用此方法</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> didUpdateWidget(<span class="keyword">covariant</span> T oldWidget) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// hot reload时触发</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> reassemble() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用这个方法会重新构建当前Widget</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> setState(VoidCallback fn) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Object?</span> result = fn() <span class="keyword">as</span> <span class="built_in">dynamic</span>;</span><br><span class="line">    _element!.markNeedsBuild();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从树中移除时回调，如果没有重新添加到树上，那么会调用dispose</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> deactivate() &#123; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> activate() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁时回调</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">if</span> (kFlutterMemoryAllocationsEnabled) &#123;</span><br><span class="line">      MemoryAllocations.instance.dispatchObjectDisposed(object: <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建UI</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  Widget build(BuildContext context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化，依赖的InheritedWidget发生变化时会调用</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Widget的子类"><a href="#Widget的子类" class="headerlink" title="Widget的子类"></a>Widget的子类</h2><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Widget/Widget%E5%AD%90%E7%B1%BB.png"></p><h3 id="ParentDataWidget"><a href="#ParentDataWidget" class="headerlink" title="ParentDataWidget"></a>ParentDataWidget</h3><p>ParentDataWidget作为 Proxy 型 Widget，其功能主要是为其他 Widget 提供ParentData信息。虽然其 child widget 不一定是 RenderObejctWidget 类型，但其提供的ParentData信息最终都会落地到 RenderObejctWidget 类型子孙 Widget 上。</p><p>比如Positioned</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Positioned</span> <span class="keyword">extends</span> <span class="title">ParentDataWidget</span>&lt;<span class="title">StackParentData</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> applyParentData(RenderObject renderObject) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(renderObject.parentData <span class="keyword">is</span> StackParentData);</span><br><span class="line">    <span class="keyword">final</span> StackParentData parentData = renderObject.parentData! <span class="keyword">as</span> StackParentData;</span><br><span class="line">    <span class="built_in">bool</span> needsLayout = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parentData.left != left) &#123;</span><br><span class="line">      parentData.left = left;</span><br><span class="line">      needsLayout = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parentData.top != top) &#123;</span><br><span class="line">      parentData.top = top;<span class="comment">//设置父节点属性</span></span><br><span class="line">      needsLayout = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (needsLayout) &#123;</span><br><span class="line">      <span class="keyword">final</span> RenderObject? targetParent = renderObject.parent;</span><br><span class="line">      <span class="keyword">if</span> (targetParent <span class="keyword">is</span> RenderObject) &#123;</span><br><span class="line">        targetParent.markNeedsLayout();<span class="comment">//标记重新布局</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h3><p>参考<a href="./InheritedWidget.md">InheritedWidget</a></p><h3 id="RenderObjectWidget"><a href="#RenderObjectWidget" class="headerlink" title="RenderObjectWidget"></a>RenderObjectWidget</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObjectWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> RenderObjectWidget(&#123; <span class="keyword">super</span>.key &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="meta">@factory</span></span><br><span class="line">  RenderObjectElement createElement();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建Widget对应的RenderObject，mount时调用</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@factory</span></span><br><span class="line">  RenderObject createRenderObject(BuildContext context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Widget更新后，修改对应的RenderObject</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> updateRenderObject(BuildContext context, <span class="keyword">covariant</span> RenderObject renderObject) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> didUnmountRenderObject(<span class="keyword">covariant</span> RenderObject renderObject) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>RenderObjectWidget的几个子类：LeafRenderObjectWidget、SingleChildRenderObjectWidget、MultiChildRenderObjectWidget只是重写了createElement方法以便返回各自对应的具体的 Element 类实例。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zxfcumtcs.github.io/2020/05/01/deepinto-flutter-widget/">深入浅出 Flutter Framework 之 Widget</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Widget&quot;&gt;&lt;a href=&quot;#Widget&quot; class=&quot;headerlink&quot; title=&quot;Widget&quot;&gt;&lt;/a&gt;Widget&lt;/h2&gt;&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>RenderObject</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RenderObject/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RenderObject/</id>
    <published>2024-08-02T13:15:20.036Z</published>
    <updated>2024-08-02T13:15:20.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>RenderObject表示渲染树的一个对象，其职责包括：Layout、Paint、Hit Testing。</p><p><strong>作用：</strong></p><ul><li>布局，从RenderBox开始，对RenderObject Tree从上至下进行布局。</li><li>绘制，通过Canvas对象，RenderObject可以绘制自身以及其在RenderObject Tree中的子节点。</li><li>点击测试，RenderObject从上至下传递点击事件，并通过其位置和behavior来控制是否响应点击事件。</li></ul><p>插槽（slot）：所谓插槽，就是预留一个接口或位置，由其他对象来接入或占据。</p><p>RenderObject拥有一个parent和parentData插槽（slot）：</p><ul><li>parentData：负责存储父节点所需要的子节点的布局信息。该成员只能通过setupParentData方法赋值，RenderObject的子类通过重写该方法将ParentData的子类赋值给parentData，已扩展ParentData功能。</li><li>layout()：布局阶段，父节点会调用子节点的该方法。</li><li>markNeedsLayout()：标记下一个frame重新layout。</li><li>paint()：绘制</li><li>layer：</li><li>isRepaintBoundary：绘制边界点，单独的一层渲染，提升性能</li><li>needsCompositing：</li></ul><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RenderObject/RenderObjectClassDiagram.png"></p><h3 id="RenderObject子类"><a href="#RenderObject子类" class="headerlink" title="RenderObject子类"></a>RenderObject子类</h3><ul><li>RenderView：Render Object Tree的根节点</li><li>RenderBox：采用2D笛卡尔坐标系中的渲染对象。它实现了一个内在的尺寸调整协议，它允许您在没有完全铺设的情况下测量一个子级，以这样的方式，如果该子级改变了尺寸，父级将再次布置（考虑到子级的新尺寸）。若对坐标系统没有限制，可直接继承它来实现自定义RenderObject。size属性用来保存控件的高宽。其layout是通过在组件树中从上往下传递BoxConstraints对象实现的。<ul><li>performResize()：测量</li><li>performLayout()：布局</li></ul></li><li>RenderView：渲染对象的根。它有单独的子级，它必须是一个RenderBox。因此，如果你想在渲染树中有一个自定义的RenderObject子类，你有两种选择：你可能需要替换RenderView本身，或者你需要一个RenderBox作为它的子类。</li><li>RenderAbstractViewport：内部较大的渲染对象的界面。其渲染对象（如RenderViewport）显示其内容的一部分，可以通过ViewportOffset进行控制。</li><li>RenderSliver：在视图中实现滚动效果的渲染对象的基类。RenderViewport有一组子Sliver，每个Sliver依次排列，覆盖过程中的视图。而RenderSliver则控制着Sliver的绘制渲染。</li></ul><p>RenderObjectWithChildMixin为只有一个child的RenderObject提供child管理模型，ContainerRenderObjectMixin用于为多个child的RenderObject提供child管理模型。</p><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RenderObject/RenderObject_XMind.png"></p><h3 id="核心函数比较"><a href="#核心函数比较" class="headerlink" title="核心函数比较"></a>核心函数比较</h3><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RenderObject/RendObject_2.png"></p><table><thead><tr><th>作用</th><th>Flutter RenderObject</th><th>Android View</th></tr></thead><tbody><tr><td>绘制</td><td>paint()</td><td>draw()&#x2F;onDraw()</td></tr><tr><td>布局</td><td>performLayout()&#x2F;layout()</td><td>measure()&#x2F;onMeasure(), layout()&#x2F;onLayout()</td></tr><tr><td>布局约束</td><td>Constraints</td><td>MeasureSpec</td></tr><tr><td>布局协议1</td><td>performLayout() 的 Constraints 参数表示父节点对子节点的布局限制</td><td>measure() 的两个参数表示父节点对子节点的布局限制</td></tr><tr><td>布局协议2</td><td>performLayout() 应调用各子节点的 layout()</td><td>onLayout() 应调用各子节点的 layout()</td></tr><tr><td>布局参数</td><td>parentData</td><td>mLayoutParams</td></tr><tr><td>请求布局</td><td>markNeedsLayout()</td><td>requestLayout()</td></tr><tr><td>请求绘制</td><td>markNeedsPaint()</td><td>invalidate()</td></tr><tr><td>添加</td><td>child adoptChild()</td><td>addView()</td></tr><tr><td>移除</td><td>child dropChild()</td><td>removeView()</td></tr><tr><td>关联到窗口&#x2F;树</td><td>attach()</td><td>onAttachedToWindow()</td></tr><tr><td>从窗口&#x2F;树取消关联</td><td>detach()</td><td>onDetachedFromWindow()</td></tr><tr><td>获取 parent</td><td>parent</td><td>getParent()</td></tr><tr><td>触摸事件</td><td>hitTest()</td><td>onTouch()</td></tr><tr><td>用户输入事件</td><td>handleEvent()</td><td>onKey()</td></tr><tr><td>旋转事件</td><td>rotate()</td><td>onConfigurationChanged()</td></tr></tbody></table><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RenderObject/renderobject_1.png"></p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>Widget中有对应的createRenderObject方法，mount时调用，用于创建Widget对应的RenderObject。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RenderObjectElement</span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">  attachRenderObject(newSlot);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>当RenderObject需要（重新）布局时调用markNeedLayout，从而被PipelineOwner收集，并在下一帧刷新时触发Layout操作</p><h3 id="markNeedsLayout调用场景"><a href="#markNeedsLayout调用场景" class="headerlink" title="markNeedsLayout调用场景"></a>markNeedsLayout调用场景</h3><ul><li>Render Object 被添加到『 RenderObject Tree 』;</li><li>子节点 adopt、drop、move；</li><li>由子节点的markNeedsLayout方法传递调用；</li><li>Render Object 自身与布局相关的属性发生变化，如RenderFlex的排版方向有变化时：</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> direction(Axis value) &#123;</span><br><span class="line">  <span class="keyword">if</span> (_direction != value) &#123;</span><br><span class="line">    _direction = value;</span><br><span class="line">    markNeedsLayout();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Relayout-Boundary"><a href="#Relayout-Boundary" class="headerlink" title="Relayout Boundary"></a>Relayout Boundary</h3><p>若某个 Render Object 的布局变化不会影响到其父节点的布局，则该 Render Object 就是『 Relayout Boundary 』。<br>Relayout Boundary 是一项重要的优化措施，可以避免不必要的 re-layout。<br>当某个 Render Object 是 Relayout Boundary 时，会切断 layout dirty 向父节点传播，即下一帧刷新时父节点无需 re-layout。</p><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RenderObject/RelayoutBoundary.png"></p><ul><li>若RD节点出现 layout dirty，由于其自身、其父节点RA、RRoot都不是 Relayout Boundary，最终 layout dirty 传播到根节点RenderView，导致整颗『 RenderObject Tree 』重新布局；</li><li>若RF节点出现 layout dirty，由于其父节点RB为 Relayout Boundary，layout dirty 传播到RB即结束，最终需要重新布局的只有RB、RF两个节点；</li><li>若RG节点出现 layout dirty，由于其自身就是 Relayout Boundary，最终需要重新布局的只有RG自己。</li></ul><p>那么，要成为Relayout Boundary，需要什么条件？</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> layout(Constraints constraints, &#123; <span class="built_in">bool</span> parentUsesSize = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">    RenderObject relayoutBoundary;</span><br><span class="line">    <span class="keyword">if</span> (!parentUsesSize || sizedByParent || constraints.isTight || parent <span class="keyword">is</span>! RenderObject) &#123;</span><br><span class="line">      relayoutBoundary = <span class="keyword">this</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      relayoutBoundary = (parent <span class="keyword">as</span> RenderObject)._relayoutBoundary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _constraints = constraints;</span><br><span class="line">    <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">null</span> &amp;&amp; relayoutBoundary != _relayoutBoundary) &#123;</span><br><span class="line">      visitChildren(_cleanChildRelayoutBoundary);</span><br><span class="line">    &#125;</span><br><span class="line">    _relayoutBoundary = relayoutBoundary;</span><br><span class="line"></span><br><span class="line">    performLayout();</span><br><span class="line">    markNeedsSemanticsUpdate();</span><br><span class="line">    markNeedsPaint();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>满足以下条件之一即可：</p><ul><li>parentUsesSize为false，即父节点在 layout 时不会使用当前节点的 size 信息(也就是当前节点的排版信息对父节点无影响)；</li><li>sizedByParent为true，即当前节点的 size 完全由父节点的 constraints 决定，即若在两次 layout 中传递下来的 constraints 相同，则两次 layout 后当前节点的 size 也相同；</li><li>传给当前节点的 constraints 是紧凑型 (Tight)，其效果与sizedByParent为true是一样的，即当前节点的 layout 不会改变其 size，size 由 constraints 唯一确定；</li><li>父节点不是 RenderObject 类型(主要针对根节点，其父节点为nil)。</li></ul><h3 id="markNeedsLayout"><a href="#markNeedsLayout" class="headerlink" title="markNeedsLayout"></a>markNeedsLayout</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> markNeedsLayout() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_needsLayout) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">this</span>) &#123;</span><br><span class="line">    markParentNeedsLayout();</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _needsLayout = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">      owner._nodesNeedingLayout.add(<span class="keyword">this</span>);</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>若当前 Render Object 不是 Relayout Boundary，则 layout 请求向上传播给父节点(即 layout 范围扩大到父节点，这是一个递归过程，直到遇到 Relayout Boundary)；</li><li>若当前 Render Object 是 Relayout Boundary，则 layout 请求到该节点为此，不会传播到其父节点。</li></ul><h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> layout(Constraints constraints, &#123; <span class="built_in">bool</span> parentUsesSize = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">  RenderObject relayoutBoundary;</span><br><span class="line">  <span class="keyword">if</span> (!parentUsesSize || sizedByParent || constraints.isTight || parent <span class="keyword">is</span>! RenderObject) &#123;</span><br><span class="line">    relayoutBoundary = <span class="keyword">this</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    relayoutBoundary = (parent <span class="keyword">as</span> RenderObject)._relayoutBoundary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _constraints = constraints;</span><br><span class="line">  <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">null</span> &amp;&amp; relayoutBoundary != _relayoutBoundary) &#123;</span><br><span class="line">    visitChildren(_cleanChildRelayoutBoundary);</span><br><span class="line">  &#125;</span><br><span class="line">  _relayoutBoundary = relayoutBoundary;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sizedByParent) &#123;</span><br><span class="line">    performResize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  performLayout();</span><br><span class="line">  markNeedsSemanticsUpdate();</span><br><span class="line">  </span><br><span class="line">  _needsLayout = <span class="keyword">false</span>;</span><br><span class="line">  markNeedsPaint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>layout方法是触发Render Object更新布局信息的主要入口点。一般情况下，由父节点调用子节点的layout方法来更新其整体布局。<br>RenderObject的子类不应重写该方法，可按需重写performResize或&#x2F;和performLayout方法。<br>当前 Render Object 的布局受到layout方法参数constraints的约束。</p><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RenderObject/LayputDataFlow.png"></p><p>如上图，『 Render Object Tree 』的 layout 是一次深度优先遍历的过程。<br>优先 layout 子节点，之后 layout 父节点。<br>父节点向子节点传递 layout constraints，子节点在 layout 时需遵守这些约束。<br>作为子节点 layout 的结果，父节点在 layout 时可以使用子节点的 size。</p><p>在上述layout代码第19~21行，若sizedByParent为true，则调用performResize来计算该 Render Object 的 size。</p><p>sizedByParent为true的 Render Object 需重写performResize方法，在该方法中仅根据constraints来计算 size。<br>如RenderBox中定义的performResize的默认行为：取constraints约束下的最小 size：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> performResize() &#123;</span><br><span class="line">  <span class="comment">// default behavior for subclasses that have sizedByParent = true</span></span><br><span class="line">  size = constraints.smallest;</span><br><span class="line">  <span class="keyword">assert</span>(size.isFinite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若父节点 layout 依赖子节点的 size，在调用layout方法时需将parentUsesSize参数设为true。<br>因为，在这种情况下若子节点 re-layout 导致其 size 发生变化，需要及时通知父节点，父节点也需要 re-layout (即 layout dirty 范围需要向上传播)。<br>这一切都是通过上节介绍过的 Relayout Boundary 来实现。</p><h3 id="performLayout"><a href="#performLayout" class="headerlink" title="performLayout"></a>performLayout</h3><p>本质上，layout是一个模板方法，具体的布局工作由performLayout方法完成。<br>RenderObject#performLayout是一个抽象方法，子类需重写。</p><p>关于performLayout有几点需要注意：</p><ul><li>该方法由layout方法调用，在需要 re-layout 时应调用layout方法，而不是performLayout；</li><li>若sizedByParent为true，则该方法不应改变当前 Render Object 的 size ( 其 size 由performResize方法计算)；</li><li>若sizedByParent为false，则该方法不仅要执行 layout 操作，还要计算当前 Render Object 的 size；</li><li>在该方法中，需对其所有子节点调用layout方法以执行所有子节点的 layout 操作，如果当前 Render Object 依赖子节点的布局信息，需将parentUsesSize参数设为true。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RenderFlex</span></span><br><span class="line"><span class="keyword">void</span> performLayout() &#123;</span><br><span class="line">  RenderBox child = firstChild;</span><br><span class="line">  <span class="keyword">while</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> FlexParentData childParentData = child.parentData;</span><br><span class="line">    BoxConstraints innerConstraints = BoxConstraints(minHeight: constraints.maxHeight, maxHeight: constraints.maxHeight);</span><br><span class="line">    child.layout(innerConstraints, parentUsesSize: <span class="keyword">true</span>);</span><br><span class="line">    child = childParentData.nextSibling;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  size = constraints.constrain(Size(idealSize, crossSize));</span><br><span class="line">  </span><br><span class="line">  child = firstChild;</span><br><span class="line">  <span class="keyword">while</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> FlexParentData childParentData = child.parentData;</span><br><span class="line">    <span class="built_in">double</span> childCrossPosition = crossSize / <span class="number">2.0</span> - _getCrossSize(child) / <span class="number">2.0</span>;</span><br><span class="line">    childParentData.offset = Offset(childMainPosition, childCrossPosition);</span><br><span class="line">    child = childParentData.nextSibling;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码片段截取自RenderFlex，可以看到它大概做了3件事：</p><ul><li>对所有子节点逐个调用layout方法；</li><li>计算当前 Render Object 的 size；</li><li>将与子节点布局有关的信息存储到相应子节点的parentData中。</li></ul><blockquote><p>RenderFlex继承自RenderBox，是常用的Row、Column对应的 Render Object</p></blockquote><h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><h3 id="markNeedsPaint"><a href="#markNeedsPaint" class="headerlink" title="markNeedsPaint"></a>markNeedsPaint</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsPaint() &#123;</span><br><span class="line">  <span class="keyword">if</span> (isRepaintBoundary) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_layer <span class="keyword">is</span> OffsetLayer);</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">      owner._nodesNeedingPaint.add(<span class="keyword">this</span>);</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">is</span> RenderObject) &#123;</span><br><span class="line">    <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent;</span><br><span class="line">    parent.markNeedsPaint();</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>)</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>markNeedsPaint内部逻辑与markNeedsLayout都非常相似：</p><ul><li>若当前 Render Object 是 Repaint Boundary，则将其添加到PipelineOwner#_nodesNeedingPaint中，Paint request 也随之结束；</li><li>否则，Paint request 向父节点传播，即需要 re-paint 的范围扩大到父节点(这是一个递归的过程)；</li><li>有一个特例，那就是『 Render Object Tree 』的根节点，即 RenderView，它的父节点为 nil，此时只需调用PipelineOwner#requestVisualUpdate即可。</li></ul><h3 id="Repaint-Boundary"><a href="#Repaint-Boundary" class="headerlink" title="Repaint Boundary"></a>Repaint Boundary</h3><p>Repaint Boundary 有以下特点：</p><ul><li>每个 Repaint Boundary 都有一个独属于自己的 OffsetLayer (ContainerLayer)，其自身及子孙节点的绘制结果都将 attach 到以该 layer 为根节点的子树上；</li><li>每个 Repaint Boundary 都有一个独属于自己的 PaintingContext (包括背后的 Canvas)，从而使得其绘制与父节点完全隔离开。</li></ul><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RenderObject/RepaintBoundary.png"></p><p>如上图，由于Root&#x2F;RA&#x2F;RC&#x2F;RG&#x2F;RI是 Repaint Boundary，所以它们都有对应的 OffsetLayer。<br>同时，由于每个 Repaint Boundary 都有属于自己的 PaintingContext，所以它们都有对应的 PictureLayer，用于呈现具体的绘制结果。<br>对于那些不是 Repaint Boundary 的节点，将会绘制到最近的 Repaint Boundary 祖先节点提供的 PictureLayer 上。</p><blockquote><p>Repaint Boundary 会影响兄弟节点的绘制，如由于RC是 Repaint Boundary，导致RB、RD被绘制到不同的 PictureLayer 上。</p></blockquote><blockquote><p>实现中，『 Layer Tree 』往往会比上图所示更复杂，由于每个 Render Object 在绘制过程中都可以自主引入更多的 layer。</p></blockquote><h3 id="paint"><a href="#paint" class="headerlink" title="paint"></a>paint</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123; &#125;</span><br></pre></td></tr></table></figure><p>paint方法主要有2项任务：</p><ul><li>当前 Render Object 本身的绘制，如：RenderImage，其paint方法主要职责就是 image 的渲染</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">  paintImage(</span><br><span class="line">    canvas: context.canvas,</span><br><span class="line">    rect: offset &amp; size,</span><br><span class="line">    image: _image,</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>绘制子节点，如：RenderTable，其paint方法主要职责是依次对每个子节点调用PaintingContext#paintChild方法进行绘制：</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> index = <span class="number">0</span>; index &lt; _children.length; index += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> RenderBox child = _children[index];</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> BoxParentData childParentData = child.parentData;</span><br><span class="line">      context.paintChild(child, childParentData.offset + offset);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="串起来"><a href="#串起来" class="headerlink" title="串起来"></a>串起来</h3><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RenderObject/RenderObject-Paint-Line.png"></p><h4 id="PipelineOwner-flushPaint"><a href="#PipelineOwner-flushPaint" class="headerlink" title="PipelineOwner#flushPaint"></a>PipelineOwner#flushPaint</h4><p>当新一帧开始时，会触发PipelineOwner#flushPaint方法，进而对dirty Render Object进行re-paint</p><h4 id="PaintingContext-repaintCompositedChild"><a href="#PaintingContext-repaintCompositedChild" class="headerlink" title="PaintingContext#repaintCompositedChild"></a>PaintingContext#repaintCompositedChild</h4><p>作用：</p><ol><li>创建layer</li><li>为RenderObject的绘制准备context并发起绘制流程</li></ol><h4 id="RenderObject-paintWithContext"><a href="#RenderObject-paintWithContext" class="headerlink" title="RenderObject#_paintWithContext"></a>RenderObject#_paintWithContext</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _paintWithContext(PaintingContext context, Offset offset) &#123;</span><br><span class="line">  paint(context, offset);<span class="comment">//子类实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PaintingContext-paintChild"><a href="#PaintingContext-paintChild" class="headerlink" title="PaintingContext#paintChild"></a>PaintingContext#paintChild</h4><p>对于当前绘制子节点，若是 Repaint Boundary，则需要在独立的 layer 上进行绘制，否则直接调用子节点的_paintWithContext方法在当前上下文(paint context)中绘制：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paintChild(RenderObject child, Offset offset) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.isRepaintBoundary) &#123;</span><br><span class="line">      stopRecordingIfNeeded();</span><br><span class="line">      _compositeChild(child, offset);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child._wasRepaintBoundary) &#123;</span><br><span class="line">      child._layerHandle.layer = <span class="keyword">null</span>;</span><br><span class="line">      child._paintWithContext(<span class="keyword">this</span>, offset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      child._paintWithContext(<span class="keyword">this</span>, offset);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> stopRecordingIfNeeded() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_isRecording)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  _currentLayer.picture = _recorder.endRecording();</span><br><span class="line">  _currentLayer = <span class="keyword">null</span>;</span><br><span class="line">  _recorder = <span class="keyword">null</span>;</span><br><span class="line">  _canvas = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PaintingContext-compositeChild"><a href="#PaintingContext-compositeChild" class="headerlink" title="PaintingContext#_compositeChild"></a>PaintingContext#_compositeChild</h4><p>在_compositeChild中，通过repaintCompositedChild对子节点发起新一轮的绘制，并将绘制结果(child._layer)添加到『 Layer Tree 』中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _compositeChild(RenderObject child, Offset offset) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(!_isRecording);</span><br><span class="line">  <span class="keyword">assert</span>(child.isRepaintBoundary);</span><br><span class="line">  <span class="keyword">assert</span>(_canvas == <span class="keyword">null</span> || _canvas.getSaveCount() == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  repaintCompositedChild(child, debugAlsoPaintedParent: <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> OffsetLayer childOffsetLayer = child._layer;</span><br><span class="line">  childOffsetLayer.offset = offset;</span><br><span class="line">  appendLayer(child._layer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跑起来"><a href="#跑起来" class="headerlink" title="跑起来"></a>跑起来</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zxfcumtcs.github.io/2021/03/27/deepinto-flutter-renderobject/">深入浅出 Flutter Framework 之 RenderObject</a></li><li><a href="https://book.flutterchina.club/chapter14/render_object.html">Flutter实战-RenderObject（布局、绘制、点击测试）</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;RenderObject表示渲染树的一个对象，其职责包括：Layout、Paint、Hit Testing。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>RepaintBoundary</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RepaintBoundary/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RepaintBoundary/</id>
    <published>2024-08-02T13:15:20.036Z</published>
    <updated>2024-08-02T13:15:20.036Z</updated>
    
    <content type="html"><![CDATA[<p>UI系统会进行界面的图层划分，可以进行图层复用，减少绘制量，提升绘制性能。而RepaintBoundary是开放给开发者使用的独立图层。</p><p>RenderObject有一个isRepaintBoundary属性，该属性决定这个RenderObject重绘时是否独立于其父元素，如果该属性为true，则独立绘制。</p><p>如何独立绘制呢？</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">PainterContext</span></span></span><br><span class="line"><span class="keyword">void</span> paintChild(RenderObject child, Offset offset) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">        debugOnProfilePaint?.call(child);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child.isRepaintBoundary) &#123;</span><br><span class="line">        stopRecordingIfNeeded();</span><br><span class="line">        _compositeChild(child, offset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child._paintWithContext(<span class="keyword">this</span>, offset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _compositeChild(RenderObject child, Offset offset) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(!_isRecording);</span><br><span class="line">    <span class="keyword">assert</span>(child.isRepaintBoundary);</span><br><span class="line">    <span class="keyword">assert</span>(_canvas == <span class="keyword">null</span> || _canvas!.getSaveCount() == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a layer for our child, and paint the child into it.</span></span><br><span class="line">    <span class="comment">// 给子节点创建一个layer，然后在上面绘制</span></span><br><span class="line">    <span class="keyword">if</span> (child._needsPaint) &#123;</span><br><span class="line">      repaintCompositedChild(child, debugAlsoPaintedParent: <span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">assert</span>(() &#123;</span><br><span class="line">        <span class="comment">// register the call for RepaintBoundary metrics</span></span><br><span class="line">        child.debugRegisterRepaintBoundaryPaint();</span><br><span class="line">        child._layerHandle.layer!.debugCreator = child.debugCreator ?? child;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span>(child._layerHandle.layer <span class="keyword">is</span> OffsetLayer);</span><br><span class="line">    <span class="keyword">final</span> OffsetLayer childOffsetLayer = child._layerHandle.layer! <span class="keyword">as</span> OffsetLayer;</span><br><span class="line">    childOffsetLayer.offset = offset;</span><br><span class="line">    appendLayer(childOffsetLayer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> markNeedsPaint() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(!_debugDisposed);</span><br><span class="line">    <span class="keyword">assert</span>(owner == <span class="keyword">null</span> || !owner!.debugDoingPaint);</span><br><span class="line">    <span class="keyword">if</span> (_needsPaint)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    _needsPaint = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//如果RenderObject.isRepaintBoundary 为true,则该RenderObject拥有layer，直接绘制</span></span><br><span class="line">    <span class="keyword">if</span> (isRepaintBoundary) &#123;</span><br><span class="line">      <span class="keyword">assert</span>(() &#123;</span><br><span class="line">        <span class="keyword">if</span> (debugPrintMarkNeedsPaintStacks)</span><br><span class="line">          debugPrintStack(label: <span class="string">&#x27;markNeedsPaint() called for <span class="subst">$this</span>&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;());</span><br><span class="line">      <span class="comment">// If we always have our own layer, then we can just repaint</span></span><br><span class="line">      <span class="comment">// ourselves without involving any other nodes.</span></span><br><span class="line">      <span class="keyword">assert</span>(_layerHandle.layer <span class="keyword">is</span> OffsetLayer);</span><br><span class="line">      <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//找到最近的layer，绘制</span></span><br><span class="line">        owner!._nodesNeedingPaint.add(<span class="keyword">this</span>);</span><br><span class="line">        owner!.requestVisualUpdate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">is</span> RenderObject) &#123;</span><br><span class="line"><span class="comment">// 没有自己的layer, 会和一个祖先节点共用一个layer </span></span><br><span class="line">      <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent! <span class="keyword">as</span> RenderObject;</span><br><span class="line">      parent.markNeedsPaint();</span><br><span class="line">      <span class="keyword">assert</span>(parent == <span class="keyword">this</span>.parent);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">assert</span>(() &#123;</span><br><span class="line">        <span class="keyword">if</span> (debugPrintMarkNeedsPaintStacks)</span><br><span class="line">          debugPrintStack(label: <span class="string">&#x27;markNeedsPaint() called for <span class="subst">$this</span> (root of render tree)&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;());</span><br><span class="line">      <span class="comment">// If we&#x27;re the root of the render tree (probably a RenderView),</span></span><br><span class="line">      <span class="comment">// then we have to paint ourselves, since nobody else can paint</span></span><br><span class="line">      <span class="comment">// us. We don&#x27;t add ourselves to _nodesNeedingPaint in this</span></span><br><span class="line">      <span class="comment">// case, because the root is always told to paint regardless.</span></span><br><span class="line">      <span class="keyword">if</span> (owner != <span class="keyword">null</span>)</span><br><span class="line">      <span class="comment">// 如果直到根节点也没找到一个Layer，那么便需要绘制自身，因为没有其它节点可以绘制根节点。</span></span><br><span class="line">        owner!.requestVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>而RepaintBoundary就是一个isRepaintBoundary为true的类。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>自定义paint的组件</li><li>会唤起输入框的界面</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.woolha.com/tutorials/flutter-using-repaintboundary-examples">Flutter - Using RepaintBoundary Examples</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;UI系统会进行界面的图层划分，可以进行图层复用，减少绘制量，提升绘制性能。而RepaintBoundary是开放给开发者使用的独立图层。&lt;/p&gt;
&lt;p&gt;RenderObject有一个isRepaintBoundary属性，该属性决定这个RenderObject重绘时是否独立</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Paint过程</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Paint%E8%BF%87%E7%A8%8B/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Paint%E8%BF%87%E7%A8%8B/</id>
    <published>2024-08-02T13:15:20.036Z</published>
    <updated>2024-08-02T13:15:20.036Z</updated>
    
    <content type="html"><![CDATA[<p>经过Build流程，Render Tree中绘制相关的基础信息已经完成更新；经过Layout流程，Render Tree中每个节点的大小和位置完成计算与存储，接下来进入Paint流程：基于Layout的信息生成绘制指令。</p><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Paint%E8%BF%87%E7%A8%8B/paint.png"></p><p>Render Tree和Layer Tree的对应关系</p><p>使用Layer Tree的好处是可以做Paint流程的局部更新。Render Tree中，每个RenderObject对象都拥有一个needsCompositing属性，用于判断自身及子节点是否有一个要去合成的图层，同是还有一个_needsCompositingBitsUpdate字段<br>用于标记该属性是否需要更新。Flutter在Paint开始前首先会完成needsCompositing属性的更新，然后开始正式绘制。</p><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Paint%E8%BF%87%E7%A8%8B/layer1.png"></p><p>Layer的子类分为以下几种类型：</p><ul><li>ContainerLayer：容器层，用于包含其他Layer。</li><li>PictureLayer：执行实际绘制的节点。通过_picture字段持有一个ui.PictureRecorder对象，用于Engine进行对应绘制指令的记录。</li><li>TextureLayer、PlatformLayer：渲染源将有外部提供</li></ul><h2 id="Compositing-State-Mark阶段"><a href="#Compositing-State-Mark阶段" class="headerlink" title="Compositing-State Mark阶段"></a>Compositing-State Mark阶段</h2><p>当Render Tree需要挂载（mount）或卸载（unmount）一个子节点时，就会调用markNeedsCompositingBitsUpdate方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> markNeedsCompositingBitsUpdate() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_needsCompositingBitsUpdate) &#123;<span class="comment">//已经标记过需要更新</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _needsCompositingBitsUpdate = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (parent <span class="keyword">is</span> RenderObject) &#123;<span class="comment">//处理父节点</span></span><br><span class="line">      <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent! <span class="keyword">as</span> RenderObject;</span><br><span class="line">      <span class="keyword">if</span> (parent._needsCompositingBitsUpdate) &#123;<span class="comment">//如果父节点标记过，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((!_wasRepaintBoundary || !isRepaintBoundary) &amp;&amp; !parent.isRepaintBoundary) &#123;<span class="comment">//非绘制边界才需要标记父节点</span></span><br><span class="line">        parent.markNeedsCompositingBitsUpdate();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">      owner!._nodesNeedingCompositingBitsUpdate.add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Compositing-State-Flush阶段"><a href="#Compositing-State-Flush阶段" class="headerlink" title="Compositing-State Flush阶段"></a>Compositing-State Flush阶段</h2><p>Layout完成之后将调用pipelineOwner.flushCompositingBits()</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PipelineOwner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> flushCompositingBits() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!kReleaseMode) &#123;</span><br><span class="line">      Timeline.startSync(<span class="string">&#x27;UPDATING COMPOSITING BITS&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _nodesNeedingCompositingBitsUpdate.sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth);<span class="comment">//优先遍历祖先节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> RenderObject node <span class="keyword">in</span> _nodesNeedingCompositingBitsUpdate) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node._needsCompositingBitsUpdate &amp;&amp; node.owner == <span class="keyword">this</span>) &#123;</span><br><span class="line">        node._updateCompositingBits();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _nodesNeedingCompositingBitsUpdate.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> PipelineOwner child <span class="keyword">in</span> _children) &#123;</span><br><span class="line">      child.flushCompositingBits();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!kReleaseMode) &#123;</span><br><span class="line">      Timeline.finishSync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> _updateCompositingBits() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_needsCompositingBitsUpdate) &#123;<span class="comment">//第1步，无更新直接返回</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span> oldNeedsCompositing = _needsCompositing;</span><br><span class="line">    _needsCompositing = <span class="keyword">false</span>;<span class="comment">//默认不需要合成，即单独使用一个图层</span></span><br><span class="line">    visitChildren((RenderObject child) &#123;<span class="comment">//第2步，遍历每个子节点</span></span><br><span class="line">      child._updateCompositingBits();</span><br><span class="line">      <span class="keyword">if</span> (child.needsCompositing) &#123;<span class="comment">//如果子节点需要合成，则父节点也需要，直到遇到绘制边界</span></span><br><span class="line">        _needsCompositing = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (isRepaintBoundary || alwaysNeedsCompositing) &#123;<span class="comment">//第3步，判断是否需要合成，即是否是一个独立图层</span></span><br><span class="line">      _needsCompositing = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isRepaintBoundary &amp;&amp; _wasRepaintBoundary) &#123;<span class="comment">//第4步，</span></span><br><span class="line">      _needsPaint = <span class="keyword">false</span>;</span><br><span class="line">      _needsCompositedLayerUpdate = <span class="keyword">false</span>;</span><br><span class="line">      owner?._nodesNeedingPaint.remove(<span class="keyword">this</span>);</span><br><span class="line">      _needsCompositingBitsUpdate = <span class="keyword">false</span>;</span><br><span class="line">      markNeedsPaint();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldNeedsCompositing != _needsCompositing) &#123;<span class="comment">//判断_needsCompositing是否发生变化</span></span><br><span class="line">      _needsCompositingBitsUpdate = <span class="keyword">false</span>;</span><br><span class="line">      markNeedsPaint();<span class="comment">//图层发生变化，需要重绘</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _needsCompositingBitsUpdate = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Paint-Mark阶段"><a href="#Paint-Mark阶段" class="headerlink" title="Paint Mark阶段"></a>Paint Mark阶段</h2><p>Paint和Layout的脏节点标记逻辑比较类似，RenderObject中对绘制有影响的属性更新了就会进行标记，比如RenderImage的image属性</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> image(ui.Image? value) &#123;</span><br><span class="line">  <span class="keyword">if</span> (value == _image) &#123;<span class="comment">//没有改变</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; _image != <span class="keyword">null</span> &amp;&amp; value.isCloneOf(_image!)) &#123;</span><br><span class="line">    value.dispose();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _image?.dispose();</span><br><span class="line">  _image = value;</span><br><span class="line">  markNeedsPaint();</span><br><span class="line">  <span class="keyword">if</span> (_width == <span class="keyword">null</span> || _height == <span class="keyword">null</span>) &#123;</span><br><span class="line">    markNeedsLayout();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>markNeedsPaint方法的逻辑如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> markNeedsPaint() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_needsPaint) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _needsPaint = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (isRepaintBoundary &amp;&amp; _wasRepaintBoundary) &#123;<span class="comment">//第一种情况，如果是绘制边界</span></span><br><span class="line">      <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        owner!._nodesNeedingPaint.add(<span class="keyword">this</span>);<span class="comment">//重新加入到需要绘制的列表中</span></span><br><span class="line">        owner!.requestVisualUpdate();<span class="comment">//请求渲染</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">is</span> RenderObject) &#123;<span class="comment">//第二种情况，父节点不是绘制边界</span></span><br><span class="line">      <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent! <span class="keyword">as</span> RenderObject;</span><br><span class="line">      parent.markNeedsPaint();<span class="comment">//父节点也受影响，直接向上标记</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;<span class="comment">//第三种情况，非RenderObject</span></span><br><span class="line">        owner!.requestVisualUpdate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Paint-Flush阶段"><a href="#Paint-Flush阶段" class="headerlink" title="Paint Flush阶段"></a>Paint Flush阶段</h2><p>当flushCompositingBits完成之后，会调用pipelineOwner.flushPaint()</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PipelineOwner</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> flushPaint() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingPaint;</span><br><span class="line">      _nodesNeedingPaint = &lt;RenderObject&gt;[];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Sort the dirty nodes in reverse order (deepest first).</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> RenderObject node <span class="keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; b.depth - a.depth)) &#123;<span class="comment">//从深到浅遍历</span></span><br><span class="line">        <span class="keyword">if</span> ((node._needsPaint || node._needsCompositedLayerUpdate) &amp;&amp; node.owner == <span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (node._layerHandle.layer!.attached) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node._needsPaint) &#123;</span><br><span class="line">              PaintingContext.repaintCompositedChild(node);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              PaintingContext.updateLayerProperties(node);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node._skippedPaintingOnLayer();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> PipelineOwner child <span class="keyword">in</span> _children) &#123;</span><br><span class="line">        child.flushPaint();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintingContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> repaintCompositedChild(RenderObject child, &#123; <span class="built_in">bool</span> debugAlsoPaintedParent = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">    _repaintCompositedChild(</span><br><span class="line">      child,</span><br><span class="line">      debugAlsoPaintedParent: debugAlsoPaintedParent,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _repaintCompositedChild(</span><br><span class="line">    RenderObject child, &#123;</span><br><span class="line">    <span class="built_in">bool</span> debugAlsoPaintedParent = <span class="keyword">false</span>,</span><br><span class="line">    PaintingContext? childContext,</span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    OffsetLayer? childLayer = child._layerHandle.layer <span class="keyword">as</span> OffsetLayer?;</span><br><span class="line">    <span class="keyword">if</span> (childLayer == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> OffsetLayer layer = child.updateCompositedLayer(oldLayer: <span class="keyword">null</span>);<span class="comment">//没有就创建一个OffsetLayer</span></span><br><span class="line">      child._layerHandle.layer = childLayer = layer;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      childLayer.removeAllChildren();<span class="comment">//移除子节点</span></span><br><span class="line">      <span class="keyword">final</span> OffsetLayer updatedLayer = child.updateCompositedLayer(oldLayer: childLayer);</span><br><span class="line">    &#125;</span><br><span class="line">    child._needsCompositedLayerUpdate = <span class="keyword">false</span>;</span><br><span class="line">    childContext ??= PaintingContext(childLayer, child.paintBounds);</span><br><span class="line">    child._paintWithContext(childContext, Offset.zero);<span class="comment">//绘制当前图层</span></span><br><span class="line">    childContext.stopRecordingIfNeeded();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> _paintWithContext(PaintingContext context, Offset offset) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_needsLayout) &#123;<span class="comment">//存在Layout未处理的节点</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RenderObject? debugLastActivePaint;</span><br><span class="line">    _needsPaint = <span class="keyword">false</span>;</span><br><span class="line">    _needsCompositedLayerUpdate = <span class="keyword">false</span>;</span><br><span class="line">    _wasRepaintBoundary = isRepaintBoundary;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      paint(context, offset);<span class="comment">//开始绘制，具体的绘制逻辑在子类中</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      _reportException(<span class="string">&#x27;paint&#x27;</span>, e, stack);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>PipelineOwner是『RenderObject Tree』与『RendererBinding』间的桥梁，在两者间起到沟通协调的作用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">  pipelineOwner.flushLayout();</span><br><span class="line">  pipelineOwner.flushCompositingBits();</span><br><span class="line">  pipelineOwner.flushPaint();</span><br><span class="line">  renderView.compositeFrame(); <span class="comment">// this sends the bits to the GPU</span></span><br><span class="line">  pipelineOwner.flushSemantics(); <span class="comment">// this also sends the semantics to the OS.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Root Widget(RenderObjectToWidgetAdapter)</li><li>『 Element Tree 』的根节点(RenderObjectToWidgetElement)</li><li>『 RenderObject Tree 』的根节点(RenderView)</li><li>『 Layer Tree 』的根节点(TransformLayer)</li></ul><ol><li><p>确定当前组件的布局边界。</p></li><li><p>判断是否需要重新布局，如果没必要会直接返回，反之才需要重新布局。不需要布局时需要同时满足三个条件：</p><ul><li><p>当前组件没有被标记为需要重新布局。</p></li><li><p>父组件传递的约束没有发生变化。</p></li><li><p>当前组件的布局边界也没有发生变化时。</p></li></ul></li><li><p>调用 performLayout() 进行布局，因为 performLayout() 中又会调用子组件的 layout 方法，所以这时一个递归的过程，递归结束后整个组件树的布局也就完成了。</p></li><li><p>请求重绘。</p></li></ol><h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><p><strong>大致流程：</strong></p><p>第一次绘制时，从上到下递归绘制子节点，每当遇到一个边界节点，判断如果该节点的layer属性是否为空，是就创建一个新的OffsetLayer并赋值给它；不是则使用。然后将layer传递给子节点，接下来：</p><ol><li>如果子节点是非边界节点，且需要绘制，则：<ul><li>第一次绘制：创建一个Canvas对象和一个PictureLayer，然后将它们绑定，后续调用Canvas绘制都会落到和其绑定的PictureLayer上，接着这个PictureLayer会加入到边界节点的layer中；</li><li>不是第一次绘制：复用已有的边界节点和Canvas对象；</li></ul></li><li>如果子节点是边界节点，则对子节点递归上述过程。当子树递归完成后，就要将子节点的layer添加到父级layer中。</li></ol><p>RenderObject调用markNeedsRepaint来发起重绘：</p><ol><li>从当前节点一直往父级查找，直到找到一个<strong>绘制边界点</strong>时终止查找，然后会将该绘制边界点添加到其PiplineOwner的_nodesNeedingPaint列表中。</li><li>在查找的过程中，会将自己到绘制边界点路径上所有节点的_needPaint属性设置为true，表示需要重绘。</li><li>请求新的frame，执行重绘流程。下一个frame就会走drawFrame流程，涉及到flushCompositingBits、flushPaint 和 compositeFrame 三个函数。</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> markNeedsPaint() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_needsPaint) <span class="keyword">return</span>;</span><br><span class="line">  _needsPaint = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (isRepaintBoundary) &#123; <span class="comment">// 如果是当前节点是边界节点</span></span><br><span class="line">      owner!._nodesNeedingPaint.add(<span class="keyword">this</span>); <span class="comment">//将当前节点添加到需要重新绘制的列表中。</span></span><br><span class="line">      owner!.requestVisualUpdate(); <span class="comment">// 请求新的frame，该方法最终会调用scheduleFrame()</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">is</span> RenderObject) &#123; <span class="comment">// 若不是边界节点且存在父节点</span></span><br><span class="line">    <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent! <span class="keyword">as</span> RenderObject;</span><br><span class="line">    parent.markNeedsPaint(); <span class="comment">// 递归调用父节点的markNeedsPaint</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是根节点，直接请求新的 frame 即可</span></span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>)</span><br><span class="line">      owner!.requestVisualUpdate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href>Flutter内核源码剖析</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;经过Build流程，Render Tree中绘制相关的基础信息已经完成更新；经过Layout流程，Render Tree中每个节点的大小和位置完成计算与存储，接下来进入Paint流程：基于Layout的信息生成绘制指令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/wiki/Flu</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Layout过程</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Layout%E8%BF%87%E7%A8%8B/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Layout%E8%BF%87%E7%A8%8B/</id>
    <published>2024-08-02T13:15:20.035Z</published>
    <updated>2024-08-02T13:15:20.035Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderBinding</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">    pipelineOwner.flushLayout();<span class="comment">//布局</span></span><br><span class="line">    pipelineOwner.flushCompositingBits();<span class="comment">//更新所有节点，计算待绘制区域数据</span></span><br><span class="line">    pipelineOwner.flushPaint();<span class="comment">//绘制</span></span><br><span class="line">    <span class="keyword">if</span> (sendFramesToEngine) &#123;</span><br><span class="line">      renderView.compositeFrame(); <span class="comment">// 发送数据到GPU线程</span></span><br><span class="line">      pipelineOwner.flushSemantics(); <span class="comment">// 更新语义化</span></span><br><span class="line">      _firstFrameSent = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h3><p>markNeedsLayout方法会将当前节点标记为需要Layout。markNeedsLayout方法在很多地方都会被触发，比如UI的高宽发生变化，字体属性发生变化等。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> </span>&#123;</span><br><span class="line"> <span class="keyword">void</span> markNeedsLayout() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_needsLayout) &#123;<span class="comment">//已经标记过</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_relayoutBoundary == <span class="keyword">null</span>) &#123;<span class="comment">//当前节点不是布局边界，父节点受此影响，也需要被标记</span></span><br><span class="line">      _needsLayout = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        markParentNeedsLayout();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">this</span>) &#123;</span><br><span class="line">      markParentNeedsLayout();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _needsLayout = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        owner!._nodesNeedingLayout.add(<span class="keyword">this</span>);</span><br><span class="line">        owner!.requestVisualUpdate();<span class="comment">//请求刷新</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> markParentNeedsLayout() &#123;</span><br><span class="line">    _needsLayout = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent! <span class="keyword">as</span> RenderObject;</span><br><span class="line">    <span class="keyword">if</span> (!_doingThisLayoutWithCallback) &#123;</span><br><span class="line">      parent.markNeedsLayout();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Flush阶段"><a href="#Flush阶段" class="headerlink" title="Flush阶段"></a>Flush阶段</h3><p>Layout开始于drawFrame的flushLayout，Layout过程也跟Build类似，先标记再处理。Layout是相对Render Tree而言的</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PipelineOwner</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> flushLayout() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (_nodesNeedingLayout.isNotEmpty) &#123;<span class="comment">//存在需要更新Layout信息的节点</span></span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout;</span><br><span class="line">        _nodesNeedingLayout = &lt;RenderObject&gt;[];</span><br><span class="line">        dirtyNodes.sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; dirtyNodes.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (_shouldMergeDirtyNodes) &#123;</span><br><span class="line">            _shouldMergeDirtyNodes = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (_nodesNeedingLayout.isNotEmpty) &#123;</span><br><span class="line">              _nodesNeedingLayout.addAll(dirtyNodes.getRange(i, dirtyNodes.length));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">final</span> RenderObject node = dirtyNodes[i];</span><br><span class="line">          <span class="keyword">if</span> (node._needsLayout &amp;&amp; node.owner == <span class="keyword">this</span>) &#123;</span><br><span class="line">            node._layoutWithoutResize();<span class="comment">//真正的Layout逻辑</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _shouldMergeDirtyNodes = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> PipelineOwner child <span class="keyword">in</span> _children) &#123;<span class="comment">//更新子节点</span></span><br><span class="line">        child.flushLayout();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      _shouldMergeDirtyNodes = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> _layoutWithoutResize() &#123;</span><br><span class="line">    RenderObject? debugPreviousActiveLayout;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      performLayout();<span class="comment">//用于开始具体的Layout逻辑，这个方法中会调用markNeedsPaint进行标记需要进行paint</span></span><br><span class="line">      markNeedsSemanticsUpdate();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      _reportException(<span class="string">&#x27;performLayout&#x27;</span>, e, stack);</span><br><span class="line">    &#125;</span><br><span class="line">    _needsLayout = <span class="keyword">false</span>;</span><br><span class="line">    markNeedsPaint();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>_nodesNeedingLayout是需要重新构建的列表，存储所有需要重新布局的节点，一般会通过markNeedsLayout将自己添加到待重新layout列表中。</p><p>总结：</p><p>drawFrame–&gt;flushLayout–&gt;performLayout–&gt;markNeedsPaint</p><h3 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> performLayout() &#123;</span><br><span class="line">    _size = configuration.size;</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      child!.layout(BoxConstraints.tight(_size));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> layout(Constraints constraints, &#123; <span class="built_in">bool</span> parentUsesSize = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!kReleaseMode &amp;&amp; debugProfileLayoutsEnabled) &#123;</span><br><span class="line">      <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;? debugTimelineArguments;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span> isRelayoutBoundary = !parentUsesSize || sizedByParent || constraints.isTight || parent <span class="keyword">is</span>! RenderObject;</span><br><span class="line">    <span class="keyword">final</span> RenderObject relayoutBoundary = isRelayoutBoundary ? <span class="keyword">this</span> : (parent! <span class="keyword">as</span> RenderObject)._relayoutBoundary!;</span><br><span class="line">    <span class="keyword">if</span> (!_needsLayout &amp;&amp; constraints == _constraints) &#123;</span><br><span class="line">      <span class="keyword">if</span> (relayoutBoundary != _relayoutBoundary) &#123;</span><br><span class="line">        _relayoutBoundary = relayoutBoundary;</span><br><span class="line">        visitChildren(_propagateRelayoutBoundaryToChild);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _constraints = constraints;</span><br><span class="line">    <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">null</span> &amp;&amp; relayoutBoundary != _relayoutBoundary) &#123;</span><br><span class="line">      visitChildren(_cleanChildRelayoutBoundary);</span><br><span class="line">    &#125;</span><br><span class="line">    _relayoutBoundary = relayoutBoundary;</span><br><span class="line">    <span class="keyword">if</span> (sizedByParent) &#123;<span class="comment">//子节点大小完全取决于父节点</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        performResize();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RenderObject? debugPreviousActiveLayout;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      performLayout();<span class="comment">//子节点自身实现布局逻辑</span></span><br><span class="line">      markNeedsSemanticsUpdate();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      _reportException(<span class="string">&#x27;performLayout&#x27;</span>, e, stack);</span><br><span class="line">    &#125;</span><br><span class="line">    _needsLayout = <span class="keyword">false</span>;</span><br><span class="line">    markNeedsPaint();<span class="comment">//标记当前节点需要重绘</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了性能考虑，layout过程会使用_relayoutBoundary来优化性能。</p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="布局过程"><a href="#布局过程" class="headerlink" title="布局过程"></a>布局过程</h3><ol><li>父节点向子节点传递约束（constraints）信息，限制子节点的最大和最小宽高。</li><li>子节点根据约束信息确定自己的大小。</li><li>父节点根据特定布局规则确定每一个子节点在父节点布局控件中的位置，用偏移offset表示。</li><li>递归整个过程，确定出每一个节点的大小和位置。</li></ol><h3 id="layout流程"><a href="#layout流程" class="headerlink" title="layout流程"></a>layout流程</h3><ol><li>确定当前组件的布局边界。</li><li>判断是否需要重新布局，如果没必要会直接返回，反之才需要重新布局。不需要布局要同时满足以下三个条件：<ol><li>当前组件没有被标记为需要重新布局。</li><li>父组件传递的约束没有发生变化。</li><li>当前组件的布局边界没有发生变化。</li></ol></li><li>调用performLayout进行布局，其内部会调用子组件的layout方法。</li><li>请求绘制。</li></ol><h3 id="performLayout流程"><a href="#performLayout流程" class="headerlink" title="performLayout流程"></a>performLayout流程</h3><ol><li>如果有子组件，则对子组件进行递归布局。</li><li>确定当前组件的大小，通常会依赖子组件的大小。</li><li>确定子组件在当前组件中的起始偏移。</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">void</span> layout(Constraints constraints, &#123; <span class="built_in">bool</span> parentUsesSize = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">  RenderObject? relayoutBoundary;</span><br><span class="line">  <span class="comment">// 先确定当前组件的布局边界</span></span><br><span class="line">  <span class="keyword">if</span> (!parentUsesSize || sizedByParent || constraints.isTight || parent <span class="keyword">is</span>! RenderObject) &#123;</span><br><span class="line">    relayoutBoundary = <span class="keyword">this</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    relayoutBoundary = (parent! <span class="keyword">as</span> RenderObject)._relayoutBoundary;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// _needsLayout 表示当前组件是否被标记为需要布局</span></span><br><span class="line">  <span class="comment">// _constraints 是上次布局时父组件传递给当前组件的约束</span></span><br><span class="line">  <span class="comment">// _relayoutBoundary 为上次布局时当前组件的布局边界</span></span><br><span class="line">  <span class="comment">// 所以，当当前组件没有被标记为需要重新布局，且父组件传递的约束没有发生变化，</span></span><br><span class="line">  <span class="comment">// 且布局边界也没有发生变化时则不需要重新布局，直接返回即可。</span></span><br><span class="line">  <span class="keyword">if</span> (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果需要布局，缓存约束和布局边界</span></span><br><span class="line">  _constraints = constraints;</span><br><span class="line">  _relayoutBoundary = relayoutBoundary;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sizedByParent表示当前的Widget虽然不是isTight，但是通过其他约束属性，也可以明确的知道size，比如Expanded，并不一定需要明确的size</span></span><br><span class="line">  <span class="keyword">if</span> (sizedByParent) &#123;</span><br><span class="line">    performResize();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行布局</span></span><br><span class="line">  performLayout();</span><br><span class="line">  <span class="comment">// 布局结束后将 _needsLayout 置为 false</span></span><br><span class="line">  _needsLayout = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// 将当前组件标记为需要重绘（因为布局发生变化后，需要重新绘制）</span></span><br><span class="line">  markNeedsPaint();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="命中测试"><a href="#命中测试" class="headerlink" title="命中测试"></a>命中测试</h2><p>命中测试用来判断某个组件是否需要响应一个点击事件，其入口是RenderObject Tree的根节点RenderView的hitTest函数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> hitTest(HitTestResult result, &#123; Offset position &#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">    child.hitTest(BoxHitTestResult.wrap(result), position: position);<span class="comment">//child为RenderView</span></span><br><span class="line">  result.add(HitTestEntry(<span class="keyword">this</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看RenderView源码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> hitTest(BoxHitTestResult result, &#123; <span class="meta">@required</span> Offset position &#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (_size.contains(position)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hitTestChildren(result, position: position) || hitTestSelf(position)) &#123;</span><br><span class="line">      result.add(BoxHitTestEntry(<span class="keyword">this</span>, position));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果点击事件位置处于RenderObject之内，如果在其内，并且hitTestSelf或者hitTestChildren返回true，则表示RenderObject通过了命中测试，需要响应事件，此时需要将被点击的RenderObject加入BoxHitTestResult列表，同时点击事件不再向下传递。否则认为没有通过命中测试，事件继续向下传递。其中，hitTestSelf函数表示节点是否通过命中测试，hitTestChildren表示子节点是否通过命中测试。</p><ol><li>父节点向子节点传递约束（constraints）信息，限制子节点的最大和最小宽高。</li><li>子节点根据约束信息确定自己的大小（size）。</li><li>父节点根据特定布局规则（不同布局组件会有不同的布局算法）确定每一个子节点在父节点布局空间中的位置，用偏移 offset 表示。</li><li>递归整个过程，确定出每一个节点的大小和位置。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Element</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/</id>
    <published>2024-08-02T13:15:20.034Z</published>
    <updated>2024-08-02T13:15:20.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Widget是UI元素的配置数据，Element代表屏幕显示元素。主要作用：</p><ul><li>维护这棵Element Tree，根据Widget Tree的变化来更新Element Tree，包括：节点的插入、更新、删除、移动等；</li><li>将Widget和RenderObject关联到Element Tree上。</li></ul><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/element_1.png"></p><ul><li>ComponentElement：用来组合其他更基础的Element，开发时常用到的StatelessWidget和StatefulWidget相对应的Element：StatelessElement和StatefulElement。其子节点对应的Widget需要通过build方法创建，该类型Element只有一个子节点。</li><li>RenderObjectElement：渲染类Element，对应Renderer Widget，是框架最核心的Element。RenderObjectElement主要包括LeafRenderObjectElement，SingleChildRenderObjectElement，和MultiChildRenderObjectElement。<ul><li>LeafRenderObjectElement对应的Widget是LeafRenderObjectWidget，没有子节点；</li><li>SingleChildRenderObjectElement对应的Widget是SingleChildRenderObjectWidget，有一个子节点；</li><li>MultiChildRenderObjectElement对应的Widget是MultiChildRenderObjecWidget，有多个子节点，这些子节点是Widget对应的Element，当前Element只负责计算布局</li></ul></li></ul><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/element_9.png"></p><ul><li>Element 通过 parent、child 指针形成「Element Tree」；</li><li>Element 持有 Widget、「Render Object」；</li><li>State 是绑定在 Element 上的，而不是绑在「Stateful Widget」上(这点很重要)。</li></ul><blockquote><p>上述这些关系并不是所有类型的 Element 都有，如：「Render Object」只有「RenderObject Element」才有，State 只有「Stateful Element」才有。</p></blockquote><h2 id="重要属性和方法"><a href="#重要属性和方法" class="headerlink" title="重要属性和方法"></a>重要属性和方法</h2><p>Element的子类：</p><ul><li>ComponentElement<ul><li>StatelessElement</li><li>StatefulElement</li><li>ProxyElement<ul><li>ParentDataElement</li><li>InheritedElement</li></ul></li></ul></li><li>RenderObjectElement<ul><li>LeafRenderObjectElement</li><li>SingleChildRenderObjectElement</li><li>MultiChildRenderObjectElement<ul><li>TheatreElement</li></ul></li><li>RootRenderObjectElement</li></ul></li><li>_NullElement</li><li>RenderObjectToWidgetElement：element树的根节点</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">Type</span>, InheritedElement&gt;? _inheritedWidgets;</span><br><span class="line"><span class="built_in">Set</span>&lt;InheritedElement&gt; _dependencies;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InheritedElement</span> <span class="keyword">extends</span> <span class="title">ProxyElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">Element</span>, <span class="built_in">Object?</span>&gt; _dependents = HashMap&lt;<span class="built_in">Element</span>, <span class="built_in">Object?</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _updateInheritance() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_lifecycleState == _ElementLifecycle.active);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">Type</span>, InheritedElement&gt;? incomingWidgets = _parent?._inheritedWidgets;</span><br><span class="line">    <span class="keyword">if</span> (incomingWidgets != <span class="keyword">null</span>)</span><br><span class="line">      _inheritedWidgets = HashMap&lt;<span class="built_in">Type</span>, InheritedElement&gt;.of(incomingWidgets);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      _inheritedWidgets = HashMap&lt;<span class="built_in">Type</span>, InheritedElement&gt;();</span><br><span class="line">    _inheritedWidgets![widget.runtimeType] = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> <span class="keyword">implements</span> <span class="title">BuildContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 槽，用来存储一些额外信息，比如坐标</span></span><br><span class="line">  <span class="built_in">Object?</span> <span class="keyword">get</span> slot =&gt; _slot;</span><br><span class="line">  <span class="built_in">Object?</span> _slot;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// element tree上的深度</span></span><br><span class="line">  <span class="keyword">late</span> <span class="built_in">int</span> _depth;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开发人员需要处理的Widget</span></span><br><span class="line">  Widget _widget;</span><br><span class="line"></span><br><span class="line">  BuildOwner _owner;<span class="comment">//用来处理Element的对象，全局一个，将element tree转换成renderobject tree</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  InheritedWidget dependOnInheritedElement(InheritedElement ancestor, &#123; <span class="built_in">Object?</span> aspect &#125;) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(ancestor != <span class="keyword">null</span>);</span><br><span class="line">    _dependencies ??= HashSet&lt;InheritedElement&gt;();</span><br><span class="line">    _dependencies!.add(ancestor);</span><br><span class="line">    ancestor.updateDependencies(<span class="keyword">this</span>, aspect);</span><br><span class="line">    <span class="keyword">return</span> ancestor.widget;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  T? dependOnInheritedWidgetOfExactType&lt;T <span class="keyword">extends</span> InheritedWidget&gt;(&#123;<span class="built_in">Object?</span> aspect&#125;) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_debugCheckStateIsActiveForAncestorLookup());</span><br><span class="line">    <span class="keyword">final</span> InheritedElement? ancestor = _inheritedWidgets == <span class="keyword">null</span> ? <span class="keyword">null</span> : _inheritedWidgets![T];</span><br><span class="line">    <span class="keyword">if</span> (ancestor != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> dependOnInheritedElement(ancestor, aspect: aspect) <span class="keyword">as</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    _hadUnsatisfiedDependencies = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  InheritedElement? getElementForInheritedWidgetOfExactType&lt;T <span class="keyword">extends</span> InheritedWidget&gt;() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_debugCheckStateIsActiveForAncestorLookup());</span><br><span class="line">    <span class="keyword">final</span> InheritedElement? ancestor = _inheritedWidgets == <span class="keyword">null</span> ? <span class="keyword">null</span> : _inheritedWidgets![T];</span><br><span class="line">    <span class="keyword">return</span> ancestor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从根节点到子节点，以runtimeType作为key，保存最新的Element对象。getElementForInheritedWidgetOfExactType方法可以通过类型查找离自己最近的类型的对象。<br>dependOnInheritedWidgetOfExactType方法会注册依赖，当InheritedWidget发生变化时就会更新依赖它的子组件。</p><h3 id="updateChild"><a href="#updateChild" class="headerlink" title="updateChild"></a>updateChild</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">父节点通过该方法来修改子节点对应的Widget</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">newWidget == null   说明子节点对应的Widget已被移除，直接remove child element</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">child == null   说明newWidget是新插入的，通过inflateWidget创建子节点</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">child != null   分以下几种情况：</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="bullet">    1.</span> child.widget == newWidget，说明没变化，若child.slot != newSlot 表明子节点在兄弟节点间移动了位置，通过updateSlotForChild修改child.slot即可；</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="bullet">    2.</span> widget.canUpdate判断是否可以用newWidget修改child element，若可以则调用update方法；</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="bullet">    3.</span> 否则先将child element移除，并通过newWidget创建新的element子节点。</span></span></span><br><span class="line"><span class="built_in">Element?</span> updateChild(<span class="built_in">Element?</span> child, Widget? newWidget, <span class="built_in">Object?</span> newSlot) &#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><h4 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> update(<span class="keyword">covariant</span> Widget newWidget) &#123;</span><br><span class="line">    _widget = newWidget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> rebuild() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_lifecycleState != _ElementLifecycle.active || !_dirty)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">Element?</span> debugPreviousBuildTarget;</span><br><span class="line">  performRebuild();<span class="comment">//ComponentElement中调用build、updateChild</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Element?</span> updateChild(<span class="built_in">Element?</span> child, Widget? newWidget, <span class="built_in">Object?</span> newSlot) &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="StatelessElement"><a href="#StatelessElement" class="headerlink" title="StatelessElement"></a>StatelessElement</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> update(StatelessWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  <span class="keyword">assert</span>(widget == newWidget);</span><br><span class="line">  _dirty = <span class="keyword">true</span>;</span><br><span class="line">  rebuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rebuild调用performRebuild，调用当前build方法和updateChild。</p><h4 id="StatefulElement"><a href="#StatefulElement" class="headerlink" title="StatefulElement"></a>StatefulElement</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatefulElement</span> <span class="keyword">extends</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//开发者操作的对象，同样有相应生命周期，参考_StateLifecycle</span></span><br><span class="line">  State&lt;StatefulWidget&gt;? _state;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> update(StatefulWidget newWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">    <span class="keyword">final</span> StatefulWidget oldWidget = state._widget!;</span><br><span class="line">    _dirty = <span class="keyword">true</span>;</span><br><span class="line">    state._widget = widget <span class="keyword">as</span> StatefulWidget;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _debugSetAllowIgnoredCallsToMarkNeedsBuild(<span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Object?</span> debugCheckForReturnedFuture = state.didUpdateWidget(oldWidget) <span class="keyword">as</span> <span class="built_in">dynamic</span>;</span><br><span class="line">      <span class="keyword">assert</span>(() &#123;</span><br><span class="line">        <span class="keyword">if</span> (debugCheckForReturnedFuture <span class="keyword">is</span> Future) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      _debugSetAllowIgnoredCallsToMarkNeedsBuild(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rebuild();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>处理State：</p><ul><li>修改_widget属性</li><li>调用didUpdateWidget更新属性</li></ul><p>然后触发rebuild操作。</p><h4 id="ProxyElement"><a href="#ProxyElement" class="headerlink" title="ProxyElement"></a>ProxyElement</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> update(ProxyWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">final</span> ProxyWidget oldWidget = widget;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  updated(oldWidget);</span><br><span class="line">  _dirty = <span class="keyword">true</span>;</span><br><span class="line">  rebuild();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="keyword">void</span> updated(<span class="keyword">covariant</span> ProxyWidget oldWidget) &#123;</span><br><span class="line">  notifyClients(oldWidget);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>update方法会通知关联对象Widget有更新。不同子类的notifyClients实现不同。</p><h4 id="RenderObjectElement"><a href="#RenderObjectElement" class="headerlink" title="RenderObjectElement"></a>RenderObjectElement</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> update(<span class="keyword">covariant</span> RenderObjectWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  _performRebuild(); <span class="comment">// calls widget.updateRenderObject()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _performRebuild() &#123;</span><br><span class="line">  widget.updateRenderObject(<span class="keyword">this</span>, renderObject);<span class="comment">//修改RenderObject的属性</span></span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SingleChildRenderObject"><a href="#SingleChildRenderObject" class="headerlink" title="SingleChildRenderObject"></a>SingleChildRenderObject</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> update(SingleChildRenderObjectWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  _child = updateChild(_child, widget.child, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="MultiChildRenderObject"><a href="#MultiChildRenderObject" class="headerlink" title="MultiChildRenderObject"></a>MultiChildRenderObject</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> update(MultiChildRenderObjectWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  _children = updateChildren(_children, widget.children, forgottenChildren: _forgottenChildren);</span><br><span class="line">  _forgottenChildren.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>updateChildren中处理子节点的插入、移动、更新、删除等操作。</p><h3 id="inflateWidget"><a href="#inflateWidget" class="headerlink" title="inflateWidget"></a>inflateWidget</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Element</span> inflateWidget(Widget newWidget, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">final</span> Key? key = newWidget.key;</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;</span><br><span class="line">  <span class="comment">//如果带有GlobalKey，首先在inactive Elements列表中查找是否有处于inactive状态的节点（即刚从树上移除），如找到就直接复活该节点。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Element?</span> newChild = _retakeInactiveElement(key, newWidget);</span><br><span class="line">    <span class="keyword">if</span> (newChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">      newChild._activateWithParent(<span class="keyword">this</span>, newSlot);</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Element?</span> updatedChild = updateChild(newChild, newWidget, newSlot);</span><br><span class="line">      <span class="keyword">return</span> updatedChild!;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Element</span> newChild = newWidget.createElement();</span><br><span class="line">  newChild.mount(<span class="keyword">this</span>, newSlot);<span class="comment">//挂载到树上</span></span><br><span class="line">  <span class="keyword">return</span> newChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><h4 id="Element-1"><a href="#Element-1" class="headerlink" title="Element"></a>Element</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element?</span> parent, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">  _parent = parent;</span><br><span class="line">  _slot = newSlot;</span><br><span class="line">  _lifecycleState = _ElementLifecycle.active;</span><br><span class="line">  _depth = _parent != <span class="keyword">null</span> ? _parent!.depth + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    _owner = parent.owner;<span class="comment">//传递owner给子节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> Key? key = widget.key;</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;</span><br><span class="line">    owner!._registerGlobalKey(key, <span class="keyword">this</span>);<span class="comment">//GlobalKey注册自己，方便其他地方使用</span></span><br><span class="line">  &#125;</span><br><span class="line">  _updateInheritance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="ComponentElement"><a href="#ComponentElement" class="headerlink" title="ComponentElement"></a>ComponentElement</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element?</span> parent, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  <span class="keyword">assert</span>(_child == <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">assert</span>(_lifecycleState == _ElementLifecycle.active);</span><br><span class="line">  _firstBuild();</span><br><span class="line">  <span class="keyword">assert</span>(_child != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _firstBuild() &#123;</span><br><span class="line">  <span class="comment">// StatefulElement overrides this to also call state.didChangeDependencies.</span></span><br><span class="line">  rebuild(); <span class="comment">// This eventually calls performRebuild.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>组合型 Element 在挂载时会执行_firstBuild-&gt;rebuild操作。</p><h4 id="RenderObjectElement-1"><a href="#RenderObjectElement-1" class="headerlink" title="RenderObjectElement"></a>RenderObjectElement</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">  attachRenderObject(newSlot);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建RenderObject并插入到树上。</p><h4 id="SingleChildRenderObjectElement"><a href="#SingleChildRenderObjectElement" class="headerlink" title="SingleChildRenderObjectElement"></a>SingleChildRenderObjectElement</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _child = updateChild(_child, widget.child, <span class="keyword">null</span>);<span class="comment">//创建新Element实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MultiChildRenderObjectElement"><a href="#MultiChildRenderObjectElement" class="headerlink" title="MultiChildRenderObjectElement"></a>MultiChildRenderObjectElement</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiChildRenderObjectElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    _children = <span class="built_in">List</span>&lt;<span class="built_in">Element</span>&gt;(widget.children.length);</span><br><span class="line">    <span class="built_in">Element</span> previousChild;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _children.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Element</span> newChild = inflateWidget(widget.children[i], previousChild);<span class="comment">//将Widget转换成Element</span></span><br><span class="line">      _children[i] = newChild;</span><br><span class="line">      previousChild = newChild;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对每个子节点调用inflateWidget。</p><h3 id="markNeedsBuild"><a href="#markNeedsBuild" class="headerlink" title="markNeedsBuild"></a>markNeedsBuild</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsBuild() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_active)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dirty)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  _dirty = <span class="keyword">true</span>;</span><br><span class="line">  owner.scheduleBuildFor(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标记需要重建，其作用是将当前Element加入_dirtyElements，以便在下一帧可以rebuild。以下场景会调用markNeedsBuild：</p><ul><li>State.setState</li><li>Element.reassemble：debug hot reload</li><li>Element.didChangeDependencies：</li><li>StatefulElement.activate</li></ul><h3 id="rebuild"><a href="#rebuild" class="headerlink" title="rebuild"></a>rebuild</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> rebuild() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_active || !_dirty)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  performRebuild();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>活跃的或脏节点会执行performRebuild，以下场景会调用rebuild：</p><ul><li>对于dirty element，在新一帧绘制过程中由BuildOwner.buildScope</li><li>在element挂载时，由Element.mount调用</li><li>在update方法内被调用</li></ul><h3 id="performRebuild"><a href="#performRebuild" class="headerlink" title="performRebuild"></a>performRebuild</h3><h4 id="ComponentElement-1"><a href="#ComponentElement-1" class="headerlink" title="ComponentElement"></a>ComponentElement</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">  Widget built;</span><br><span class="line">  built = build();</span><br><span class="line"></span><br><span class="line">  _child = updateChild(_child, built, slot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组合型Element，先build自己，再更新子节点</p><h4 id="RenderObjectElement-2"><a href="#RenderObjectElement-2" class="headerlink" title="RenderObjectElement"></a>RenderObjectElement</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">  widget.updateRenderObject(<span class="keyword">this</span>, renderObject);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Element有4种状态：initial，active，inactive，defunct。其对应的意义如下：</p><ul><li>initial：初始状态，Element刚创建时就是该状态。、</li><li>active：激活状态。此时Element的Parent已经通过mount将该Element插入Element Tree的指定的插槽处（Slot），Element此时随时可能显示在屏幕上。</li><li>inactive：未激活状态。当Widget Tree发生变化，Element对应的Widget发生变化，同时由于新旧Widget的Key或者的RunTimeType不匹配等原因导致该Element也被移除，因此该Element的状态变为未激活状态，被从屏幕上移除。并将该Element从Element Tree中移除，如果该Element有对应的RenderObject，还会将对应的RenderObject从Render Tree移除。但是，此Element还是有被复用的机会，例如通过GlobalKey进行复用。</li><li>defunct：失效状态。如果一个处于未激活状态的Element在当前帧动画结束时还是未被复用，此时会调用该Element的unmount函数，将Element的状态改为defunct，并对其中的资源进行清理。</li></ul><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/element_2.png"></p><h2 id="ComponentElement-2"><a href="#ComponentElement-2" class="headerlink" title="ComponentElement"></a>ComponentElement</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/element_3.png"></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/element_4.png"></p><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/element_5.jpg"></p><h2 id="RenderObjectElement-3"><a href="#RenderObjectElement-3" class="headerlink" title="RenderObjectElement"></a>RenderObjectElement</h2><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/element_6.png"></p><h3 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h3><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/element_7.png"></p><h3 id="销毁-1"><a href="#销毁-1" class="headerlink" title="销毁"></a>销毁</h3><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/element_8.jpg"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Element继承自BuildContext，所以我们在平常使用的context其实就是Element。各种of方法其实就是操作Element树来获取相应对象。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/">深入浅出 Flutter Framework 之 Element</a></li><li><a href="https://medium.com/flutter/keys-what-are-they-good-for-13cb51742e7d">Keys! What are they good for?</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;Widget是UI元素的配置数据，Element代表屏幕显示元素。主要作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维护这棵Element Tree，根</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Build过程</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Build%E8%BF%87%E7%A8%8B/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Build%E8%BF%87%E7%A8%8B/</id>
    <published>2024-08-02T13:15:20.034Z</published>
    <updated>2024-08-02T13:15:20.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><ol><li>runApp，初始化构建Widget树，Widget通过createElement创建对应Element树，Element通过createRenderObject创建RenderObject树；</li><li>调用setState方法时，会将对应的element添加到dirtyElement队列中；触发WidgetsBinding中的_handleBuildScheduled方法，下一帧drawFrame会调用BuilderOwner的buildScope方法；</li><li>在buildScope方法中，会对dirtyElement队列中的element进行排序，然后逐个调用rebuild方法，触发对应的生命周期方法，State的didChangeDependencies、build等；</li><li>当Widget从树中移除时，会调用deactivate方法，将对应的element添加到inactiveElement队列中；调用unmount方法</li><li>RenderBinding中的drawFrame会触发Layout、Paint流程</li></ol><h2 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h2><p>开发者用来绘制UI的配置挂件，每一个Widget都对应一个Element(通过createElement创建)。Widget是不可变的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetsBinding</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    _buildOwner = BuildOwner(onBuildScheduled: _handleBuildScheduled); <span class="comment">//管理整个build过程</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> attachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">    rootElement = RenderObjectToWidgetAdapter&lt;RenderObjectToWidgetAdapter&gt;(</span><br><span class="line">      container: renderView,</span><br><span class="line">      debugShortDescription: <span class="string">&#x27;[root]&#x27;</span>,</span><br><span class="line">      owner: <span class="keyword">this</span>,</span><br><span class="line">    ).attachToRenderTree(rootElement);<span class="comment">//初始化</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">每一帧都会调用该方法</span></span></span><br><span class="line">  <span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">    buildOwner.buildScope(rootElement);<span class="comment">//走build过程</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObjectToWidgetAdapter</span> </span>&#123;</span><br><span class="line">  attachToRenderTree(RenderObjectToWidgetElement&lt;RenderObjectToWidgetAdapter&gt; element) &#123;</span><br><span class="line">    owner.buildScope(element, ()&#123;</span><br><span class="line">      element!.mount(<span class="keyword">null</span>, <span class="keyword">null</span>);<span class="comment">//第一次挂载</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildOwner</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> buildScope(<span class="built_in">Element</span> context, [VoidCallback? callback]) &#123;</span><br><span class="line">    callback();</span><br><span class="line">    element.rebuild();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> rebuild() &#123;</span><br><span class="line">    performRebuild();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatefulElement</span> <span class="keyword">extends</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    state.didChangeDependencies();<span class="comment">//生命周期回调</span></span><br><span class="line">    <span class="keyword">super</span>.performRebuild();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    build();<span class="comment">//生命周期回调</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><h3 id="标脏阶段"><a href="#标脏阶段" class="headerlink" title="标脏阶段"></a>标脏阶段</h3><p>我们在需要触发刷新时会调用setState方法，会对该element进行标脏，然后擦除脏标记。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> setState(VoidCallback fn) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Object?</span> result = fn() <span class="keyword">as</span> <span class="built_in">dynamic</span>;<span class="comment">//执行用户的逻辑</span></span><br><span class="line">    _element!.markNeedsBuild();<span class="comment">//标记需要build，就是将当前节点添加到脏列表</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> markNeedsBuild() &#123;</span><br><span class="line">    _dirty = <span class="keyword">true</span>;</span><br><span class="line">    owner.scheduleBuildFor(<span class="keyword">this</span>);<span class="comment">//在BuildOwner中进一步标记</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BuildOwner"><a href="#BuildOwner" class="headerlink" title="BuildOwner"></a>BuildOwner</h3><p>作用：</p><ol><li>在 UI 更新过程中跟踪、管理需要 rebuild 的 Element (「dirty elements」);</li><li>在有「dirty elements」时，及时通知引擎，以便在下一帧安排上对「dirty elements」的 rebuild，从而去刷新 UI；</li><li>管理处于 “inactive” 状态的 Element。</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildOwner</span> </span>&#123;</span><br><span class="line">  BuildOwner(&#123; <span class="keyword">this</span>.onBuildScheduled, FocusManager? focusManager &#125;) :</span><br><span class="line">      focusManager = focusManager ?? (FocusManager()..registerGlobalHandlers());</span><br><span class="line"></span><br><span class="line">  VoidCallback? onBuildScheduled;</span><br><span class="line"><span class="comment">//所谓「Inactive Element」，是指 element 从「Element Tree」上被移除到 dispose 或被重新插入「Element Tree」间的一个中间状态。</span></span><br><span class="line">  <span class="keyword">final</span> _InactiveElements _inactiveElements = _InactiveElements();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">Element</span>&gt; _dirtyElements = &lt;<span class="built_in">Element</span>&gt;[];<span class="comment">//脏列表</span></span><br><span class="line">  <span class="built_in">bool</span> _scheduledFlushDirtyElements = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool?</span> _dirtyElementsNeedsResorting;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> _debugIsInBuildScope =&gt; _dirtyElementsNeedsResorting != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  FocusManager focusManager;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">setState方法会调用该方法</span></span></span><br><span class="line">  <span class="keyword">void</span> scheduleBuildFor(<span class="built_in">Element</span> element) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element._inDirtyList) &#123;<span class="comment">//已经在脏列表中，重排</span></span><br><span class="line">      _dirtyElementsNeedsResorting = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!_scheduledFlushDirtyElements &amp;&amp; onBuildScheduled != <span class="keyword">null</span>) &#123;</span><br><span class="line">      _scheduledFlushDirtyElements = <span class="keyword">true</span>;</span><br><span class="line">      onBuildScheduled!();<span class="comment">//通知下一帧要更新，对应WidgetsBinding中的_handleBuildScheduled方法，调用ensureVisualUpdate，下一帧drawFrame会调用buildScope方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    _dirtyElements.add(element);<span class="comment">//添加到脏列表</span></span><br><span class="line">    element._inDirtyList = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> _debugStateLockLevel = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> _debugStateLocked =&gt; _debugStateLockLevel &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> debugBuilding =&gt; _debugBuilding;</span><br><span class="line">  <span class="built_in">bool</span> _debugBuilding = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">Element?</span> _debugCurrentBuildTarget;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> lockState(VoidCallback callback) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drawFrame会调用该方法</span></span><br><span class="line">  <span class="meta">@pragma</span>(<span class="string">&#x27;vm:notify-debugger-on-exception&#x27;</span>)</span><br><span class="line">  <span class="keyword">void</span> buildScope(<span class="built_in">Element</span> context, [ VoidCallback? callback ]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (callback == <span class="keyword">null</span> &amp;&amp; _dirtyElements.isEmpty) &#123;<span class="comment">//第1步，没有脏数据直接返回</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">//第2步</span></span><br><span class="line">      _scheduledFlushDirtyElements = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          callback();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      _dirtyElements.sort(<span class="built_in">Element</span>._sort);</span><br><span class="line">      _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</span><br><span class="line">      <span class="built_in">int</span> dirtyCount = _dirtyElements.length;</span><br><span class="line">      <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (index &lt; dirtyCount) &#123;<span class="comment">//第3步，开始遍历脏节点</span></span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">Element</span> element = _dirtyElements[index];</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">bool</span> isTimelineTracked = !kReleaseMode &amp;&amp; _isProfileBuildsEnabledFor(element.widget);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          element.rebuild();<span class="comment">//第4步，重新构建，触发对应生命周期方法，State的didChangeDependencies、build等</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        index += <span class="number">1</span>;<span class="comment">//第5步</span></span><br><span class="line">        <span class="keyword">if</span> (dirtyCount &lt; _dirtyElements.length || _dirtyElementsNeedsResorting!) &#123;</span><br><span class="line">          _dirtyElements.sort(<span class="built_in">Element</span>._sort);</span><br><span class="line">          _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</span><br><span class="line">          dirtyCount = _dirtyElements.length;</span><br><span class="line">          <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; _dirtyElements[index - <span class="number">1</span>].dirty) &#123;</span><br><span class="line">            index -= <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> <span class="built_in">Element</span> element <span class="keyword">in</span> _dirtyElements) &#123;</span><br><span class="line">        element._inDirtyList = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      _dirtyElements.clear();<span class="comment">//清空脏数据</span></span><br><span class="line">      _scheduledFlushDirtyElements = <span class="keyword">false</span>;</span><br><span class="line">      _dirtyElementsNeedsResorting = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">Element</span>, <span class="built_in">Set</span>&lt;GlobalKey&gt;&gt;? _debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _debugTrackElementThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans(<span class="built_in">Element</span> node, GlobalKey key) &#123;</span><br><span class="line">    _debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans ??= HashMap&lt;<span class="built_in">Element</span>, <span class="built_in">Set</span>&lt;GlobalKey&gt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Set</span>&lt;GlobalKey&gt; keys = _debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans!</span><br><span class="line">      .putIfAbsent(node, () =&gt; HashSet&lt;GlobalKey&gt;());</span><br><span class="line">    keys.add(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _debugElementWasRebuilt(<span class="built_in">Element</span> node) &#123;</span><br><span class="line">    _debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans?.remove(node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span>&lt;GlobalKey, <span class="built_in">Element</span>&gt; _globalKeyRegistry = &lt;GlobalKey, <span class="built_in">Element</span>&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  @_debugOnly</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Set</span>&lt;<span class="built_in">Element</span>&gt;? _debugIllFatedElements = kDebugMode ? HashSet&lt;<span class="built_in">Element</span>&gt;() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  @_debugOnly</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">Element</span>, <span class="built_in">Map</span>&lt;<span class="built_in">Element</span>, GlobalKey&gt;&gt;? _debugGlobalKeyReservations = kDebugMode ? &lt;<span class="built_in">Element</span>, <span class="built_in">Map</span>&lt;<span class="built_in">Element</span>, GlobalKey&gt;&gt;&#123;&#125; : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> globalKeyCount =&gt; _globalKeyRegistry.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _debugRemoveGlobalKeyReservationFor(<span class="built_in">Element</span> parent, <span class="built_in">Element</span> child) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _registerGlobalKey(GlobalKey key, <span class="built_in">Element</span> element) &#123;</span><br><span class="line">    _globalKeyRegistry[key] = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _unregisterGlobalKey(GlobalKey key, <span class="built_in">Element</span> element) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_globalKeyRegistry[key] == element) &#123;</span><br><span class="line">      _globalKeyRegistry.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _debugReserveGlobalKeyFor(<span class="built_in">Element</span> parent, <span class="built_in">Element</span> child, GlobalKey key) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _debugVerifyGlobalKeyReservation() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _debugVerifyIllFatedPopulation() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@pragma</span>(<span class="string">&#x27;vm:notify-debugger-on-exception&#x27;</span>)</span><br><span class="line">  <span class="keyword">void</span> finalizeTree() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lockState(_inactiveElements._unmountAll); <span class="comment">// this unregisters the GlobalKeys</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> reassemble(<span class="built_in">Element</span> root, DebugReassembleConfig? reassembleConfig) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      root._debugReassembleConfig = reassembleConfig;</span><br><span class="line">      root.reassemble();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Flush阶段"><a href="#Flush阶段" class="headerlink" title="Flush阶段"></a>Flush阶段</h3><p>我们知道Vsync信号到达后会触发BuildOwner的buildScope方法（参考上面的代码解释），该方法分为以下几个步骤：</p><ol><li>检查参数，并标记当前进入Build流程</li><li>callback的回调，一般用于首帧渲染时3棵树的创建，更新阶段该参数为null</li><li>脏节点排序，优先更新父节点效率更高</li><li>遍历脏节点，执行rebuild方法</li><li>第5步，先将index自增，再检查当前是否满足以下两种情况之一：</li></ol><ul><li>dirtyCount &lt; _dirtyElements.length：即在处理Element脏节点的过程中又有新的节点标记为脏</li><li>_dirtyElementsNeedsResorting：通常由GlobalKey的复用导致，如果当前节点已经在列表中，则会将该字段设置为true(scheduleBuildFor方法中设置)</li></ul><p>满足任何一个都会导致_dirtyElements列表重新排序，然后将index重制到最近的一个非脏节点，并继续从该Element节点的索引进行rebuild方法</p><ol start="6"><li>将_dirtyElements列表中的每个节点的_inDirtyList字段重置为false，然后清空列表，并重置相关字段</li></ol><p>对于rebuild，会调用performRebuild方法，该方法不同子类不一样的实现</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    _dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///<span class="language-markdown">对于StatefulElement来说，rebuild会触发ComponentElement的performRebuild方法</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    Widget? built;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      built = build();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      _debugDoingBuild = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.performRebuild(); <span class="comment">// clears the &quot;dirty&quot; flag</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _child = updateChild(_child, built, slot);<span class="comment">//完成子节点的更新</span></span><br><span class="line">      <span class="keyword">assert</span>(_child != <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      _child = updateChild(<span class="keyword">null</span>, built, slot);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Element?</span> updateChild(<span class="built_in">Element?</span> child, Widget? newWidget, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newWidget == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">        deactivateChild(child);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Element</span> newChild;</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="built_in">bool</span> hasSameSuperclass = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (hasSameSuperclass &amp;&amp; child.widget == newWidget) &#123;<span class="comment">//第1种情况</span></span><br><span class="line">        <span class="keyword">if</span> (child.slot != newSlot) &#123;</span><br><span class="line">          updateSlotForChild(child, newSlot);</span><br><span class="line">        &#125;</span><br><span class="line">        newChild = child;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasSameSuperclass &amp;&amp; Widget.canUpdate(child.widget, newWidget)) &#123;<span class="comment">//第2种情况</span></span><br><span class="line">        <span class="keyword">if</span> (child.slot != newSlot) &#123;</span><br><span class="line">          updateSlotForChild(child, newSlot);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">bool</span> isTimelineTracked = !kReleaseMode &amp;&amp; _isProfileBuildsEnabledFor(newWidget);</span><br><span class="line">        <span class="keyword">if</span> (isTimelineTracked) &#123;</span><br><span class="line">          <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;? debugTimelineArguments;</span><br><span class="line">        &#125;</span><br><span class="line">        child.update(newWidget);</span><br><span class="line">        newChild = child;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//第3种情况</span></span><br><span class="line">        deactivateChild(child);</span><br><span class="line">        newChild = inflateWidget(newWidget, newSlot);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//第4种情况</span></span><br><span class="line">      newChild = inflateWidget(newWidget, newSlot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newChild;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第1种：Widget节点相同，直接同步slot，并复用现有的Element节点。</li><li>第2种：可直接基于新的Widget节点更新，复用并更新现有的Element节点即可。不同的子类不一样的update，比如</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> update(Widget newWidget) &#123;</span><br><span class="line">    _widget = newWidget;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatelessElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> update(Widget newWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">    _dirty = <span class="keyword">true</span>;</span><br><span class="line">    rebuild();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObjectElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> update(Widget newWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">    widget.updateRenderObject(<span class="keyword">this</span>, renderObject);<span class="comment">//更新对应RenderObject</span></span><br><span class="line">    rebuild();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第3种：当前Widget Tree的子节点完全不一样，需要移除原有的Element节点，并新建新的Element节点进行挂载</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> deactivateChild(<span class="built_in">Element</span> child) &#123;</span><br><span class="line">    child._parent = <span class="keyword">null</span>;</span><br><span class="line">    child.detachRenderObject();</span><br><span class="line">    owner!._inactiveElements.add(child); <span class="comment">// this eventually calls child.deactivate()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清理阶段"><a href="#清理阶段" class="headerlink" title="清理阶段"></a>清理阶段</h3><p>在Build流程中，对于执行了deactivate方法的节点，其_lifecycleState字段的属性为inactive，当Build、Layout、Paint、Composition在UI线程的工作结束后，BuildOwner会调用finalizeTree方法进行最后的处理，其会调用_unmountAll</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_InactiveElements</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> _unmountAll() &#123;</span><br><span class="line">    _locked = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">Element</span>&gt; elements = _elements.toList()..sort(<span class="built_in">Element</span>._sort);</span><br><span class="line">    _elements.clear();<span class="comment">//对每一个inactive状态的节点进行清理</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      elements.reversed.forEach(_unmount);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      _locked = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _unmount(<span class="built_in">Element</span> element) &#123;</span><br><span class="line">    element.visitChildren((<span class="built_in">Element</span> child) &#123;</span><br><span class="line">      _unmount(child);</span><br><span class="line">    &#125;);</span><br><span class="line">    element.unmount();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> unmount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (kFlutterMemoryAllocationsEnabled) &#123;</span><br><span class="line">      MemoryAllocations.instance.dispatchObjectDisposed(object: <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Key? key = _widget?.key;</span><br><span class="line">    <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;</span><br><span class="line">      owner!._unregisterGlobalKey(key, <span class="keyword">this</span>);<span class="comment">//移除注册</span></span><br><span class="line">    &#125;</span><br><span class="line">    _widget = <span class="keyword">null</span>;</span><br><span class="line">    _dependencies = <span class="keyword">null</span>;</span><br><span class="line">    _lifecycleState = _ElementLifecycle.defunct;<span class="comment">//更新状态</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zxfcumtcs.github.io/2020/05/16/deepinto-flutter-buildowner/">深入浅出 Flutter Framework 之 BuildOwner</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概括&quot;&gt;&lt;a href=&quot;#概括&quot; class=&quot;headerlink&quot; title=&quot;概括&quot;&gt;&lt;/a&gt;概括&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;runApp，初始化构建Widget树，Widget通过createElement创建对应Element树，Element通过c</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>go_router</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/go_router/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/go_router/</id>
    <published>2024-08-02T13:15:20.034Z</published>
    <updated>2024-08-02T13:15:20.034Z</updated>
    
    <content type="html"><![CDATA[<p>官方出品路由管理库<a href="https://pub.dev/packages/go_router">go_router</a></p><p>路由管理需要的基本功能：</p><ul><li>命名路由，方便通过系统消息栏等地方打开具体的路由页面，且能带上参数</li><li>路由嵌套，一个路由页面嵌套多个页面的场景非常多</li></ul><p>可以自己封装Navigator，也可以使用第三方库，getx、go_router等都是不错的选择。go_router是官方出品。</p><h2 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">url上添加参数</span></span></span><br><span class="line">context.go(<span class="built_in">Uri</span>(path: <span class="string">&#x27;/users/123&#x27;</span>, queryParameters: &#123;<span class="string">&#x27;filter&#x27;</span>: <span class="string">&#x27;abc&#x27;</span>&#125;).toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加附加参数</span></span><br><span class="line">context.go(<span class="string">&#x27;/123&#x27;</span>, extra: <span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">获取参数</span></span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> extraString = GoRouterState.of(context).extra! <span class="keyword">as</span> <span class="built_in">String</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="转场动画"><a href="#转场动画" class="headerlink" title="转场动画"></a>转场动画</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GoRoute(</span><br><span class="line">  path: <span class="string">&#x27;details&#x27;</span>,</span><br><span class="line">  pageBuilder: (context, state) &#123;</span><br><span class="line">    <span class="keyword">return</span> CustomTransitionPage(</span><br><span class="line">      key: state.pageKey,</span><br><span class="line">      child: DetailsScreen(),</span><br><span class="line">      transitionsBuilder: (context, animation, secondaryAnimation, child) &#123;</span><br><span class="line">        <span class="comment">// Change the opacity of the screen using a Curve based on the the animation&#x27;s</span></span><br><span class="line">        <span class="comment">// value</span></span><br><span class="line">        <span class="keyword">return</span> FadeTransition(</span><br><span class="line">          opacity:</span><br><span class="line">              CurveTween(curve: Curves.easeInOutCirc).animate(animation),</span><br><span class="line">          child: child,</span><br><span class="line">        );</span><br><span class="line">      &#125;,</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">),</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GoRoute(</span><br><span class="line">   name: <span class="string">&#x27;song&#x27;</span>,</span><br><span class="line">   path: <span class="string">&#x27;songs/:songId&#x27;</span>,</span><br><span class="line">   builder: <span class="comment">/* ... */</span>,</span><br><span class="line"> ),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> TextButton(</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    context.goNamed(<span class="string">&#x27;song&#x27;</span>, pathParameters: &#123;<span class="string">&#x27;songId&#x27;</span>: <span class="number">123</span>&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  child: <span class="keyword">const</span> Text(<span class="string">&#x27;Go to song 2&#x27;</span>),</span><br><span class="line">),</span><br><span class="line"></span><br><span class="line">TextButton(</span><br><span class="line">  onPressed: () &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> location = context.namedLocation(<span class="string">&#x27;song&#x27;</span>, pathParameters: &#123;<span class="string">&#x27;songId&#x27;</span>: <span class="number">123</span>&#125;, queryParameters: &#123;<span class="string">&#x27;filter&#x27;</span>: <span class="string">&#x27;abc&#x27;</span>&#125;);</span><br><span class="line">    context.go(location);</span><br><span class="line">  &#125;,</span><br><span class="line">  child: <span class="keyword">const</span> Text(<span class="string">&#x27;Go to song 2&#x27;</span>),</span><br><span class="line">),</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="监听路由跳转"><a href="#监听路由跳转" class="headerlink" title="监听路由跳转"></a>监听路由跳转</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GoRouter router = GoRouter(</span><br><span class="line">  initialLocation: <span class="string">&#x27;/splash&#x27;</span>,</span><br><span class="line">  routes: &lt;RouteBase&gt;[deskAppRoute],</span><br><span class="line">  observers: [wsNavObserver],</span><br><span class="line">  onException: (BuildContext ctx, GoRouterState state, GoRouter router) &#123;</span><br><span class="line">    router.go(<span class="string">&#x27;/404&#x27;</span>, extra: state.uri.toString());</span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">MyNavObserver wsNavObserver = MyNavObserver();</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">可以通过subscribe在具体的页面监听路由变化</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNavObserver</span> <span class="keyword">extends</span> <span class="title">RouteObserver</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPageState</span> <span class="title">extend</span> <span class="title">State</span> <span class="title">with</span> <span class="title">RouteAware</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    wsNavObserver.subscribe(<span class="keyword">this</span>, ModalRoute.of(context)!); <span class="comment">//of方法会进行InheritedWidget绑定</span></span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;官方出品路由管理库&lt;a href=&quot;https://pub.dev/packages/go_router&quot;&gt;go_router&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;路由管理需要的基本功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命名路由，方便通过系统消息栏等地方打开具体的路由页面，且能带上参数&lt;/l</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="开源库" scheme="http://airshu.github.io/categories/Flutter/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Image原理分析</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Image%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Image%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2024-08-02T13:15:20.034Z</published>
    <updated>2024-08-02T13:15:20.034Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Image%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image1.png"></p><p>_ImageState是Image所对应的State，也是图片加载的驱动者，它将通过ImageProvider的resolve方法获取一个ImageStream对象。</p><p>ImageStream负责提供图片信息的数据流，其对应的监听器由_ImageState的_getListener方法提供。而ImageStream的主要工作将委托给ImageStreamCompleter，因此其持有的ImageStreamListener也将传递给ImageStreamCompleter。图片信息真正的加载由ImageProvider的子类实现，例如NetworkImage将从网络加载图片，加载并解码后的图片信息ImageInfo交由ImageStreamCompleter进行通知。</p><p>PaintBinding将持有一个ImageCache实例，用于全局图片缓存的管理。</p><h2 id="框架分析"><a href="#框架分析" class="headerlink" title="框架分析"></a>框架分析</h2><p>_ImageState的didChangeDependencies方法发起图片的解析</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ImageState</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    _updateInvertColors();</span><br><span class="line">    _resolveImage();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TickerMode.of(context)) &#123;</span><br><span class="line">      _listenToStream();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _stopListeningToStream(keepStreamAlive: <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _resolveImage() &#123;</span><br><span class="line">    <span class="keyword">final</span> ScrollAwareImageProvider provider = ScrollAwareImageProvider&lt;<span class="built_in">Object</span>&gt;(</span><br><span class="line">      context: _scrollAwareContext,</span><br><span class="line">      imageProvider: widget.image,<span class="comment">//真正加载图片的ImageProvider</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">final</span> ImageStream newStream =</span><br><span class="line">      provider.resolve(createLocalImageConfiguration(</span><br><span class="line">        context,</span><br><span class="line">        size: widget.width != <span class="keyword">null</span> &amp;&amp; widget.height != <span class="keyword">null</span> ? Size(widget.width!, widget.height!) : <span class="keyword">null</span>,</span><br><span class="line">      ));</span><br><span class="line">    _updateSourceStream(newStream);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">更新图片</span></span></span><br><span class="line">  <span class="keyword">void</span> _updateSourceStream(ImageStream newStream) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_imageStream?.key == newStream.key) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_isListeningToStream) &#123;</span><br><span class="line">      _imageStream!.removeListener(_getListener());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!widget.gaplessPlayback) &#123;<span class="comment">//新图片加载期间是否维持旧的图片信息</span></span><br><span class="line">      setState(() &#123; _replaceImage(info: <span class="keyword">null</span>); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setState(() &#123;<span class="comment">//重置相关字段</span></span><br><span class="line">      _loadingProgress = <span class="keyword">null</span>;</span><br><span class="line">      _frameNumber = <span class="keyword">null</span>;</span><br><span class="line">      _wasSynchronouslyLoaded = <span class="keyword">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    _imageStream = newStream;<span class="comment">//增加监听</span></span><br><span class="line">    <span class="keyword">if</span> (_isListeningToStream) &#123;</span><br><span class="line">      _imageStream!.addListener(_getListener());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ImageStreamListener _getListener(&#123;<span class="built_in">bool</span> recreateListener = <span class="keyword">false</span>&#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span>(_imageStreamListener == <span class="keyword">null</span> || recreateListener) &#123;</span><br><span class="line">      _lastException = <span class="keyword">null</span>;</span><br><span class="line">      _lastStack = <span class="keyword">null</span>;</span><br><span class="line">      _imageStreamListener = ImageStreamListener(</span><br><span class="line">        _handleImageFrame,</span><br><span class="line">        onChunk: widget.loadingBuilder == <span class="keyword">null</span> ? <span class="keyword">null</span> : _handleImageChunk,</span><br><span class="line">        onError: widget.errorBuilder != <span class="keyword">null</span> || kDebugMode</span><br><span class="line">            ? (<span class="built_in">Object</span> error, StackTrace? stackTrace) &#123;</span><br><span class="line">                setState(() &#123;</span><br><span class="line">                  _lastException = error;</span><br><span class="line">                  _lastStack = stackTrace;</span><br><span class="line">                &#125;);</span><br><span class="line">              &#125;</span><br><span class="line">            : <span class="keyword">null</span>,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _imageStreamListener!;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">真实更新图片的地方</span></span></span><br><span class="line">  <span class="keyword">void</span> _handleImageFrame(ImageInfo imageInfo, <span class="built_in">bool</span> synchronousCall) &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _replaceImage(info: imageInfo);</span><br><span class="line">      _loadingProgress = <span class="keyword">null</span>;</span><br><span class="line">      _lastException = <span class="keyword">null</span>;</span><br><span class="line">      _lastStack = <span class="keyword">null</span>;</span><br><span class="line">      _frameNumber = _frameNumber == <span class="keyword">null</span> ? <span class="number">0</span> : _frameNumber! + <span class="number">1</span>;</span><br><span class="line">      _wasSynchronouslyLoaded = _wasSynchronouslyLoaded | synchronousCall;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ImageProvider-resolve"><a href="#ImageProvider-resolve" class="headerlink" title="ImageProvider.resolve"></a>ImageProvider.resolve</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageProvider</span> </span>&#123;</span><br><span class="line">  ImageStream resolve(ImageConfiguration configuration) &#123;</span><br><span class="line">    <span class="keyword">final</span> ImageStream stream = createStream(configuration);</span><br><span class="line">    <span class="comment">//解析当前ImageConfiguration所对应的Key，并基于Key进行图片的加载</span></span><br><span class="line">    _createErrorHandlerAndKey(</span><br><span class="line">      configuration,</span><br><span class="line">      (T key, ImageErrorListener errorHandler) &#123;</span><br><span class="line">        resolveStreamForKey(configuration, stream, key, errorHandler);</span><br><span class="line">      &#125;,</span><br><span class="line">      (T? key, <span class="built_in">Object</span> exception, StackTrace? stack) <span class="keyword">async</span> &#123;...&#125;,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> stream;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _createErrorHandlerAndKey(</span><br><span class="line">    ImageConfiguration configuration,</span><br><span class="line">    _KeyAndErrorHandlerCallback&lt;T&gt; successCallback,</span><br><span class="line">    _AsyncKeyErrorHandler&lt;T?&gt; errorCallback,</span><br><span class="line">  ) &#123;</span><br><span class="line">    T? obtainedKey;</span><br><span class="line">    <span class="built_in">bool</span> didError = <span class="keyword">false</span>;</span><br><span class="line">    Future&lt;<span class="keyword">void</span>&gt; handleError(<span class="built_in">Object</span> exception, StackTrace? stack) <span class="keyword">async</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (didError) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!didError) &#123;</span><br><span class="line">        didError = <span class="keyword">true</span>;</span><br><span class="line">        errorCallback(obtainedKey, exception, stack);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Future&lt;T&gt; key;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      key = obtainKey(configuration);<span class="comment">//获取图片的key</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error, stackTrace) &#123;</span><br><span class="line">      handleError(error, stackTrace);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    key.then&lt;<span class="keyword">void</span>&gt;((T key) &#123;</span><br><span class="line">      obtainedKey = key;</span><br><span class="line">      <span class="keyword">try</span> &#123;<span class="comment">//获取key成功后，加载图片</span></span><br><span class="line">        successCallback(key, handleError);<span class="comment">//resolveStreamForKey</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (error, stackTrace) &#123;</span><br><span class="line">        handleError(error, stackTrace);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).catchError(handleError);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载图片</span></span><br><span class="line">  <span class="keyword">void</span> resolveStreamForKey(ImageConfiguration configuration, ImageStream stream, T key, ImageErrorListener handleError) &#123;</span><br><span class="line">    <span class="keyword">if</span> (stream.completer != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> ImageStreamCompleter? completer = PaintingBinding.instance.imageCache.putIfAbsent(</span><br><span class="line">        key,</span><br><span class="line">        () =&gt; stream.completer!,</span><br><span class="line">        onError: handleError,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">assert</span>(identical(completer, stream.completer));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过key从缓存中依次加载，没有缓存则执行load方法</span></span><br><span class="line">    <span class="keyword">final</span> ImageStreamCompleter? completer = PaintingBinding.instance.imageCache.putIfAbsent(</span><br><span class="line">      key,</span><br><span class="line">      () &#123;</span><br><span class="line">        <span class="comment">//如果缓存没有，则通过load创建一个新的实例</span></span><br><span class="line">        ImageStreamCompleter result = loadImage(key, PaintingBinding.instance.instantiateImageCodecWithSize);</span><br><span class="line">        <span class="keyword">if</span> (result <span class="keyword">is</span> _AbstractImageStreamCompleter) &#123;</span><br><span class="line">          result = loadBuffer(key, PaintingBinding.instance.instantiateImageCodecFromBuffer);</span><br><span class="line">          <span class="keyword">if</span> (result <span class="keyword">is</span> _AbstractImageStreamCompleter) &#123;</span><br><span class="line">            result = load(key, PaintingBinding.instance.instantiateImageCodec);<span class="comment">//子类具体实现，比如NetworkImage</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;,</span><br><span class="line">      onError: handleError,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (completer != <span class="keyword">null</span>) &#123;</span><br><span class="line">      stream.setCompleter(completer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="NetworkImage-load"><a href="#NetworkImage-load" class="headerlink" title="NetworkImage.load"></a>NetworkImage.load</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkImage</span> </span>&#123;</span><br><span class="line">  ImageStreamCompleter load(image_provider.NetworkImage key, image_provider.DecoderCallback decode) &#123;</span><br><span class="line">    <span class="keyword">final</span> StreamController&lt;ImageChunkEvent&gt; chunkEvents = StreamController&lt;ImageChunkEvent&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建MultiFrameImageStreamCompleter，图片加载成功后的处理逻辑</span></span><br><span class="line">    <span class="keyword">return</span> MultiFrameImageStreamCompleter(</span><br><span class="line">      codec: _loadAsync(key <span class="keyword">as</span> NetworkImage, chunkEvents, decodeDeprecated: decode),<span class="comment">//decode为图片解码器</span></span><br><span class="line">      chunkEvents: chunkEvents.stream,<span class="comment">//加载进度监听</span></span><br><span class="line">      scale: key.scale,</span><br><span class="line">      debugLabel: key.url,</span><br><span class="line">      informationCollector: () =&gt; &lt;DiagnosticsNode&gt;[</span><br><span class="line">        DiagnosticsProperty&lt;image_provider.ImageProvider&gt;(<span class="string">&#x27;Image provider&#x27;</span>, <span class="keyword">this</span>),</span><br><span class="line">        DiagnosticsProperty&lt;image_provider.NetworkImage&gt;(<span class="string">&#x27;Image key&#x27;</span>, key),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;ui.Codec&gt; _loadAsync(</span><br><span class="line">    NetworkImage key,</span><br><span class="line">    StreamController&lt;ImageChunkEvent&gt; chunkEvents, &#123;</span><br><span class="line">    image_provider.ImageDecoderCallback? decode,</span><br><span class="line">    image_provider.DecoderBufferCallback? decodeBufferDeprecated,</span><br><span class="line">    image_provider.DecoderCallback? decodeDeprecated,</span><br><span class="line">  &#125;) <span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">assert</span>(key == <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Uri</span> resolved = <span class="built_in">Uri</span>.<span class="keyword">base</span>.resolve(key.url);<span class="comment">//解析图片资源地址</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> HttpClientRequest request = <span class="keyword">await</span> _httpClient.getUrl(resolved);</span><br><span class="line"></span><br><span class="line">      headers?.forEach((<span class="built_in">String</span> name, <span class="built_in">String</span> value) &#123;</span><br><span class="line">        request.headers.add(name, value);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">final</span> HttpClientResponse response = <span class="keyword">await</span> request.close();</span><br><span class="line">      <span class="keyword">if</span> (response.statusCode != HttpStatus.ok) &#123;</span><br><span class="line">        <span class="keyword">await</span> response.drain&lt;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt;&gt;(&lt;<span class="built_in">int</span>&gt;[]);</span><br><span class="line">        <span class="keyword">throw</span> image_provider.NetworkImageLoadException(statusCode: response.statusCode, uri: resolved);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> Uint8List bytes = <span class="keyword">await</span> consolidateHttpClientResponseBytes(<span class="comment">//下载数据</span></span><br><span class="line">        response,</span><br><span class="line">        onBytesReceived: (<span class="built_in">int</span> cumulative, <span class="built_in">int?</span> total) &#123;<span class="comment">//当前进度</span></span><br><span class="line">          chunkEvents.add(ImageChunkEvent(<span class="comment">//对外通知</span></span><br><span class="line">            cumulativeBytesLoaded: cumulative,</span><br><span class="line">            expectedTotalBytes: total,</span><br><span class="line">          ));</span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (bytes.lengthInBytes == <span class="number">0</span>) &#123;<span class="comment">//没有数据</span></span><br><span class="line">        <span class="keyword">throw</span> Exception(<span class="string">&#x27;NetworkImage is an empty file: <span class="subst">$resolved</span>&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//解析图片信息</span></span><br><span class="line">      <span class="keyword">if</span> (decode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ui.ImmutableBuffer buffer = <span class="keyword">await</span> ui.ImmutableBuffer.fromUint8List(bytes);</span><br><span class="line">        <span class="keyword">return</span> decode(buffer);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (decodeBufferDeprecated != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ui.ImmutableBuffer buffer = <span class="keyword">await</span> ui.ImmutableBuffer.fromUint8List(bytes);</span><br><span class="line">        <span class="keyword">return</span> decodeBufferDeprecated(buffer);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span>(decodeDeprecated != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> decodeDeprecated!(bytes);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      scheduleMicrotask(() &#123;</span><br><span class="line">        PaintingBinding.instance.imageCache.evict(key);</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">rethrow</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      chunkEvents.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="MultiFrameImageStreamCompleter"><a href="#MultiFrameImageStreamCompleter" class="headerlink" title="MultiFrameImageStreamCompleter"></a>MultiFrameImageStreamCompleter</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiFrameImageStreamCompleter</span> </span>&#123;</span><br><span class="line">    MultiFrameImageStreamCompleter(&#123;</span><br><span class="line">    <span class="keyword">required</span> Future&lt;ui.Codec&gt; codec,</span><br><span class="line">    <span class="keyword">required</span> <span class="built_in">double</span> scale,</span><br><span class="line">    <span class="built_in">String?</span> debugLabel,</span><br><span class="line">    Stream&lt;ImageChunkEvent&gt;? chunkEvents,</span><br><span class="line">    InformationCollector? informationCollector,</span><br><span class="line">  &#125;) : _informationCollector = informationCollector,</span><br><span class="line">       _scale = scale &#123;</span><br><span class="line">    <span class="keyword">this</span>.debugLabel = debugLabel;</span><br><span class="line">    codec.then&lt;<span class="keyword">void</span>&gt;(_handleCodecReady, onError: (<span class="built_in">Object</span> error, StackTrace stack) &#123;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (chunkEvents != <span class="keyword">null</span>) &#123;</span><br><span class="line">      _chunkSubscription = chunkEvents.listen(reportImageChunkEvent,</span><br><span class="line">        onError: (<span class="built_in">Object</span> error, StackTrace stack) &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/// <span class="language-markdown">处理加载好的数据</span></span></span><br><span class="line">  <span class="keyword">void</span> _handleCodecReady(ui.Codec codec) &#123;</span><br><span class="line">    _codec = codec;</span><br><span class="line">    <span class="keyword">assert</span>(_codec != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasListeners) &#123;</span><br><span class="line">      _decodeNextFrameAndSchedule();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Future&lt;<span class="keyword">void</span>&gt; _decodeNextFrameAndSchedule() <span class="keyword">async</span> &#123;</span><br><span class="line">    _nextFrame?.image.dispose();</span><br><span class="line">    _nextFrame = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _nextFrame = <span class="keyword">await</span> _codec!.getNextFrame();<span class="comment">//获取一帧</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_codec!.frameCount == <span class="number">1</span>) &#123;<span class="comment">//图片只有一帧，则会进入emitFrame</span></span><br><span class="line">      <span class="keyword">if</span> (!hasListeners) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      _emitFrame(ImageInfo(</span><br><span class="line">        image: _nextFrame!.image.clone(),</span><br><span class="line">        scale: _scale,</span><br><span class="line">        debugLabel: debugLabel,</span><br><span class="line">      ));</span><br><span class="line">      _nextFrame!.image.dispose();</span><br><span class="line">      _nextFrame = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">return</span>;<span class="comment">//单帧和多帧是互斥的</span></span><br><span class="line">    &#125;</span><br><span class="line">    _scheduleAppFrame();<span class="comment">//图片存在多帧</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _emitFrame(ImageInfo imageInfo) &#123;</span><br><span class="line">    setImage(imageInfo);</span><br><span class="line">    _framesEmitted += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> setImage(ImageInfo image) &#123;</span><br><span class="line">    _checkDisposed();</span><br><span class="line">    _currentImage?.dispose();<span class="comment">//释放资源</span></span><br><span class="line">    _currentImage = image;<span class="comment">//新的突破信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_listeners.isEmpty) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Make a copy to allow for concurrent modification.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;ImageStreamListener&gt; localListeners =</span><br><span class="line">        <span class="built_in">List</span>&lt;ImageStreamListener&gt;.of(_listeners);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> ImageStreamListener listener <span class="keyword">in</span> localListeners) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        listener.onImage(image.clone(), <span class="keyword">false</span>);<span class="comment">//通知图片更新，_ImageState的_updateSourceStream--&gt;_getListener--&gt;_handleImageFrame</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h2><p>ImageCache进行缓存管理</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageCache</span> </span>&#123;</span><br><span class="line">  ImageStreamCompleter? putIfAbsent(<span class="built_in">Object</span> key, ImageStreamCompleter <span class="built_in">Function</span>() loader, &#123; ImageErrorListener? onError &#125;) &#123;</span><br><span class="line">    TimelineTask? timelineTask;</span><br><span class="line">    TimelineTask? listenerTask;</span><br><span class="line">    ImageStreamCompleter? result = _pendingImages[key]?.completer;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;<span class="comment">//正在加载，直接返回</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> _CachedImage? image = _cache.remove(key);<span class="comment">//使用缓存</span></span><br><span class="line">    <span class="keyword">if</span> (image != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!kReleaseMode) &#123;</span><br><span class="line">        timelineTask!.finish(arguments: &lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;&#123;<span class="string">&#x27;result&#x27;</span>: <span class="string">&#x27;keepAlive&#x27;</span>&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      _trackLiveImage(</span><br><span class="line">        key,</span><br><span class="line">        image.completer,</span><br><span class="line">        image.sizeBytes,</span><br><span class="line">      );</span><br><span class="line">      _cache[key] = image;<span class="comment">//注册新的key</span></span><br><span class="line">      <span class="keyword">return</span> image.completer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> _LiveImage? liveImage = _liveImages[key];</span><br><span class="line">    <span class="keyword">if</span> (liveImage != <span class="keyword">null</span>) &#123;</span><br><span class="line">      _touch(</span><br><span class="line">        key,</span><br><span class="line">        _CachedImage(</span><br><span class="line">          liveImage.completer,</span><br><span class="line">          sizeBytes: liveImage.sizeBytes,</span><br><span class="line">        ),</span><br><span class="line">        timelineTask,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (!kReleaseMode) &#123;</span><br><span class="line">        timelineTask!.finish(arguments: &lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;&#123;<span class="string">&#x27;result&#x27;</span>: <span class="string">&#x27;keepAlive&#x27;</span>&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> liveImage.completer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      result = loader();<span class="comment">//没有缓存，开始加载</span></span><br><span class="line">      _trackLiveImage(key, result, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error, stackTrace) &#123;</span><br><span class="line">      <span class="keyword">if</span> (onError != <span class="keyword">null</span>) &#123;</span><br><span class="line">        onError(error, stackTrace);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">rethrow</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kReleaseMode) &#123;</span><br><span class="line">      listenerTask = TimelineTask(parent: timelineTask)..start(<span class="string">&#x27;listener&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bool</span> listenedOnce = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span> trackPendingImage = maximumSize &gt; <span class="number">0</span> &amp;&amp; maximumSizeBytes &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">late</span> _PendingImage pendingImage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> listener(ImageInfo? info, <span class="built_in">bool</span> syncCall) &#123;</span><br><span class="line">      <span class="built_in">int?</span> sizeBytes;<span class="comment">//图片大小</span></span><br><span class="line">      <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sizeBytes = info.sizeBytes;</span><br><span class="line">        info.dispose();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//构造缓存</span></span><br><span class="line">      <span class="keyword">final</span> _CachedImage image = _CachedImage(</span><br><span class="line">        result!,</span><br><span class="line">        sizeBytes: sizeBytes,</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      _trackLiveImage(key, result, sizeBytes);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Only touch if the cache was enabled when resolve was initially called.</span></span><br><span class="line">      <span class="keyword">if</span> (trackPendingImage) &#123;</span><br><span class="line">        _touch(key, image, listenerTask);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        image.dispose();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      _pendingImages.remove(key);</span><br><span class="line">      <span class="keyword">if</span> (!listenedOnce) &#123;</span><br><span class="line">        pendingImage.removeListener();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!kReleaseMode &amp;&amp; !listenedOnce) &#123;</span><br><span class="line">        listenerTask!.finish(arguments: &lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;&#123;</span><br><span class="line">          <span class="string">&#x27;syncCall&#x27;</span>: syncCall,</span><br><span class="line">          <span class="string">&#x27;sizeInBytes&#x27;</span>: sizeBytes,</span><br><span class="line">        &#125;);</span><br><span class="line">        timelineTask!.finish(arguments: &lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;&#123;</span><br><span class="line">          <span class="string">&#x27;currentSizeBytes&#x27;</span>: currentSizeBytes,</span><br><span class="line">          <span class="string">&#x27;currentSize&#x27;</span>: currentSize,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      listenedOnce = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ImageStreamListener streamListener = ImageStreamListener(listener);<span class="comment">//定义监听器</span></span><br><span class="line">    pendingImage = _PendingImage(result, streamListener);</span><br><span class="line">    <span class="keyword">if</span> (trackPendingImage) &#123;</span><br><span class="line">      _pendingImages[key] = pendingImage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Listener is removed in [_PendingImage.removeListener].</span></span><br><span class="line">    result.addListener(streamListener);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _touch(<span class="built_in">Object</span> key, _CachedImage image, TimelineTask? timelineTask) &#123;</span><br><span class="line">    <span class="keyword">if</span> (image.sizeBytes != <span class="keyword">null</span> &amp;&amp; image.sizeBytes! &lt;= maximumSizeBytes &amp;&amp; maximumSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      _currentSizeBytes += image.sizeBytes!;<span class="comment">//已缓存图片大小</span></span><br><span class="line">      _cache[key] = image;<span class="comment">//添加缓存</span></span><br><span class="line">      _checkCacheSize(timelineTask);<span class="comment">//检查缓存大小，并清理缓存</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      image.dispose();<span class="comment">//图片过大，释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _trackLiveImage(<span class="built_in">Object</span> key, ImageStreamCompleter completer, <span class="built_in">int?</span> sizeBytes) &#123;</span><br><span class="line">    <span class="comment">//加入缓存队列</span></span><br><span class="line">    _liveImages.putIfAbsent(key, () &#123;</span><br><span class="line">      <span class="keyword">return</span> _LiveImage(</span><br><span class="line">        completer,</span><br><span class="line">        () &#123;</span><br><span class="line">          _liveImages.remove(key);</span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">    &#125;).sizeBytes ??= sizeBytes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _checkCacheSize(TimelineTask? timelineTask) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; finishArgs = &lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt;&#123;&#125;;</span><br><span class="line">    TimelineTask? checkCacheTask;</span><br><span class="line">    <span class="keyword">while</span> (_currentSizeBytes &gt; _maximumSizeBytes || _cache.length &gt; _maximumSize) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Object</span> key = _cache.keys.first;<span class="comment">//取出最先加入的图片</span></span><br><span class="line">      <span class="keyword">final</span> _CachedImage image = _cache[key]!;</span><br><span class="line">      _currentSizeBytes -= image.sizeBytes!;<span class="comment">//更新大小</span></span><br><span class="line">      image.dispose();<span class="comment">//释放资源</span></span><br><span class="line">      _cache.remove(key);<span class="comment">//移除缓存注册信息</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href>Flutter源码内核剖析</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Image%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/image1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;_ImageState是Im</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Layer</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Layer/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Layer/</id>
    <published>2024-08-02T13:15:20.034Z</published>
    <updated>2024-08-02T13:15:20.034Z</updated>
    
    <content type="html"><![CDATA[<p>Layer是Flutter中针对SceneBuilder的一些方法做的一个封装，每种Layer都对应了一个或多个SceneBuilder的方法。</p><p>Layer分类：</p><ul><li>有孩子节点的Layer：<ul><li>OffsetLayer&#x2F;TransformLayer：位移类</li><li>OpacityLayer：透明度类</li><li>ClipRectLayer&#x2F;ClipRRectLayer&#x2F;ClipPathLayer：裁剪类</li><li>PhysicalModelLayer：</li></ul></li><li>无孩子节点的Layer：<ul><li>PictureLayer：绘制类，Flutter的组件基本都是通过这个Layer来绘制的</li><li>TextureLayer：纹理类，比如视频播放</li><li>PlatformViewLayer： 用于iOS上的PlatformView嵌入纹理</li></ul></li></ul><p>XXXLayer对应还有XXXEngineLayer，通过addToScene中创建。</p><p>RenderObject是渲染树中的一个节点，包含了布局和绘制逻辑。Layer是合成树的一个节点，他代表了GPU的一次绘制指令。Layer主要负责将渲染树中的绘制操作转换为GPU可以理解的指令。</p><p>RenderObject的paint方法中，会创建新的Layer或更新已有的Layer。这些Layer会被添加到合成树中，然后在后续的合成阶段，会被转换为GPU的绘制指令。</p><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Layer/Element_RenderObject_LayerTree.png"></p><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Layer/Layer.png"></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Layer</span> <span class="title">with</span> <span class="title">DiagnosticableTreeMixin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">SceneBuilder.pushXXX创建</span></span></span><br><span class="line">ui.EngineLayer? _engineLayer;</span><br><span class="line"></span><br><span class="line"><span class="comment">///<span class="language-markdown">用于记录该 Layer 自上次渲染后(addToScene)是否发生了变化</span></span></span><br><span class="line"><span class="built_in">bool</span> _needsAddToScene = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">用于将 layer 送入 engine 进行渲染</span></span></span><br><span class="line"><span class="keyword">void</span> addToScene(ui.SceneBuilder builder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Layer/LayerBuild.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zxfcumtcs.github.io/2020/06/07/deepinto-flutter-layer/">深入浅出 Flutter Framework 之 Layer</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Layer是Flutter中针对SceneBuilder的一些方法做的一个封装，每种Layer都对应了一个或多个SceneBuilder的方法。&lt;/p&gt;
&lt;p&gt;Layer分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有孩子节点的Layer：&lt;ul&gt;
&lt;li&gt;OffsetLayer&amp;#x</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>文本处理</title>
    <link href="http://airshu.github.io/wiki/Flutter/UI/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"/>
    <id>http://airshu.github.io/wiki/Flutter/UI/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/</id>
    <published>2024-08-02T13:15:20.033Z</published>
    <updated>2024-08-02T13:15:20.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TextPainter"><a href="#TextPainter" class="headerlink" title="TextPainter"></a>TextPainter</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPainter</span> <span class="keyword">extends</span> <span class="title">CustomPainter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> paint(Canvas canvas, Size size) &#123;</span><br><span class="line">    <span class="comment">/// <span class="language-markdown">绘制文本</span></span></span><br><span class="line">    <span class="keyword">const</span> textStyle = TextStyle(color: Colors.black, fontSize: <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">const</span> textSpan = TextSpan(text: <span class="string">&#x27;Hello, World&#x27;</span>, style: textStyle);</span><br><span class="line">    <span class="keyword">final</span> textPainter = TextPainter(text: textSpan, textDirection: TextDirection.ltr);</span><br><span class="line">    textPainter.layout(minWidth: <span class="number">0</span>, maxWidth: size.width);</span><br><span class="line">    <span class="keyword">const</span> offset = Offset(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">    textPainter.paint(canvas, offset);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> shouldRepaint(<span class="keyword">covariant</span> CustomPainter oldDelegate) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>TextPainter封装了Paragraph，用于绘制文本。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextPainter</span> </span>&#123;</span><br><span class="line">  TextPainter(&#123;</span><br><span class="line">    InlineSpan? text,<span class="comment">//文本内容</span></span><br><span class="line">    TextAlign textAlign = TextAlign.start,<span class="comment">//对齐方式</span></span><br><span class="line">    TextDirection? textDirection,</span><br><span class="line">    <span class="built_in">double</span> textScaleFactor = <span class="number">1.0</span>,</span><br><span class="line">    <span class="built_in">int?</span> maxLines,</span><br><span class="line">    <span class="built_in">String?</span> ellipsis,</span><br><span class="line">    Locale? locale,</span><br><span class="line">    StrutStyle? strutStyle,</span><br><span class="line">    TextWidthBasis textWidthBasis = TextWidthBasis.parent,</span><br><span class="line">    ui.TextHeightBehavior? textHeightBehavior,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> layout(&#123; <span class="built_in">double</span> minWidth = <span class="number">0.0</span>, <span class="built_in">double</span> maxWidth = <span class="built_in">double</span>.infinity &#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_paragraph != <span class="keyword">null</span> &amp;&amp; minWidth == _lastMinWidth &amp;&amp; maxWidth == _lastMaxWidth) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_rebuildParagraphForPaint || _paragraph == <span class="keyword">null</span>) &#123;</span><br><span class="line">      _createParagraph();</span><br><span class="line">    &#125;</span><br><span class="line">    _lastMinWidth = minWidth;</span><br><span class="line">    _lastMaxWidth = maxWidth;</span><br><span class="line">    <span class="comment">// A change in layout invalidates the cached caret and line metrics as well.</span></span><br><span class="line">    _lineMetricsCache = <span class="keyword">null</span>;</span><br><span class="line">    _previousCaretPosition = <span class="keyword">null</span>;</span><br><span class="line">    _layoutParagraph(minWidth, maxWidth);</span><br><span class="line">    _inlinePlaceholderBoxes = _paragraph!.getBoxesForPlaceholders();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _layoutParagraph(<span class="built_in">double</span> minWidth, <span class="built_in">double</span> maxWidth) &#123;</span><br><span class="line">    _paragraph!.layout(ui.ParagraphConstraints(width: maxWidth));<span class="comment">//布局</span></span><br><span class="line">    <span class="keyword">if</span> (minWidth != maxWidth) &#123;</span><br><span class="line">      <span class="built_in">double</span> newWidth;</span><br><span class="line">      <span class="keyword">switch</span> (textWidthBasis) &#123;</span><br><span class="line">        <span class="keyword">case</span> TextWidthBasis.longestLine:</span><br><span class="line">          newWidth = _applyFloatingPointHack(_paragraph!.longestLine);</span><br><span class="line">        <span class="keyword">case</span> TextWidthBasis.parent:</span><br><span class="line">          newWidth = maxIntrinsicWidth;</span><br><span class="line">      &#125;</span><br><span class="line">      newWidth = clampDouble(newWidth, minWidth, maxWidth);</span><br><span class="line">      <span class="keyword">if</span> (newWidth != _applyFloatingPointHack(_paragraph!.width)) &#123;</span><br><span class="line">        _paragraph!.layout(ui.ParagraphConstraints(width: newWidth));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> paint(Canvas canvas, Offset offset) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">double?</span> minWidth = _lastMinWidth;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">double?</span> maxWidth = _lastMaxWidth;</span><br><span class="line">    <span class="keyword">if</span> (_paragraph == <span class="keyword">null</span> || minWidth == <span class="keyword">null</span> || maxWidth == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> StateError(</span><br><span class="line">        <span class="string">&#x27;TextPainter.paint called when text geometry was not yet calculated.\n&#x27;</span></span><br><span class="line">        <span class="string">&#x27;Please call layout() before paint() to position the text before painting it.&#x27;</span>,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_rebuildParagraphForPaint) &#123;</span><br><span class="line">      _createParagraph();</span><br><span class="line">      _layoutParagraph(minWidth, maxWidth);</span><br><span class="line">    &#125;</span><br><span class="line">    canvas.drawParagraph(_paragraph!, offset);<span class="comment">//绘制</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ui.Paragraph? _paragraph; <span class="comment">//封装的Paragraph</span></span><br><span class="line"></span><br><span class="line">  ui.Paragraph _createParagraph() &#123;</span><br><span class="line">    <span class="keyword">final</span> InlineSpan? text = <span class="keyword">this</span>.text;</span><br><span class="line">    <span class="keyword">if</span> (text == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> StateError(<span class="string">&#x27;TextPainter.text must be set to a non-null value before using the TextPainter.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ui.ParagraphBuilder builder = ui.ParagraphBuilder(_createParagraphStyle());</span><br><span class="line">    text.build(builder, textScaleFactor: textScaleFactor, dimensions: _placeholderDimensions);</span><br><span class="line">    _inlinePlaceholderScales = builder.placeholderScales;</span><br><span class="line">    <span class="keyword">final</span> ui.Paragraph paragraph = _paragraph = builder.build();</span><br><span class="line">    _rebuildParagraphForPaint = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> paragraph;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Paragraph"><a href="#Paragraph" class="headerlink" title="Paragraph"></a>Paragraph</h2><p>TextPainter通过封装Paragraph来绘制文本。绘制的基本流程：</p><ol><li>通过_createParagraphStyle创建ParagraphStyle</li><li>根据样式创建ParagraphBuilder</li><li>通过ParagraphBuilder处理文本内容和样式</li><li>Paragraph的layout进行布局</li><li>Canvas的drawParagrahp进行绘制</li></ol><p>代码示例如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">// 第一步</span></span><br><span class="line">    <span class="keyword">final</span> paragraphStyle = ParagraphStyle(</span><br><span class="line">        <span class="comment">// 字体方向，有些国家语言是从右往左排版的</span></span><br><span class="line">        textDirection: TextDirection.ltr,</span><br><span class="line">        <span class="comment">// 字体对齐方式</span></span><br><span class="line">        textAlign: TextAlign.justify,</span><br><span class="line">        fontSize: <span class="number">14</span>,</span><br><span class="line">        maxLines: <span class="number">2</span>,</span><br><span class="line">        <span class="comment">// 字体超出大小时显示的提示</span></span><br><span class="line">        ellipsis: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">        fontWeight: FontWeight.bold,</span><br><span class="line">        fontStyle: FontStyle.italic,</span><br><span class="line">        height: <span class="number">5</span>,</span><br><span class="line">        <span class="comment">// 当我们设置[TextStyle.height]时 这个高度是否应用到字体顶部和底部</span></span><br><span class="line">        textHeightBehavior: TextHeightBehavior(applyHeightToFirstAscent: <span class="keyword">true</span>, applyHeightToLastDescent: <span class="keyword">true</span>));</span><br><span class="line"><span class="comment">// 第二步 与第三步</span></span><br><span class="line">    <span class="keyword">final</span> paragraphBuilder = ParagraphBuilder(paragraphStyle)</span><br><span class="line">      ..addText(<span class="string">&#x27;ParagraphBuilder类接收一个参数，是一个ParagraphStyle类，用于设置字体基本样式，例如字体方向、对齐方向、字体粗细等，下面我们分几个步骤来绘制文字&#x27;</span>);</span><br><span class="line"><span class="comment">// 第四步</span></span><br><span class="line">    <span class="keyword">var</span> paragraph = paragraphBuilder.build();</span><br><span class="line"><span class="comment">// 第五步</span></span><br><span class="line">    paragraph.layout(ParagraphConstraints(width: <span class="number">300</span>));</span><br><span class="line"><span class="comment">// 画一个辅助矩形（可以通过paragraph.width和paragraph.height来获取绘制文字的宽高）</span></span><br><span class="line">    canvas.drawRect(Rect.fromLTRB(<span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span> + paragraph.width, <span class="number">50</span> + paragraph.height),</span><br><span class="line">        Paint()..color = Colors.red.withOpacity(<span class="number">0.5</span>));</span><br><span class="line"><span class="comment">// 第六步</span></span><br><span class="line">    canvas.drawParagraph(paragraph, Offset(<span class="number">50</span>, <span class="number">50</span>));</span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParagraphBuilder</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// <span class="language-markdown">添加文本</span></span></span><br><span class="line">  <span class="keyword">void</span> addText(<span class="built_in">String</span> text) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String?</span> error = _addText(text);</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ArgumentError(error);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">external</span> <span class="built_in">String?</span> _addText(<span class="built_in">String</span> text);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">设置样式</span></span></span><br><span class="line">  <span class="keyword">void</span> pushStyle(TextStyle style) &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Paragraph build() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> addPlaceholder(<span class="built_in">double</span> width, <span class="built_in">double</span> height, PlaceholderAlignment alignment, &#123;</span><br><span class="line">    <span class="built_in">double</span> scale = <span class="number">1.0</span>,</span><br><span class="line">    <span class="built_in">double?</span> baselineOffset,</span><br><span class="line">    TextBaseline? baseline,</span><br><span class="line">  &#125;) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Paragraph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">根据约束布局</span></span></span><br><span class="line">  <span class="keyword">void</span> layout(ParagraphConstraints constraints) &#123;</span><br><span class="line">    _layout(constraints.width);</span><br><span class="line">    <span class="keyword">assert</span>(() &#123;</span><br><span class="line">      _needsLayout = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Native</span>&lt;Void <span class="built_in">Function</span>(Pointer&lt;Void&gt;, Double)&gt;(symbol: <span class="string">&#x27;Paragraph::layout&#x27;</span>, isLeaf: <span class="keyword">true</span>)</span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">void</span> _layout(<span class="built_in">double</span> width);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">drawParagraph会调用该方法进行绘制</span></span></span><br><span class="line">  <span class="keyword">external</span> <span class="keyword">void</span> _paint(Canvas canvas, <span class="built_in">double</span> x, <span class="built_in">double</span> y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://dev.to/rrtutors/text-widget-with-read-more-or-expand-feature-flutter-nbk">Text widget with read more or expand feature - Flutter</a></li><li><a href="https://flutteragency.com/how-to-use-a-textpainter-to-draw-text-in-flutter/">How to Use a TextPainter to Draw Text In Flutter?</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;TextPainter&quot;&gt;&lt;a href=&quot;#TextPainter&quot; class=&quot;headerlink&quot; title=&quot;TextPainter&quot;&gt;&lt;/a&gt;TextPainter&lt;/h2&gt;&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="UI" scheme="http://airshu.github.io/categories/Flutter/UI/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>media_query</title>
    <link href="http://airshu.github.io/wiki/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/media_query/"/>
    <id>http://airshu.github.io/wiki/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/media_query/</id>
    <published>2024-08-02T13:15:20.033Z</published>
    <updated>2024-08-02T13:15:20.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MediaQuery"><a href="#MediaQuery" class="headerlink" title="MediaQuery"></a>MediaQuery</h2><p>MediaQuery 用于查询解析给定数据的媒体信息（例如，window宽高&#x2F;横竖屏&#x2F;像素密度比等信息）官方提供这个组件让开发者可以获取想要的数据。它主要用于不同尺寸大小设备的适配。</p><p><code>Object &gt; DiagnosticableTree &gt; Widget &gt; ProxyWidget &gt; InheritedWidget &gt; MediaQuery</code></p><h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><p><code>data → MediaQueryData</code>：MediaQueryData是MediaQuery.of获取数据的类型。</p><p>使用MediaQuery必须要MaterialApp 或者WidgetsApp去包裹我们的Widget，这样才能够提供正常使用它，否则会出现错误。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deviceData = MediaQuery.of(context); <span class="comment">// 返回 MediaQueryData</span></span><br><span class="line"><span class="keyword">var</span> width = deviceData.size.width; <span class="comment">//返回context所在的窗口宽度</span></span><br><span class="line"><span class="keyword">var</span> height = deviceData.size.height;<span class="comment">//返回context所在的窗口高度</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><h2 id="MediaQueryData"><a href="#MediaQueryData" class="headerlink" title="MediaQueryData"></a>MediaQueryData</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取MediaQueryData的方式</span></span><br><span class="line">MediaQueryData.fromWindow(WidgetsBinding.instance!.<span class="built_in">window</span>);</span><br><span class="line"></span><br><span class="line">MediaQuery.of(context);</span><br></pre></td></tr></table></figure><h3 id="常用属性-1"><a href="#常用属性-1" class="headerlink" title="常用属性"></a>常用属性</h3><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>size</td><td>逻辑像素，并不是物理像素，类似于Android中的dp，逻辑像素会在不同大小的手机上显示的大小基本一样，物理像素 &#x3D; size*devicePixelRatio。</td></tr><tr><td>devicePixelRatio</td><td>单位逻辑像素的物理像素数量，即设备像素比。</td></tr><tr><td>textScaleFactor</td><td>单位逻辑像素字体像素数，如果设置为1.5则比指定的字体大50%。</td></tr><tr><td>platformBrightness</td><td>当前设备的亮度模式，比如在Android Pie手机上进入省电模式，所有的App将会使用深色（dark）模式绘制。</td></tr><tr><td>viewInsets</td><td>被系统遮挡的部分，通常指键盘，弹出键盘，viewInsets.bottom表示键盘的高度。</td></tr><tr><td>padding</td><td>被系统遮挡的部分，通常指“刘海屏”或者系统状态栏。</td></tr><tr><td>viewPadding</td><td>被系统遮挡的部分，通常指“刘海屏”或者系统状态栏，此值独立于padding和viewInsets，它们的值从MediaQuery控件边界的边缘开始测量。在移动设备上，通常是全屏。</td></tr><tr><td>systemGestureInsets</td><td>显示屏边缘上系统“消耗”的区域输入事件，并阻止将这些事件传递给应用。比如在Android Q手势滑动用于页面导航（ios也一样），比如左滑退出当前页面。</td></tr><tr><td>physicalDepth</td><td>设备的最大深度，类似于三维空间的Z轴。</td></tr><tr><td>alwaysUse24HourFormat</td><td>是否是24小时制。</td></tr><tr><td>accessibleNavigation</td><td>用户是否使用诸如TalkBack或VoiceOver之类的辅助功能与应用程序进行交互，用于帮助视力有障碍的人进行使用。</td></tr><tr><td>invertColors</td><td>是否支持颜色反转。</td></tr><tr><td>highContrast</td><td>用户是否要求前景与背景之间的对比度高， iOS上，方法是通过“设置”-&gt;“辅助功能”-&gt;“增加对比度”。 此标志仅在运行iOS 13的iOS设备上更新或以上。</td></tr><tr><td>disableAnimations</td><td>平台是否要求尽可能禁用或减少动画。</td></tr><tr><td>boldText</td><td>平台是否要求使用粗体。</td></tr><tr><td>orientation</td><td>是横屏还是竖屏。</td></tr></tbody></table><h2 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h2><p>如果代码中直接使用MediaQuery.of(context)，则因为InheritedWidget的机制，会造成不必要的rebuild，推荐使用MediaQuery.xxxOf(context)。</p><p>为什么xxxOf可以减少刷新频率呢？</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InheritedModel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> T? inheritFrom&lt;T <span class="keyword">extends</span> InheritedModel&lt;<span class="built_in">Object</span>&gt;&gt;(BuildContext context, &#123; <span class="built_in">Object?</span> aspect &#125;) &#123;</span><br><span class="line">    <span class="comment">//参数为空，使用旧的方式</span></span><br><span class="line">    <span class="keyword">if</span> (aspect == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> context.dependOnInheritedWidgetOfExactType&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;InheritedElement&gt; models = &lt;InheritedElement&gt;[];</span><br><span class="line">    _findModels&lt;T&gt;(context, aspect, models);</span><br><span class="line">    <span class="keyword">if</span> (models.isEmpty) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> InheritedElement lastModel = models.last;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> InheritedElement model <span class="keyword">in</span> models) &#123;</span><br><span class="line">      <span class="keyword">final</span> T value = context.dependOnInheritedElement(model, aspect: aspect) <span class="keyword">as</span> T;</span><br><span class="line">      <span class="keyword">if</span> (model == lastModel) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;<span class="comment">//获取MediaQuery</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MediaQuery</span> <span class="keyword">extends</span> <span class="title">InheritedModel</span>&lt;<span class="title">_MediaQueryAspect</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">当InheritedWidget发生变化时，会调用此方法，判断是否需要刷新</span></span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotifyDependent(MediaQuery oldWidget, <span class="built_in">Set</span>&lt;<span class="built_in">Object</span>&gt; dependencies) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> <span class="built_in">Object</span> dependency <span class="keyword">in</span> dependencies) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dependency <span class="keyword">is</span> _MediaQueryAspect) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (dependency) &#123;</span><br><span class="line">          <span class="keyword">case</span> _MediaQueryAspect.size:</span><br><span class="line">            <span class="keyword">if</span> (data.size != oldWidget.data.size) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/7240805459288031288">Flutter 小技巧之 3.10 全新的 MediaQuery 优化与 InheritedModel</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MediaQuery&quot;&gt;&lt;a href=&quot;#MediaQuery&quot; class=&quot;headerlink&quot; title=&quot;MediaQuery&quot;&gt;&lt;/a&gt;MediaQuery&lt;/h2&gt;&lt;p&gt;MediaQuery 用于查询解析给定数据的媒体信息（例如，window宽高</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="UI" scheme="http://airshu.github.io/categories/Flutter/UI/"/>
    
    <category term="标准库" scheme="http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
    <category term="widgets" scheme="http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>裁剪</title>
    <link href="http://airshu.github.io/wiki/Flutter/UI/%E8%A3%81%E5%89%AA/"/>
    <id>http://airshu.github.io/wiki/Flutter/UI/%E8%A3%81%E5%89%AA/</id>
    <published>2024-08-02T13:15:20.033Z</published>
    <updated>2024-08-02T13:15:20.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h2><ul><li>ClipOval</li><li>ClipRRect</li><li>ClipRect</li><li>ClipPath</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;相关类&quot;&gt;&lt;a href=&quot;#相关类&quot; class=&quot;headerlink&quot; title=&quot;相关类&quot;&gt;&lt;/a&gt;相关类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;ClipOval&lt;/li&gt;
&lt;li&gt;ClipRRect&lt;/li&gt;
&lt;li&gt;ClipRect&lt;/li&gt;
&lt;li&gt;ClipP</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="UI" scheme="http://airshu.github.io/categories/Flutter/UI/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>CustomSingleChildLayout</title>
    <link href="http://airshu.github.io/wiki/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/CustomSingleChildLayout/"/>
    <id>http://airshu.github.io/wiki/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/CustomSingleChildLayout/</id>
    <published>2024-08-02T13:15:20.033Z</published>
    <updated>2024-08-02T13:15:20.033Z</updated>
    
    <content type="html"><![CDATA[<p>CustomSingleChildLayout解决以下几个问题：</p><ul><li>设置child的大小</li><li>设置child的位置</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> CustomSingleChildLayout(&#123;</span><br><span class="line">  <span class="keyword">super</span>.key,</span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">this</span>.delegate,<span class="comment">//通过委托类实现相关回调函数</span></span><br><span class="line">  <span class="keyword">super</span>.child,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleChildLayoutDelegate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> SingleChildLayoutDelegate(&#123; Listenable? relayout &#125;) : _relayout = relayout;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Listenable? _relayout;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">返回child的大小</span></span></span><br><span class="line">  Size getSize(BoxConstraints constraints) =&gt; constraints.biggest;</span><br><span class="line"></span><br><span class="line">  BoxConstraints getConstraintsForChild(BoxConstraints constraints) =&gt; constraints;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">返回child的偏移值</span></span></span><br><span class="line">  Offset getPositionForChild(Size size, Size childSize) =&gt; Offset.zero;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">是否需要重新布局</span></span></span><br><span class="line">  <span class="built_in">bool</span> shouldRelayout(<span class="keyword">covariant</span> SingleChildLayoutDelegate oldDelegate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可参考ToolTip的具体实现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;CustomSingleChildLayout解决以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置child的大小&lt;/li&gt;
&lt;li&gt;设置child的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="UI" scheme="http://airshu.github.io/categories/Flutter/UI/"/>
    
    <category term="标准库" scheme="http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
    <category term="widgets" scheme="http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Focus</title>
    <link href="http://airshu.github.io/wiki/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/Focus/"/>
    <id>http://airshu.github.io/wiki/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/Focus/</id>
    <published>2024-08-02T13:15:20.033Z</published>
    <updated>2024-08-02T13:15:20.033Z</updated>
    
    <content type="html"><![CDATA[<p>用于光标管理</p><h2 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h2><h3 id="FocusNode"><a href="#FocusNode" class="headerlink" title="FocusNode"></a>FocusNode</h3><p>用于Widget获取键盘焦点和处理键盘事件的对象</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FucusNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">请求焦点</span></span></span><br><span class="line"> <span class="keyword">void</span> requestFocus([FocusNode? node]) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">释放焦点</span></span></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">disposition表示释放后的行为， scope表示向上寻找最近的FocusScopeNode，previouslyFocusedChild表示寻找上一个焦点位置</span></span></span><br><span class="line"> <span class="keyword">void</span> unfocus(&#123;    UnfocusDisposition disposition = UnfocusDisposition.scope,  &#125;) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FocusScopeNode"><a href="#FocusScopeNode" class="headerlink" title="FocusScopeNode"></a>FocusScopeNode</h3><p>FocusScopeNode继承自FocusNode</p><h3 id="Focus"><a href="#Focus" class="headerlink" title="Focus"></a>Focus</h3><p>Focus是一个Widget，内部管理者一个FocusNode，监听焦点的变化。源码中很多地方都使用了Focus，比如MaterialApp、InkWell等。</p><h3 id="FocusScope"><a href="#FocusScope" class="headerlink" title="FocusScope"></a>FocusScope</h3><p>FocusScope继承Focus，允许你在多个焦点节点之间进行导航和管理焦点状态。FocusScope 通常用于处理复杂的焦点管理场景，例如在表单中有多个输入字段时。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/qq_17766199/article/details/107132031">说说Flutter中的无名英雄 —— Focus</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;用于光标管理&lt;/p&gt;
&lt;h2 id=&quot;相关类&quot;&gt;&lt;a href=&quot;#相关类&quot; class=&quot;headerlink&quot; title=&quot;相关类&quot;&gt;&lt;/a&gt;相关类&lt;/h2&gt;&lt;h3 id=&quot;FocusNode&quot;&gt;&lt;a href=&quot;#FocusNode&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="UI" scheme="http://airshu.github.io/categories/Flutter/UI/"/>
    
    <category term="标准库" scheme="http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
    <category term="widgets" scheme="http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter动画</title>
    <link href="http://airshu.github.io/wiki/Flutter/Flutter%E5%8A%A8%E7%94%BB/"/>
    <id>http://airshu.github.io/wiki/Flutter/Flutter%E5%8A%A8%E7%94%BB/</id>
    <published>2024-08-02T13:15:20.032Z</published>
    <updated>2024-08-02T13:15:20.032Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://flutter.cn/docs/development/ui/animations">https://flutter.cn/docs/development/ui/animations</a></p><h2 id="动画的基本组成"><a href="#动画的基本组成" class="headerlink" title="动画的基本组成"></a>动画的基本组成</h2><h3 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h3><p>作用：保存动画的差值和状态。整个动画执行过程可以是线性的、曲线的、一个步进函数或者任何其他曲线，由Curve来决定。</p><ul><li>addListener</li></ul><p>给Animation添加帧监听器</p><ul><li>addStatusListener</li></ul><p>动画开始、结束、正向或反向时的回调</p><h3 id="Curve"><a href="#Curve" class="headerlink" title="Curve"></a>Curve</h3><p>作用：定义动画曲线</p><p>内置Curves曲线：</p><ul><li>linear：匀速</li><li>decelerate：匀减速</li><li>ease：开始加速后面减速</li><li>easeIn：开始慢后面快</li><li>easeOut：开始快后面慢</li><li>easeInOut：开始慢，然后加速，最后再减速</li></ul><h3 id="AnimationController"><a href="#AnimationController" class="headerlink" title="AnimationController"></a>AnimationController</h3><p>作用：用于控制动画，包含启动forward、停止stop、反向播放reverse等</p><h3 id="Ticker"><a href="#Ticker" class="headerlink" title="Ticker"></a>Ticker</h3><p>当创建AnimationController时，需要传递一个vsync参数，它接收一个TickerProvider类型。通常我们会将SingleTickerProviderStateMixin添加到State的定义中，然后将State对象作为vsync的值。</p><p>SingleTickerProviderStateMixin和TickerProviderStateMixin，这两个类的区别就是是否支持创建多个TickerProvider，可以使用多个AnimationController。</p><h3 id="Tween"><a href="#Tween" class="headerlink" title="Tween"></a>Tween</h3><p>默认情况下，AnimationController对象值的范围是[0.0，1.0]。如果我们需要构建UI的动画值在不同的范围或不同的数据类型，则可以使用Tween来添加映射以生成不同的范围或数据类型的值。例如，像下面示例，Tween生成[-200.0，0.0]的值</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Tween doubleTween = Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">-200.0</span>, end: <span class="number">0.0</span>);</span><br></pre></td></tr></table></figure><p>Tween构造函数需要begin和end两个参数。Tween的唯一职责就是定义从输入范围到输出范围的映射。输入范围通常为[0.0，1.0]，但这不是必须的，我们可以自定义需要的范围。Tween继承自Animatable<T>，而不是继承自Animation<T>，Animatable中主要定义动画值的映射规则。</T></T></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Tween colorTween =</span><br><span class="line">    ColorTween(begin: Colors.transparent, end: Colors.black54);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> AnimationController controller = AnimationController(</span><br><span class="line">  duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(milliseconds: <span class="number">500</span>), </span><br><span class="line">  vsync: <span class="keyword">this</span>,</span><br><span class="line">);</span><br><span class="line">Animation&lt;<span class="built_in">int</span>&gt; alpha = IntTween(begin: <span class="number">0</span>, end: <span class="number">255</span>).animate(controller);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Animation curve = CurvedAnimation(parent: controller, curve: Curves.easeOut);</span><br><span class="line">Animation&lt;<span class="built_in">int</span>&gt; alpha = IntTween(begin: <span class="number">0</span>, end: <span class="number">255</span>).animate(curve);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Tween对象不存储任何状态，相反，它提供了evaluate(Animation<double> animation)方法，它可以获取动画当前映射值。 Animation对象的当前值可以通过value()方法取到。evaluate函数还执行一些其他处理，例如分别确保在动画值为0.0和1.0时返回开始和结束状态</double></p><p><strong>Tween的子类：</strong></p><ul><li>ColorTween</li><li>ConstantTween</li><li>CurveTween</li><li>IntTween</li><li>RectTween</li><li>ReverseTween</li><li>SizeTween</li><li>StepTween</li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScaleAnimationRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ScaleAnimationRoute(&#123;Key? key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _ScaleAnimationRouteState createState() =&gt; _ScaleAnimationRouteState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要继承TickerProvider，如果有多个AnimationController，则应该使用TickerProviderStateMixin。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_ScaleAnimationRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">ScaleAnimationRoute</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">late</span> Animation&lt;<span class="built_in">double</span>&gt; animation;</span><br><span class="line">  <span class="keyword">late</span> AnimationController controller;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    controller = AnimationController(</span><br><span class="line">      duration: <span class="keyword">const</span> <span class="built_in">Duration</span>(seconds: <span class="number">2</span>),</span><br><span class="line">      vsync: <span class="keyword">this</span>,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//匀速</span></span><br><span class="line">    <span class="comment">//图片宽高从0变到300</span></span><br><span class="line">    animation = Tween(begin: <span class="number">0.0</span>, end: <span class="number">300.0</span>).animate(controller);</span><br><span class="line">    animation.addListener(() &#123;</span><br><span class="line">        setState(() =&gt; &#123;&#125;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动动画(正向执行)</span></span><br><span class="line">    controller.forward();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: Image.asset(</span><br><span class="line">        <span class="string">&quot;imgs/avatar.png&quot;</span>,</span><br><span class="line">        width: animation.value,</span><br><span class="line">        height: animation.value,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  dispose() &#123;</span><br><span class="line">    <span class="comment">//路由销毁时需要释放动画资源</span></span><br><span class="line">    controller.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上写法封装后便是AnimatedBuilder</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnimatedBuilderExample</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123; </span><br><span class="line">  <span class="meta">@override</span> </span><br><span class="line">  _AnimatedBuilderExampleState createState() =&gt; _AnimatedBuilderExampleState(); </span><br><span class="line">&#125; </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_AnimatedBuilderExampleState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">AnimatedBuilderExample</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123; </span><br><span class="line">  <span class="keyword">late</span> AnimationController _controller; </span><br><span class="line">  <span class="keyword">late</span> Animation&lt;<span class="built_in">double</span>&gt; _animation; </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span> </span><br><span class="line">  <span class="keyword">void</span> initState() &#123; </span><br><span class="line">    <span class="keyword">super</span>.initState(); </span><br><span class="line">    _controller = AnimationController( </span><br><span class="line">      duration: <span class="built_in">Duration</span>(seconds: <span class="number">2</span>), <span class="comment">// Animation duration </span></span><br><span class="line">      vsync: <span class="keyword">this</span>, </span><br><span class="line">    ); </span><br><span class="line">    <span class="comment">// Tween animation </span></span><br><span class="line">    _animation = Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">50.0</span>, end: <span class="number">200.0</span>).animate(_controller);  </span><br><span class="line">    _controller.forward(); <span class="comment">// Start the animation </span></span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span> </span><br><span class="line">  Widget build(BuildContext context) &#123; </span><br><span class="line">    <span class="keyword">return</span> Scaffold( </span><br><span class="line">      appBar: AppBar( </span><br><span class="line">        title: Text(<span class="string">&#x27;AnimatedBuilder Demo&#x27;</span>), <span class="comment">// App bar title </span></span><br><span class="line">      ), </span><br><span class="line">      body: Center( </span><br><span class="line">        child: AnimatedBuilder( </span><br><span class="line">          animation: _controller, </span><br><span class="line">          builder: (BuildContext context, Widget? child) &#123; </span><br><span class="line">            <span class="keyword">return</span> Container( </span><br><span class="line">              width: _animation.value, <span class="comment">// Animate the width </span></span><br><span class="line">              height: _animation.value, <span class="comment">// Animate the height </span></span><br><span class="line">              color: Colors.green, <span class="comment">// Container background color </span></span><br><span class="line">              child: Center( </span><br><span class="line">                child: Text( </span><br><span class="line">                  <span class="string">&#x27;Hello&#x27;</span>, </span><br><span class="line">                  style: TextStyle(color: Colors.white), <span class="comment">// Text color </span></span><br><span class="line">                ), </span><br><span class="line">              ), </span><br><span class="line">            ); </span><br><span class="line">          &#125;, </span><br><span class="line">        ), </span><br><span class="line">      ), </span><br><span class="line">    ); </span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span> </span><br><span class="line">  <span class="keyword">void</span> dispose() &#123; </span><br><span class="line">    _controller.dispose(); <span class="comment">// Dispose of the animation controller </span></span><br><span class="line">    <span class="keyword">super</span>.dispose(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="隐式动画"><a href="#隐式动画" class="headerlink" title="隐式动画"></a>隐式动画</h2><p>Implicit Animations</p><p>ImplicitlyAnimatedWidget的子类，可以方便的设置各种各种属性的动画。隐式动画只需要传递duration，即可自行驱动。简单的动画场景可使用。</p><p><strong>系统实现的隐式动画</strong></p><ul><li>AnimatedContainer：Container属性变化过渡动画</li><li>AnimatedAlign：alignment变化过渡动画</li><li>AnimatedOpacity：透明度</li><li>AnimatedPositioned：配合Stack使用</li><li>AnimatedRotation</li><li>AnimatedScale</li><li>AnimatedSlide</li><li>AnimatedSwitcher</li><li>AnimatedSize</li><li>AnimatedCrossFade</li><li>AnimatedTheme</li><li>AnimatedPositionedDirectional</li><li>AnimatedPhysicalModel</li><li>AnimatedPadding</li></ul><p><strong>常用属性</strong></p><ul><li>duration：设置动画时长</li><li>curve：设置动画曲线</li><li>onEnd：动画结束回调</li></ul><h3 id="自定义隐式动画"><a href="#自定义隐式动画" class="headerlink" title="自定义隐式动画"></a>自定义隐式动画</h3><p>使用TweenAnimationBuilder，该 Widget 使用的时候我们需要传递 duration 参数动画时间、tween 参数动画要设置的值的范围（补间）、重要的还有 builder 参数，builder函数的参数包含context、补间参数tween的类型、还有child</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">TweenAnimationBuilder&lt;<span class="built_in">double</span>&gt;(</span><br><span class="line">    tween: Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0</span>, end: <span class="number">2</span> * pi),</span><br><span class="line">    duration: <span class="built_in">Duration</span>(seconds: <span class="number">2</span>),</span><br><span class="line">    builder: (BuildContext context, <span class="built_in">double</span> angle, Widget child) &#123;</span><br><span class="line">        <span class="keyword">return</span> Transform.rotate(</span><br><span class="line">        angle: angle,</span><br><span class="line">        child: Container(</span><br><span class="line">            color: Colors.red,</span><br><span class="line">            width: <span class="number">100</span>,</span><br><span class="line">            height: <span class="number">100</span>,</span><br><span class="line">        ),</span><br><span class="line">        );</span><br><span class="line">    &#125;,</span><br><span class="line">),</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="显示动画"><a href="#显示动画" class="headerlink" title="显示动画"></a>显示动画</h2><p>Explicit Animations</p><p>继承自AnimatedWidget，通过传入listenable来驱动视图变化。自己来控制动画的运行</p><ul><li>AlignTransition</li><li>AnimatedBuilder</li><li>DecoratedBoxTransition</li><li>DefaultTextStyleTransition</li><li>RelativePositionedTransition</li><li>RotationTransition：旋转</li><li>ScaleTransition：缩放动画，可以指定中心点</li><li>FadeTransition：透明度动画</li><li>SizeTransition：宽高变化，不会引起内容的变形</li><li>SlideTransition：位移动画</li></ul><h2 id="交织动画"><a href="#交织动画" class="headerlink" title="交织动画"></a>交织动画</h2><p>多个动画交错在一起，通过一个controller控制。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多个tween绑定controller</span></span><br><span class="line">AnimationController controller = AnimationController();</span><br><span class="line">Tween&lt;<span class="built_in">double</span>&gt;(begin: <span class="number">0</span>, end: <span class="number">100</span>).animate(CurvedAnimation(parent: controller, curve: Interval(<span class="number">0.0</span>, <span class="number">0.5</span>, curve: Curves.ease)));</span><br><span class="line">ColorTween(begin: Colors.green, end: Colors.red,).amimate(CurvedAnimation(parent: controller, curve: Interval(<span class="number">0.5</span>, <span class="number">0.8</span>, curve: Curves.ease,)));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://book.flutterchina.club/chapter9/intro.html#_9-1-1-%E5%8A%A8%E7%94%BB%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">Flutter实战-动画</a></li><li><a href="http://gityuan.com/2019/07/13/flutter_animator/">深入理解Flutter动画原理</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://flutter.cn/docs/development/ui/animations&quot;&gt;https://flutter.cn/docs/development/ui/animations&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;动画的基本组成&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Widget</title>
    <link href="http://airshu.github.io/wiki/Flutter/UI/Widget/"/>
    <id>http://airshu.github.io/wiki/Flutter/UI/Widget/</id>
    <published>2024-08-02T13:15:20.032Z</published>
    <updated>2024-08-02T13:15:20.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2><p>Flutter中的一切都是Widget。关于Flutter的UI绘制原理可以参考<a href="https://juejin.cn/post/6844903794627575822">纷争再起：Flutter-UI绘制解析</a>。</p><p>简要概括就是，我们写各种widget，Flutter框架帮我们解析成element树，最终转换成renderobject树，再通过底层skia绘制。</p><p><img src="/wiki/Flutter/UI/Widget/widget_1.png"></p><ul><li>Component Widget：组合类Widget，这类Widget都继承StatelessWidget或StatefulWidget；</li><li>Render Widget：渲染类Widget，参与layout、paint流程，有与之对应的Render Object；</li><li>Proxy Widget：代理类Widget，提供一些附加的功能，比如InheritedWidget用于共享信息，ParentDataWidget用于为其他Widget提供信息；</li></ul><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>如果 widget <code>A</code> 拥有子 widget，那么 widget <code>A</code> 的 context 将成为其直接关联子 context 的父 context。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.ancestorWidgetOfExactType(Scaffold) =&gt; 通过从 context 得到树结构来返回第一个 Scaffold</span><br></pre></td></tr></table></figure><p>Widget主要有两种类型：</p><ul><li>StatelessWidget：只有在创建的时候绘制一次</li><li>StatefulWidget：根据状态会发生变化</li></ul><p>感觉这样设计还是处于性能考虑，当某些控件不需要改变UI时，使用StatelessWidget就不会重绘。</p><h2 id="Widget-1"><a href="#Widget-1" class="headerlink" title="Widget"></a>Widget</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> Key? key;<span class="comment">//标识 https://medium.com/flutter/keys-what-are-they-good-for-13cb51742e7d</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">Element</span> createElement();<span class="comment">//每个Widget对应一个Element</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/// <span class="language-markdown">是否需要更新，根据runtimeType和key来判断,新旧Widget相同就只需要更新数据</span></span></span><br><span class="line">   <span class="keyword">static</span> <span class="built_in">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class="line">    <span class="keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class="line">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>为什么widget都是immutable?</code></p><p>@immutable 代表 Widget 是不可变的，这会限制 Widget 中定义的属性（即配置信息）必须是不可变的（final），为什么不允许 Widget 中定义的属性变化呢？这是因为，Flutter 中如果属性发生变化则会重新构建Widget树，即重新创建新的 Widget 实例来替换旧的 Widget 实例，所以允许 Widget 的属性变化是没有意义的，因为一旦 Widget 自己的属性变了自己就会被替换。这也是为什么 Widget 中定义的属性必须是 final 的原因。</p><h2 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h2><p>对于StatelessWidget，只需要重写build方法即可。</p><h2 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h2><p>StatefulWidget是通过State来管理状态，State的生命周期也就是State的生命周期。参考：<a href="/wiki/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/framework/State/">State</a></p><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><p>在 Fultter 中，每一个 Widget 都是被唯一标识的。这个唯一标识在 build&#x2F;rendering 阶段由框架定义。该唯一标识对应于可选的 Key 参数。如果省略该参数，Flutter 将会为你生成一个。</p><p>参考：<a href="/wiki/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/framework/Key/">key</a></p><h3 id="访问子Widget"><a href="#访问子Widget" class="headerlink" title="访问子Widget"></a>访问子Widget</h3><p>通过key</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">GlobalKey&lt;MyStatefulWidgetState&gt; myWidgetStateKey = <span class="keyword">new</span> GlobalKey&lt;MyStatefulWidgetState&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line">Widget build(BuildContext context)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyStatefulWidget(</span><br><span class="line">        key: myWidgetStateKey,</span><br><span class="line">        color: Colors.blue,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///<span class="language-markdown">访问子State</span></span></span><br><span class="line">myWidgetStateKey.currentState</span><br></pre></td></tr></table></figure><h3 id="访问父Widget"><a href="#访问父Widget" class="headerlink" title="访问父Widget"></a>访问父Widget</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyExposingWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">MyExposingWidget</span>&gt;</span>&#123;</span><br><span class="line">   Color _color;</span><br><span class="line"></span><br><span class="line">   Color <span class="keyword">get</span> color =&gt; _color;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChildWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   Widget build(BuildContext context)&#123;</span><br><span class="line">   <span class="comment">// 通过context的方法</span></span><br><span class="line">      <span class="keyword">final</span> MyExposingWidget widget = context.ancestorWidgetOfExactType(MyExposingWidget);</span><br><span class="line">      <span class="keyword">final</span> MyExposingWidgetState state = widget?.myState;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Container(</span><br><span class="line">         color: state == <span class="keyword">null</span> ? Colors.blue : state.color,</span><br><span class="line">      );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="StatelessWidget、StatefulWidget选择策略："><a href="#StatelessWidget、StatefulWidget选择策略：" class="headerlink" title="StatelessWidget、StatefulWidget选择策略："></a>StatelessWidget、StatefulWidget选择策略：</h3><ul><li>优先使用 StatelessWidget</li><li>含有大量子 Widget（如根布局、次根布局）慎用 StatefulWidget</li><li>尽量在叶子节点使用 StatefulWidget</li><li>将会调用到setState((){}) 的代码尽可能的和要更新的视图封装在一个尽可能小的模块里。</li><li>如果一个Widget需要reBuild，那么它的子节点、兄弟节点、兄弟节点的子节点应该尽可能少</li></ul><h2 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h2><p>允许树中较低层次的widget向上查找，获得祖先widget的引用，以及在祖先改变的时候重建自身。Theme.of()和Navigator.of()都是InheritedWidget的例子。</p><p>InheritedWidget 组件的所有子组件都可以直接通过 BuildContext.dependOnInheritedWidgetOfExactType 获取数据。</p><p>updateShouldNotify方法来决定是否通知子树中依赖data的Widget。 如果返回true，则子树中依赖(build函数中有调用)本widget的子widget的<code>state.didChangeDependencies</code>会被调用</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/6844903794627575822">纷争再起：Flutter-UI绘制解析</a></li><li><a href="https://book.flutterchina.club/chapter7/inherited_widget.html">数据共享（InheritedWidget）</a></li><li><a href="https://segmentfault.com/a/1190000039030651">源码分析系列之InheritedWidget</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Widget&quot;&gt;&lt;a href=&quot;#Widget&quot; class=&quot;headerlink&quot; title=&quot;Widget&quot;&gt;&lt;/a&gt;Widget&lt;/h2&gt;&lt;p&gt;Flutter中的一切都是Widget。关于Flutter的UI绘制原理可以参考&lt;a href=&quot;https</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="UI" scheme="http://airshu.github.io/categories/Flutter/UI/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
</feed>
