<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Airshu&#39;s Blog</title>
  
  <subtitle>Hello World</subtitle>
  <link href="http://airshu.github.io/atom.xml" rel="self"/>
  
  <link href="http://airshu.github.io/"/>
  <updated>2024-07-26T13:38:12.827Z</updated>
  <id>http://airshu.github.io/</id>
  
  <author>
    <name>airshu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Element</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/</id>
    <published>2024-07-26T13:38:12.827Z</published>
    <updated>2024-07-26T13:38:12.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Widget是UI元素的配置数据，Element代表屏幕显示元素。主要作用：</p><ul><li>维护这棵Element Tree，根据Widget Tree的变化来更新Element Tree，包括：节点的插入、更新、删除、移动等；</li><li>将Widget和RenderObject关联到Element Tree上。</li></ul><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/element_1.png"></p><ul><li>ComponentElement：用来组合其他更基础的Element，开发时常用到的StatelessWidget和StatefulWidget相对应的Element：StatelessElement和StatefulElement。其子节点对应的Widget需要通过build方法创建，该类型Element只有一个子节点。</li><li>RenderObjectElement：渲染类Element，对应Renderer Widget，是框架最核心的Element。RenderObjectElement主要包括LeafRenderObjectElement，SingleChildRenderObjectElement，和MultiChildRenderObjectElement。<ul><li>LeafRenderObjectElement对应的Widget是LeafRenderObjectWidget，没有子节点；</li><li>SingleChildRenderObjectElement对应的Widget是SingleChildRenderObjectWidget，有一个子节点；</li><li>MultiChildRenderObjectElement对应的Widget是MultiChildRenderObjecWidget，有多个子节点。</li></ul></li></ul><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/element_9.png"></p><h2 id="重要属性和方法"><a href="#重要属性和方法" class="headerlink" title="重要属性和方法"></a>重要属性和方法</h2><p>Element的子类：</p><ul><li>ComponentElement<ul><li>StatelessElement</li><li>StatefulElement</li><li>ProxyElement<ul><li>ParentDataElement</li><li>InheritedElement</li></ul></li></ul></li><li>RenderObjectElement<ul><li>LeafRenderObjectElement</li><li>SingleChildRenderObjectElement</li><li>MultiChildRenderObjectElement<ul><li>TheatreElement</li></ul></li><li>RootRenderObjectElement</li></ul></li><li>_NullElement</li><li>RenderObjectToWidgetElement：element树的根节点</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">Type</span>, InheritedElement&gt;? _inheritedWidgets;</span><br><span class="line"><span class="built_in">Set</span>&lt;InheritedElement&gt; _dependencies;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InheritedElement</span> <span class="keyword">extends</span> <span class="title">ProxyElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">Element</span>, <span class="built_in">Object?</span>&gt; _dependents = HashMap&lt;<span class="built_in">Element</span>, <span class="built_in">Object?</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _updateInheritance() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_lifecycleState == _ElementLifecycle.active);</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">Type</span>, InheritedElement&gt;? incomingWidgets = _parent?._inheritedWidgets;</span><br><span class="line">    <span class="keyword">if</span> (incomingWidgets != <span class="keyword">null</span>)</span><br><span class="line">      _inheritedWidgets = HashMap&lt;<span class="built_in">Type</span>, InheritedElement&gt;.of(incomingWidgets);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      _inheritedWidgets = HashMap&lt;<span class="built_in">Type</span>, InheritedElement&gt;();</span><br><span class="line">    _inheritedWidgets![widget.runtimeType] = <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> <span class="keyword">implements</span> <span class="title">BuildContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 槽，用来存储一些额外信息，比如坐标</span></span><br><span class="line">  <span class="built_in">Object?</span> <span class="keyword">get</span> slot =&gt; _slot;</span><br><span class="line">  <span class="built_in">Object?</span> _slot;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// element tree上的深度</span></span><br><span class="line">  <span class="keyword">late</span> <span class="built_in">int</span> _depth;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开发人员需要处理的Widget</span></span><br><span class="line">  Widget _widget;</span><br><span class="line"></span><br><span class="line">  BuildOwner _owner;<span class="comment">//用来处理Element的对象，全局一个，将element tree转换成renderobject tree</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  InheritedWidget dependOnInheritedElement(InheritedElement ancestor, &#123; <span class="built_in">Object?</span> aspect &#125;) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(ancestor != <span class="keyword">null</span>);</span><br><span class="line">    _dependencies ??= HashSet&lt;InheritedElement&gt;();</span><br><span class="line">    _dependencies!.add(ancestor);</span><br><span class="line">    ancestor.updateDependencies(<span class="keyword">this</span>, aspect);</span><br><span class="line">    <span class="keyword">return</span> ancestor.widget;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  T? dependOnInheritedWidgetOfExactType&lt;T <span class="keyword">extends</span> InheritedWidget&gt;(&#123;<span class="built_in">Object?</span> aspect&#125;) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_debugCheckStateIsActiveForAncestorLookup());</span><br><span class="line">    <span class="keyword">final</span> InheritedElement? ancestor = _inheritedWidgets == <span class="keyword">null</span> ? <span class="keyword">null</span> : _inheritedWidgets![T];</span><br><span class="line">    <span class="keyword">if</span> (ancestor != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> dependOnInheritedElement(ancestor, aspect: aspect) <span class="keyword">as</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    _hadUnsatisfiedDependencies = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  InheritedElement? getElementForInheritedWidgetOfExactType&lt;T <span class="keyword">extends</span> InheritedWidget&gt;() &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_debugCheckStateIsActiveForAncestorLookup());</span><br><span class="line">    <span class="keyword">final</span> InheritedElement? ancestor = _inheritedWidgets == <span class="keyword">null</span> ? <span class="keyword">null</span> : _inheritedWidgets![T];</span><br><span class="line">    <span class="keyword">return</span> ancestor;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从根节点到子节点，以runtimeType作为key，保存最新的Element对象。getElementForInheritedWidgetOfExactType方法可以通过类型查找离自己最近的类型的对象。<br>dependOnInheritedWidgetOfExactType方法会注册依赖，当InheritedWidget发生变化时就会更新依赖它的子组件。</p><h3 id="updateChild"><a href="#updateChild" class="headerlink" title="updateChild"></a>updateChild</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">父节点通过该方法来修改子节点对应的Widget</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">newWidget == null   说明子节点对应的Widget已被移除，直接remove child element</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">child == null   说明newWidget是新插入的，通过inflateWidget创建子节点</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">child != null   分以下几种情况：</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="bullet">    1.</span> child.widget == newWidget，说明没变化，若child.slot != newSlot 表明子节点在兄弟节点间移动了位置，通过updateSlotForChild修改child.slot即可；</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="bullet">    2.</span> widget.canUpdate判断是否可以用newWidget修改child element，若可以则调用update方法；</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown"><span class="bullet">    3.</span> 否则先将child element移除，并通过newWidget创建新的element子节点。</span></span></span><br><span class="line"><span class="built_in">Element?</span> updateChild(<span class="built_in">Element?</span> child, Widget? newWidget, <span class="built_in">Object?</span> newSlot) &#123; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><h4 id="Element"><a href="#Element" class="headerlink" title="Element"></a>Element</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> update(<span class="keyword">covariant</span> Widget newWidget) &#123;</span><br><span class="line">    _widget = newWidget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> rebuild() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_lifecycleState != _ElementLifecycle.active || !_dirty)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="built_in">Element?</span> debugPreviousBuildTarget;</span><br><span class="line">  performRebuild();<span class="comment">//ComponentElement中调用build、updateChild</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Element?</span> updateChild(<span class="built_in">Element?</span> child, Widget? newWidget, <span class="built_in">Object?</span> newSlot) &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="StatelessElement"><a href="#StatelessElement" class="headerlink" title="StatelessElement"></a>StatelessElement</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> update(StatelessWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  <span class="keyword">assert</span>(widget == newWidget);</span><br><span class="line">  _dirty = <span class="keyword">true</span>;</span><br><span class="line">  rebuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rebuild调用performRebuild，调用当前build方法和updateChild。</p><h4 id="StatefulElement"><a href="#StatefulElement" class="headerlink" title="StatefulElement"></a>StatefulElement</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatefulElement</span> <span class="keyword">extends</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//开发者操作的对象，同样有相应生命周期，参考_StateLifecycle</span></span><br><span class="line">  State&lt;StatefulWidget&gt;? _state;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> update(StatefulWidget newWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">    <span class="keyword">final</span> StatefulWidget oldWidget = state._widget!;</span><br><span class="line">    _dirty = <span class="keyword">true</span>;</span><br><span class="line">    state._widget = widget <span class="keyword">as</span> StatefulWidget;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _debugSetAllowIgnoredCallsToMarkNeedsBuild(<span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Object?</span> debugCheckForReturnedFuture = state.didUpdateWidget(oldWidget) <span class="keyword">as</span> <span class="built_in">dynamic</span>;</span><br><span class="line">      <span class="keyword">assert</span>(() &#123;</span><br><span class="line">        <span class="keyword">if</span> (debugCheckForReturnedFuture <span class="keyword">is</span> Future) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      _debugSetAllowIgnoredCallsToMarkNeedsBuild(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rebuild();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>处理State：</p><ul><li>修改_widget属性</li><li>调用didUpdateWidget更新属性</li></ul><p>然后触发rebuild操作。</p><h4 id="ProxyElement"><a href="#ProxyElement" class="headerlink" title="ProxyElement"></a>ProxyElement</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> update(ProxyWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">final</span> ProxyWidget oldWidget = widget;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  updated(oldWidget);</span><br><span class="line">  _dirty = <span class="keyword">true</span>;</span><br><span class="line">  rebuild();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@protected</span></span><br><span class="line"><span class="keyword">void</span> updated(<span class="keyword">covariant</span> ProxyWidget oldWidget) &#123;</span><br><span class="line">  notifyClients(oldWidget);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>update方法会通知关联对象Widget有更新。不同子类的notifyClients实现不同。</p><h4 id="RenderObjectElement"><a href="#RenderObjectElement" class="headerlink" title="RenderObjectElement"></a>RenderObjectElement</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> update(<span class="keyword">covariant</span> RenderObjectWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  <span class="keyword">assert</span>(widget == newWidget);</span><br><span class="line">  <span class="keyword">assert</span>(() &#123;</span><br><span class="line">    _debugUpdateRenderObjectOwner();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;());</span><br><span class="line">  _performRebuild(); <span class="comment">// calls widget.updateRenderObject()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _performRebuild() &#123;</span><br><span class="line">  widget.updateRenderObject(<span class="keyword">this</span>, renderObject);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SingleChildRenderObject"><a href="#SingleChildRenderObject" class="headerlink" title="SingleChildRenderObject"></a>SingleChildRenderObject</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> update(SingleChildRenderObjectWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  <span class="keyword">assert</span>(widget == newWidget);</span><br><span class="line">  _child = updateChild(_child, widget.child, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="MultiChildRenderObject"><a href="#MultiChildRenderObject" class="headerlink" title="MultiChildRenderObject"></a>MultiChildRenderObject</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> update(MultiChildRenderObjectWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  _children = updateChildren(_children, widget.children, forgottenChildren: _forgottenChildren);</span><br><span class="line">  _forgottenChildren.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>updateChildren中处理子节点的插入、移动、更新、删除等操作。</p><h3 id="inflateWidget"><a href="#inflateWidget" class="headerlink" title="inflateWidget"></a>inflateWidget</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Element</span> inflateWidget(Widget newWidget, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">final</span> Key? key = newWidget.key;</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;</span><br><span class="line">  <span class="comment">//如果带有GlobalKey，首先在inactive Elements列表中查找是否有处于inactive状态的节点（即刚从树上移除），如找到就直接复活该节点。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Element?</span> newChild = _retakeInactiveElement(key, newWidget);</span><br><span class="line">    <span class="keyword">if</span> (newChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">      newChild._activateWithParent(<span class="keyword">this</span>, newSlot);</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Element?</span> updatedChild = updateChild(newChild, newWidget, newSlot);</span><br><span class="line">      <span class="keyword">return</span> updatedChild!;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Element</span> newChild = newWidget.createElement();</span><br><span class="line">  newChild.mount(<span class="keyword">this</span>, newSlot);<span class="comment">//挂载到树上</span></span><br><span class="line">  <span class="keyword">return</span> newChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><h4 id="Element-1"><a href="#Element-1" class="headerlink" title="Element"></a>Element</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element?</span> parent, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">  _parent = parent;</span><br><span class="line">  _slot = newSlot;</span><br><span class="line">  _lifecycleState = _ElementLifecycle.active;</span><br><span class="line">  _depth = _parent != <span class="keyword">null</span> ? _parent!.depth + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    _owner = parent.owner;<span class="comment">//传递owner给子节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> Key? key = widget.key;</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;</span><br><span class="line">    owner!._registerGlobalKey(key, <span class="keyword">this</span>);<span class="comment">//GlobalKey注册自己，方便其他地方使用</span></span><br><span class="line">  &#125;</span><br><span class="line">  _updateInheritance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="ComponentElement"><a href="#ComponentElement" class="headerlink" title="ComponentElement"></a>ComponentElement</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element?</span> parent, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  <span class="keyword">assert</span>(_child == <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">assert</span>(_lifecycleState == _ElementLifecycle.active);</span><br><span class="line">  _firstBuild();</span><br><span class="line">  <span class="keyword">assert</span>(_child != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _firstBuild() &#123;</span><br><span class="line">  <span class="comment">// StatefulElement overrides this to also call state.didChangeDependencies.</span></span><br><span class="line">  rebuild(); <span class="comment">// This eventually calls performRebuild.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>组合型 Element 在挂载时会执行_firstBuild-&gt;rebuild操作。</p><h4 id="RenderObjectElement-1"><a href="#RenderObjectElement-1" class="headerlink" title="RenderObjectElement"></a>RenderObjectElement</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">  attachRenderObject(newSlot);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建RenderObject并插入到树上。</p><h4 id="SingleChildRenderObjectElement"><a href="#SingleChildRenderObjectElement" class="headerlink" title="SingleChildRenderObjectElement"></a>SingleChildRenderObjectElement</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _child = updateChild(_child, widget.child, <span class="keyword">null</span>);<span class="comment">//创建新Element实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MultiChildRenderObjectElement"><a href="#MultiChildRenderObjectElement" class="headerlink" title="MultiChildRenderObjectElement"></a>MultiChildRenderObjectElement</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _children = <span class="built_in">List</span>&lt;<span class="built_in">Element</span>&gt;(widget.children.length);</span><br><span class="line">  <span class="built_in">Element</span> previousChild;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; _children.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Element</span> newChild = inflateWidget(widget.children[i], previousChild);</span><br><span class="line">    _children[i] = newChild;</span><br><span class="line">    previousChild = newChild;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对每个子节点调用inflateWidget。</p><h3 id="markNeedsBuild"><a href="#markNeedsBuild" class="headerlink" title="markNeedsBuild"></a>markNeedsBuild</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsBuild() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_active)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dirty)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  _dirty = <span class="keyword">true</span>;</span><br><span class="line">  owner.scheduleBuildFor(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标记需要重建，其作用是将当前Element加入_dirtyElements，以便在下一帧可以rebuild。以下场景会调用markNeedsBuild：</p><ul><li>State.setState</li><li>Element.reassemble：debug hot reload</li><li>Element.didChangeDependencies：</li><li>StatefulElement.activate</li></ul><h3 id="rebuild"><a href="#rebuild" class="headerlink" title="rebuild"></a>rebuild</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> rebuild() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_active || !_dirty)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  performRebuild();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>活跃的或脏节点会执行performRebuild，以下场景会调用rebuild：</p><ul><li>对于dirty element，在新一帧绘制过程中由BuildOwner.buildScope</li><li>在element挂载时，由Element.mount调用</li><li>在update方法内被调用</li></ul><h3 id="performRebuild"><a href="#performRebuild" class="headerlink" title="performRebuild"></a>performRebuild</h3><h4 id="ComponentElement-1"><a href="#ComponentElement-1" class="headerlink" title="ComponentElement"></a>ComponentElement</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">  Widget built;</span><br><span class="line">  built = build();</span><br><span class="line"></span><br><span class="line">  _child = updateChild(_child, built, slot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组合型Element，先build自己，再更新子节点</p><h4 id="RenderObjectElement-2"><a href="#RenderObjectElement-2" class="headerlink" title="RenderObjectElement"></a>RenderObjectElement</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">  widget.updateRenderObject(<span class="keyword">this</span>, renderObject);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>Element有4种状态：initial，active，inactive，defunct。其对应的意义如下：</p><ul><li>initial：初始状态，Element刚创建时就是该状态。、</li><li>active：激活状态。此时Element的Parent已经通过mount将该Element插入Element Tree的指定的插槽处（Slot），Element此时随时可能显示在屏幕上。</li><li>inactive：未激活状态。当Widget Tree发生变化，Element对应的Widget发生变化，同时由于新旧Widget的Key或者的RunTimeType不匹配等原因导致该Element也被移除，因此该Element的状态变为未激活状态，被从屏幕上移除。并将该Element从Element Tree中移除，如果该Element有对应的RenderObject，还会将对应的RenderObject从Render Tree移除。但是，此Element还是有被复用的机会，例如通过GlobalKey进行复用。</li><li>defunct：失效状态。如果一个处于未激活状态的Element在当前帧动画结束时还是未被复用，此时会调用该Element的unmount函数，将Element的状态改为defunct，并对其中的资源进行清理。</li></ul><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/element_2.png"></p><h2 id="ComponentElement-2"><a href="#ComponentElement-2" class="headerlink" title="ComponentElement"></a>ComponentElement</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/element_3.png"></p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/element_4.png"></p><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/element_5.jpg"></p><h2 id="RenderObjectElement-3"><a href="#RenderObjectElement-3" class="headerlink" title="RenderObjectElement"></a>RenderObjectElement</h2><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/element_6.png"></p><h3 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h3><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/element_7.png"></p><h3 id="销毁-1"><a href="#销毁-1" class="headerlink" title="销毁"></a>销毁</h3><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Element/element_8.jpg"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Element继承自BuildContext，所以我们在平常使用的context其实就是Element。各种of方法其实就是操作Element树来获取相应对象。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://zxfcumtcs.github.io/2020/05/17/deepinto-flutter-element/">深入浅出 Flutter Framework 之 Element</a></li><li><a href="https://medium.com/flutter/keys-what-are-they-good-for-13cb51742e7d">Keys! What are they good for?</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;Widget是UI元素的配置数据，Element代表屏幕显示元素。主要作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维护这棵Element Tree，根</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Build过程</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Build%E8%BF%87%E7%A8%8B/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Build%E8%BF%87%E7%A8%8B/</id>
    <published>2024-07-26T13:38:12.827Z</published>
    <updated>2024-07-26T13:38:12.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概括"><a href="#概括" class="headerlink" title="概括"></a>概括</h2><ol><li>runApp，初始化构建Widget树，Widget对应Element，创建Element树；</li><li>调用setState方法时，会将对应的element添加到dirtyElement队列中；触发WidgetsBinding中的_handleBuildScheduled方法，下一帧drawFrame会调用buildScope方法；</li><li>在buildScope方法中，会对dirtyElement队列中的element进行排序，然后逐个调用rebuild方法，触发对应的生命周期方法，State的didChangeDependencies、build等；</li><li>当Widget从树中移除时，会调用deactivate方法，将对应的element添加到inactiveElement队列中；调用unmount方法</li></ol><h2 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h2><p>开发者用来绘制UI的配置挂件，每一个Widget都对应一个Element(通过createElement创建)。Widget是不可变的。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetsBinding</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">  <span class="keyword">void</span> initInstances() &#123;</span><br><span class="line">    _buildOwner = BuildOwner(onBuildScheduled: _handleBuildScheduled); 管理整个build过程</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> attachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">    rootElement = RenderObjectToWidgetAdapter&lt;RenderObjectToWidgetAdapter&gt;(</span><br><span class="line">      container: renderView,</span><br><span class="line">      debugShortDescription: <span class="string">&#x27;[root]&#x27;</span>,</span><br><span class="line">      owner: <span class="keyword">this</span>,</span><br><span class="line">    ).attachToRenderTree(rootElement);<span class="comment">//初始化</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">每一帧都会调用该方法</span></span></span><br><span class="line">  <span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">    buildOwner.buildScope(rootElement);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObjectToWidgetAdapter</span> </span>&#123;</span><br><span class="line">  attachToRenderTree(RenderObjectToWidgetElement&lt;RenderObjectToWidgetAdapter&gt; element) &#123;</span><br><span class="line">    owner.buildScope(element, ()&#123;</span><br><span class="line">      element!.mount(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildOwner</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> buildScope(<span class="built_in">Element</span> context, [VoidCallback? callback]) &#123;</span><br><span class="line">    callback();</span><br><span class="line">    element.rebuild();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> rebuild() &#123;</span><br><span class="line">    performRebuild();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatefulElement</span> <span class="keyword">extends</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    state.didChangeDependencies();<span class="comment">//生命周期回调</span></span><br><span class="line">    <span class="keyword">super</span>.performRebuild();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    build();<span class="comment">//生命周期回调</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h2><h3 id="标脏阶段"><a href="#标脏阶段" class="headerlink" title="标脏阶段"></a>标脏阶段</h3><p>我们在需要触发刷新时会调用setState方法，会对该element进行标脏，然后擦除脏标记。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> setState(VoidCallback fn) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Object?</span> result = fn() <span class="keyword">as</span> <span class="built_in">dynamic</span>;<span class="comment">//执行用户的逻辑</span></span><br><span class="line">    _element!.markNeedsBuild();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> markNeedsBuild() &#123;</span><br><span class="line">    _dirty = <span class="keyword">true</span>;</span><br><span class="line">    owner.scheduleBuildFor(<span class="keyword">this</span>);<span class="comment">//在BuildOwner中进一步标记</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BuildOwner"><a href="#BuildOwner" class="headerlink" title="BuildOwner"></a>BuildOwner</h3><p>作用：</p><ol><li>在 UI 更新过程中跟踪、管理需要 rebuild 的 Element (「dirty elements」);</li><li>在有「dirty elements」时，及时通知引擎，以便在下一帧安排上对「dirty elements」的 rebuild，从而去刷新 UI；</li><li>管理处于 “inactive” 状态的 Element。</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildOwner</span> </span>&#123;</span><br><span class="line">  BuildOwner(&#123; <span class="keyword">this</span>.onBuildScheduled, FocusManager? focusManager &#125;) :</span><br><span class="line">      focusManager = focusManager ?? (FocusManager()..registerGlobalHandlers());</span><br><span class="line"></span><br><span class="line">  VoidCallback? onBuildScheduled;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> _InactiveElements _inactiveElements = _InactiveElements();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">Element</span>&gt; _dirtyElements = &lt;<span class="built_in">Element</span>&gt;[];</span><br><span class="line">  <span class="built_in">bool</span> _scheduledFlushDirtyElements = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool?</span> _dirtyElementsNeedsResorting;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> _debugIsInBuildScope =&gt; _dirtyElementsNeedsResorting != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  FocusManager focusManager;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// <span class="language-markdown">setState方法会调用该方法</span></span></span><br><span class="line">  <span class="keyword">void</span> scheduleBuildFor(<span class="built_in">Element</span> element) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element._inDirtyList) &#123;<span class="comment">//已经在脏列表中，重排</span></span><br><span class="line">      _dirtyElementsNeedsResorting = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!_scheduledFlushDirtyElements &amp;&amp; onBuildScheduled != <span class="keyword">null</span>) &#123;</span><br><span class="line">      _scheduledFlushDirtyElements = <span class="keyword">true</span>;</span><br><span class="line">      onBuildScheduled!();<span class="comment">//通知下一帧要更新，对应WidgetsBinding中的_handleBuildScheduled方法，调用ensureVisualUpdate，下一帧drawFrame会调用buildScope方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    _dirtyElements.add(element);<span class="comment">//添加到脏列表</span></span><br><span class="line">    element._inDirtyList = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> _debugStateLockLevel = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> _debugStateLocked =&gt; _debugStateLockLevel &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> debugBuilding =&gt; _debugBuilding;</span><br><span class="line">  <span class="built_in">bool</span> _debugBuilding = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">Element?</span> _debugCurrentBuildTarget;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> lockState(VoidCallback callback) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// drawFrame会调用该方法</span></span><br><span class="line">  <span class="meta">@pragma</span>(<span class="string">&#x27;vm:notify-debugger-on-exception&#x27;</span>)</span><br><span class="line">  <span class="keyword">void</span> buildScope(<span class="built_in">Element</span> context, [ VoidCallback? callback ]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (callback == <span class="keyword">null</span> &amp;&amp; _dirtyElements.isEmpty) &#123;<span class="comment">//第1步</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;<span class="comment">//第2步</span></span><br><span class="line">      _scheduledFlushDirtyElements = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          callback();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      _dirtyElements.sort(<span class="built_in">Element</span>._sort);</span><br><span class="line">      _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</span><br><span class="line">      <span class="built_in">int</span> dirtyCount = _dirtyElements.length;</span><br><span class="line">      <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (index &lt; dirtyCount) &#123;<span class="comment">//第3步，开始遍历脏节点</span></span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">Element</span> element = _dirtyElements[index];</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">bool</span> isTimelineTracked = !kReleaseMode &amp;&amp; _isProfileBuildsEnabledFor(element.widget);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          element.rebuild();<span class="comment">//第4步，重新构建，触发对应生命周期方法，State的didChangeDependencies、build等</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        index += <span class="number">1</span>;<span class="comment">//第5步</span></span><br><span class="line">        <span class="keyword">if</span> (dirtyCount &lt; _dirtyElements.length || _dirtyElementsNeedsResorting!) &#123;</span><br><span class="line">          _dirtyElements.sort(<span class="built_in">Element</span>._sort);</span><br><span class="line">          _dirtyElementsNeedsResorting = <span class="keyword">false</span>;</span><br><span class="line">          dirtyCount = _dirtyElements.length;</span><br><span class="line">          <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; _dirtyElements[index - <span class="number">1</span>].dirty) &#123;</span><br><span class="line">            index -= <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> <span class="built_in">Element</span> element <span class="keyword">in</span> _dirtyElements) &#123;</span><br><span class="line">        element._inDirtyList = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      _dirtyElements.clear();</span><br><span class="line">      _scheduledFlushDirtyElements = <span class="keyword">false</span>;</span><br><span class="line">      _dirtyElementsNeedsResorting = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Map</span>&lt;<span class="built_in">Element</span>, <span class="built_in">Set</span>&lt;GlobalKey&gt;&gt;? _debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _debugTrackElementThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans(<span class="built_in">Element</span> node, GlobalKey key) &#123;</span><br><span class="line">    _debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans ??= HashMap&lt;<span class="built_in">Element</span>, <span class="built_in">Set</span>&lt;GlobalKey&gt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Set</span>&lt;GlobalKey&gt; keys = _debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans!</span><br><span class="line">      .putIfAbsent(node, () =&gt; HashSet&lt;GlobalKey&gt;());</span><br><span class="line">    keys.add(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _debugElementWasRebuilt(<span class="built_in">Element</span> node) &#123;</span><br><span class="line">    _debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans?.remove(node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span>&lt;GlobalKey, <span class="built_in">Element</span>&gt; _globalKeyRegistry = &lt;GlobalKey, <span class="built_in">Element</span>&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  @_debugOnly</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Set</span>&lt;<span class="built_in">Element</span>&gt;? _debugIllFatedElements = kDebugMode ? HashSet&lt;<span class="built_in">Element</span>&gt;() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  @_debugOnly</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">Element</span>, <span class="built_in">Map</span>&lt;<span class="built_in">Element</span>, GlobalKey&gt;&gt;? _debugGlobalKeyReservations = kDebugMode ? &lt;<span class="built_in">Element</span>, <span class="built_in">Map</span>&lt;<span class="built_in">Element</span>, GlobalKey&gt;&gt;&#123;&#125; : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> globalKeyCount =&gt; _globalKeyRegistry.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _debugRemoveGlobalKeyReservationFor(<span class="built_in">Element</span> parent, <span class="built_in">Element</span> child) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _registerGlobalKey(GlobalKey key, <span class="built_in">Element</span> element) &#123;</span><br><span class="line">    _globalKeyRegistry[key] = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _unregisterGlobalKey(GlobalKey key, <span class="built_in">Element</span> element) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_globalKeyRegistry[key] == element) &#123;</span><br><span class="line">      _globalKeyRegistry.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _debugReserveGlobalKeyFor(<span class="built_in">Element</span> parent, <span class="built_in">Element</span> child, GlobalKey key) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _debugVerifyGlobalKeyReservation() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _debugVerifyIllFatedPopulation() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@pragma</span>(<span class="string">&#x27;vm:notify-debugger-on-exception&#x27;</span>)</span><br><span class="line">  <span class="keyword">void</span> finalizeTree() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lockState(_inactiveElements._unmountAll); <span class="comment">// this unregisters the GlobalKeys</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> reassemble(<span class="built_in">Element</span> root, DebugReassembleConfig? reassembleConfig) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      root._debugReassembleConfig = reassembleConfig;</span><br><span class="line">      root.reassemble();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Flush阶段"><a href="#Flush阶段" class="headerlink" title="Flush阶段"></a>Flush阶段</h3><p>我们知道Vsync信号到达后会触发BuildOwner的buildScope方法（参考上面的代码解释），该方法分为以下几个步骤：</p><ol><li>检查参数，并标记当前进入Build流程</li><li>callback的回调，一般用于首帧渲染时3棵树的创建，更新阶段该参数为null</li><li>脏节点排序，优先更新父节点效率更高</li><li>遍历脏节点，执行rebuild方法</li><li>第5步，先将index自增，再检查当前是否满足以下两种情况之一：</li></ol><ul><li>dirtyCount &lt; _dirtyElements.length：即在处理Element脏节点的过程中又有新的节点标记为脏</li><li>_dirtyElementsNeedsResorting：通常由GlobalKey的复用导致，如果当前节点已经在列表中，则会将该字段设置为true(scheduleBuildFor方法中设置)</li></ul><p>满足任何一个都会导致_dirtyElements列表重新排序，然后将index重制到最近的一个非脏节点，并继续从该Element节点的索引进行rebuild方法</p><ol start="6"><li>将_dirtyElements列表中的每个节点的_inDirtyList字段重置为false，然后清空列表，并重置相关字段</li></ol><p>对于rebuild，会调用performRebuild方法，该方法不同子类不一样的实现</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    _dirty = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///<span class="language-markdown">对于StatefulElement来说，rebuild会触发ComponentElement的performRebuild方法</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> performRebuild() &#123;</span><br><span class="line">    Widget? built;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      built = build();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      _debugDoingBuild = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">super</span>.performRebuild(); <span class="comment">// clears the &quot;dirty&quot; flag</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _child = updateChild(_child, built, slot);<span class="comment">//完成子节点的更新</span></span><br><span class="line">      <span class="keyword">assert</span>(_child != <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      _child = updateChild(<span class="keyword">null</span>, built, slot);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Element?</span> updateChild(<span class="built_in">Element?</span> child, Widget? newWidget, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newWidget == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">        deactivateChild(child);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Element</span> newChild;</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="built_in">bool</span> hasSameSuperclass = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (hasSameSuperclass &amp;&amp; child.widget == newWidget) &#123;<span class="comment">//第1种情况</span></span><br><span class="line">        <span class="keyword">if</span> (child.slot != newSlot) &#123;</span><br><span class="line">          updateSlotForChild(child, newSlot);</span><br><span class="line">        &#125;</span><br><span class="line">        newChild = child;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasSameSuperclass &amp;&amp; Widget.canUpdate(child.widget, newWidget)) &#123;<span class="comment">//第2种情况</span></span><br><span class="line">        <span class="keyword">if</span> (child.slot != newSlot) &#123;</span><br><span class="line">          updateSlotForChild(child, newSlot);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">bool</span> isTimelineTracked = !kReleaseMode &amp;&amp; _isProfileBuildsEnabledFor(newWidget);</span><br><span class="line">        <span class="keyword">if</span> (isTimelineTracked) &#123;</span><br><span class="line">          <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;? debugTimelineArguments;</span><br><span class="line">        &#125;</span><br><span class="line">        child.update(newWidget);</span><br><span class="line">        newChild = child;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//第3种情况</span></span><br><span class="line">        deactivateChild(child);</span><br><span class="line">        newChild = inflateWidget(newWidget, newSlot);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//第4种情况</span></span><br><span class="line">      newChild = inflateWidget(newWidget, newSlot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newChild;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第1种：Widget节点相同，直接同步slot，并复用现有的Element节点。</li><li>第2种：可直接基于新的Widget节点更新，复用并更新现有的Element节点即可。不同的子类不一样的update，比如</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> update(Widget newWidget) &#123;</span><br><span class="line">    _widget = newWidget;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StatelessElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> update(Widget newWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">    _dirty = <span class="keyword">true</span>;</span><br><span class="line">    rebuild();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObjectElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> update(Widget newWidget) &#123;</span><br><span class="line">    <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">    widget.updateRenderObject(<span class="keyword">this</span>, renderObject);<span class="comment">//更新对应RenderObject</span></span><br><span class="line">    rebuild();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第3种：当前Widget Tree的子节点完全不一样，需要移除原有的Element节点，并新建新的Element节点进行挂载</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> deactivateChild(<span class="built_in">Element</span> child) &#123;</span><br><span class="line">    child._parent = <span class="keyword">null</span>;</span><br><span class="line">    child.detachRenderObject();</span><br><span class="line">    owner!._inactiveElements.add(child); <span class="comment">// this eventually calls child.deactivate()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清理阶段"><a href="#清理阶段" class="headerlink" title="清理阶段"></a>清理阶段</h3><p>在Build流程中，对于执行了deactivate方法的节点，其_lifecycleState字段的属性为inactive，当Build、Layout、Paint、Composition在UI线程的工作结束后，BuildOwner会调用finalizeTree方法进行最后的处理，其会调用_unmountAll</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_InactiveElements</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> _unmountAll() &#123;</span><br><span class="line">    _locked = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;<span class="built_in">Element</span>&gt; elements = _elements.toList()..sort(<span class="built_in">Element</span>._sort);</span><br><span class="line">    _elements.clear();<span class="comment">//对每一个inactive状态的节点进行清理</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      elements.reversed.forEach(_unmount);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      _locked = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _unmount(<span class="built_in">Element</span> element) &#123;</span><br><span class="line">    element.visitChildren((<span class="built_in">Element</span> child) &#123;</span><br><span class="line">      _unmount(child);</span><br><span class="line">    &#125;);</span><br><span class="line">    element.unmount();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> unmount() &#123;</span><br><span class="line">    <span class="keyword">if</span> (kFlutterMemoryAllocationsEnabled) &#123;</span><br><span class="line">      MemoryAllocations.instance.dispatchObjectDisposed(object: <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Key? key = _widget?.key;</span><br><span class="line">    <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;</span><br><span class="line">      owner!._unregisterGlobalKey(key, <span class="keyword">this</span>);<span class="comment">//移除注册</span></span><br><span class="line">    &#125;</span><br><span class="line">    _widget = <span class="keyword">null</span>;</span><br><span class="line">    _dependencies = <span class="keyword">null</span>;</span><br><span class="line">    _lifecycleState = _ElementLifecycle.defunct;<span class="comment">//更新状态</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zxfcumtcs.github.io/2020/05/16/deepinto-flutter-buildowner/">深入浅出 Flutter Framework 之 BuildOwner</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概括&quot;&gt;&lt;a href=&quot;#概括&quot; class=&quot;headerlink&quot; title=&quot;概括&quot;&gt;&lt;/a&gt;概括&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;runApp，初始化构建Widget树，Widget对应Element，创建Element树；&lt;/li&gt;
&lt;li&gt;调用setSt</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Widget</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Widget/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Widget/</id>
    <published>2024-07-26T13:38:12.827Z</published>
    <updated>2024-07-26T13:38:12.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@immutable</span> <span class="comment">// 不可变</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> <span class="keyword">extends</span> <span class="title">DiagnosticableTree</span> </span>&#123; <span class="comment">//DiagnosticableTree提供调试信息</span></span><br><span class="line">  <span class="keyword">const</span> Widget(&#123; <span class="keyword">this</span>.key &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Key? key;<span class="comment">//canUpdate中判断前后的key是否相同，则使用新的Widget配置更新Element对象，否则创建新的Element对象</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@factory</span></span><br><span class="line">  <span class="built_in">Element</span> createElement();<span class="comment">//每个Widget都有对应的Element。Widget树根Element树对应</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toStringShort() &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">String</span> type = objectRuntimeType(<span class="keyword">this</span>, <span class="string">&#x27;Widget&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> key == <span class="keyword">null</span> ? type : <span class="string">&#x27;<span class="subst">$type</span>-<span class="subst">$key</span>&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> debugFillProperties(DiagnosticPropertiesBuilder properties) &#123;</span><br><span class="line">    <span class="keyword">super</span>.debugFillProperties(properties);</span><br><span class="line">    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="meta">@nonVirtual</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">operator</span> ==(<span class="built_in">Object</span> other) =&gt; <span class="keyword">super</span> == other;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="meta">@nonVirtual</span></span><br><span class="line">  <span class="built_in">int</span> <span class="keyword">get</span> hashCode =&gt; <span class="keyword">super</span>.hashCode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否可以用newWidget修改前一帧oldWidget生成的Element，而不是创建新的Element</span></span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">bool</span> canUpdate(Widget oldWidget, Widget newWidget) &#123;</span><br><span class="line">    <span class="keyword">return</span> oldWidget.runtimeType == newWidget.runtimeType</span><br><span class="line">        &amp;&amp; oldWidget.key == newWidget.key;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开发过程中，我们会使用<code>StatelessWidget</code>和<code>StatefulWidget</code>，这两个类都继承自<code>Widget</code>。而整个过程就是将Widget树转换成Element树，再转换成RenderObject树，最终通过底层skia绘制。</p><p>如果我们绘制的UI也是不可变的，那么我们可以使用<code>StatelessWidget</code>，这样在创建的时候绘制一次即可。如果UI需要根据状态发生变化，那么我们可以使用<code>StatefulWidget</code>。对于<code>StatefulWidget</code>，我们需要实现<code>State</code>类，这个类持有<code>Widget</code>和<code>Element</code>，用来管理<code>Widget</code>的状态。</p><h2 id="StatelessWidget"><a href="#StatelessWidget" class="headerlink" title="StatelessWidget"></a>StatelessWidget</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> FooWidget(&#123;<span class="keyword">super</span>.key&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下三种情况会被调用：</span></span><br><span class="line"><span class="comment">// 1. Widget第一次插入到树中时，mount时调用</span></span><br><span class="line"><span class="comment">// 2. Parent Widget修改了配置信息</span></span><br><span class="line"><span class="comment">// 3. InheritedWidget发生变化时</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const</span> Placeholder();<span class="comment">//通过不同Widget的组合来构建UI</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="StatefulWidget"><a href="#StatefulWidget" class="headerlink" title="StatefulWidget"></a>StatefulWidget</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StatefulWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> StatefulWidget(&#123; Key key &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  StatefulElement createElement() =&gt; StatefulElement(<span class="keyword">this</span>);<span class="comment">//Element持有该Widget，回调State对应的生命周期方法</span></span><br><span class="line">    </span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  State createState();<span class="comment">//开发者通过不同的生命周期方法来管理Widget的状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span>&gt; <span class="title">with</span> <span class="title">Diagnosticable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  T <span class="keyword">get</span> widget =&gt; _widget!;<span class="comment">//持有Widget对象</span></span><br><span class="line">  T? _widget;</span><br><span class="line"></span><br><span class="line">  _StateLifecycle _debugLifecycleState = _StateLifecycle.created;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> _debugTypesAreRight(Widget widget) =&gt; widget <span class="keyword">is</span> T;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 持有对应Element</span></span><br><span class="line">  BuildContext <span class="keyword">get</span> context &#123;</span><br><span class="line">    <span class="keyword">return</span> _element!;</span><br><span class="line">  &#125;</span><br><span class="line">  StatefulElement? _element;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否挂载在树上</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> mounted =&gt; _element != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生命周期初始化方法</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// canUpdate返回true则会调用此方法</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> didUpdateWidget(<span class="keyword">covariant</span> T oldWidget) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// hot reload时触发</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> reassemble() &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用这个方法会重新构建当前Widget</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> setState(VoidCallback fn) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Object?</span> result = fn() <span class="keyword">as</span> <span class="built_in">dynamic</span>;</span><br><span class="line">    _element!.markNeedsBuild();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从树中移除时回调，如果没有重新添加到树上，那么会调用dispose</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> deactivate() &#123; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> activate() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁时回调</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">if</span> (kFlutterMemoryAllocationsEnabled) &#123;</span><br><span class="line">      MemoryAllocations.instance.dispatchObjectDisposed(object: <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构建UI</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  Widget build(BuildContext context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化，依赖的InheritedWidget发生变化时会调用</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Widget的子类"><a href="#Widget的子类" class="headerlink" title="Widget的子类"></a>Widget的子类</h2><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Widget/Widget%E5%AD%90%E7%B1%BB.png"></p><p>Widget的子类：</p><ul><li>StatelessWidget、StatefulWidget：组合类Widget</li><li>ProxyWidget：提供一些附加的功能<ul><li>ParentDataWidget：布局信息</li><li>InheritedWidget：传递共享信息</li></ul></li><li>RenderObjectWidget：渲染类Widget，参与layout、paint流程，组合Widget和代理Widget都会映射到Render Widget<ul><li>LeafRenderObjectWidget</li><li>SingleChildRenderObjectWidget</li><li>MultiChildRenderObjectWidget</li></ul></li><li>RenderObjectToWidgetAdapter：Widget树的根节点</li></ul><h3 id="RenderObjectWidget"><a href="#RenderObjectWidget" class="headerlink" title="RenderObjectWidget"></a>RenderObjectWidget</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderObjectWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> RenderObjectWidget(&#123; <span class="keyword">super</span>.key &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="meta">@factory</span></span><br><span class="line">  RenderObjectElement createElement();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建Widget对应的RenderObject，mount时调用</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@factory</span></span><br><span class="line">  RenderObject createRenderObject(BuildContext context);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Widget更新后，修改对应的RenderObject</span></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> updateRenderObject(BuildContext context, <span class="keyword">covariant</span> RenderObject renderObject) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> didUnmountRenderObject(<span class="keyword">covariant</span> RenderObject renderObject) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Widget&quot;&gt;&lt;a href=&quot;#Widget&quot; class=&quot;headerlink&quot; title=&quot;Widget&quot;&gt;&lt;/a&gt;Widget&lt;/h2&gt;&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter学习资源汇总</title>
    <link href="http://airshu.github.io/wiki/Flutter/Flutter%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/"/>
    <id>http://airshu.github.io/wiki/Flutter/Flutter%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/</id>
    <published>2024-07-26T13:38:12.826Z</published>
    <updated>2024-07-26T13:38:12.826Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>[基本使用]</p></li><li><p>[源码分析]</p><ul><li><a href>Widget</a></li><li><a href>Element</a></li><li><a href>RenderObject</a></li><li><a href>BuildOwner</a></li><li><a href>PipelineOwner</a></li><li><a href>RepaintBoundary</a></li><li><a href>Build过程</a></li><li><a href>Layout过程</a></li><li><a href>Paint过程</a></li><li><a href>Composition过程</a></li><li>[动画机制]</li><li>[事件机制]</li><li>[布局模型]</li><li>[路由机制]</li></ul></li><li><p><a href="https://github.com/flutter/flutter/wiki/">官方文档库</a></p></li><li><p><a href="http://gityuan.com/2019/06/15/flutter_ui_draw/">Flutter渲染机制—UI线程</a></p></li><li><p><a href="http://gityuan.com/2019/06/16/flutter_gpu_draw/">Flutter渲染机制—GPU线程</a></p></li><li><p><a href="http://gityuan.com/2019/06/22/flutter_booting/">深入理解Flutter引擎启动</a></p></li><li><p><a href="http://gityuan.com/2019/06/23/dart-vm/">深入理解Dart虚拟机启动</a></p></li><li><p><a href="http://gityuan.com/2019/06/29/flutter_run_app/">深入理解Flutter应用启动</a></p></li><li><p><a href="http://gityuan.com/2019/07/06/flutter_set_state/">深入理解setState更新机制</a></p></li><li><p><a href="http://gityuan.com/2019/07/13/flutter_animator/">深入理解Flutter动画原理</a></p></li><li><p><a href="http://gityuan.com/2019/07/20/flutter_message_loop/">深入理解Flutter消息机制</a></p></li><li><p><a href></a></p></li><li><p><a href></a></p></li><li><p><a href></a></p></li><li><p><a href></a></p></li><li><p><a href></a></p></li><li><p><a href></a></p></li><li><p><a href></a></p></li><li><p><a href="http://w4lle.com/2021/01/15/flutter-ui-layout/">Flutter UI 渲染浅析（五）Layout</a></p></li><li><p><a href="http://w4lle.com/2021/02/01/flutter-ui-paint/">Flutter UI 渲染浅析（六）Paint</a></p></li><li><p><a href="http://w4lle.com/2021/02/02/flutter-ui-composite/">Flutter UI 渲染浅析（七）Composite</a></p></li><li><p><a href></a></p></li><li><p><a href></a></p></li><li><p><a href></a></p></li><li><p><a href="https://fucknmb.com/2019/10/20/%E8%8E%B7%E5%8F%96%E5%B9%B6%E8%BF%98%E5%8E%9FFlutter-Engine-Crash%E5%A0%86%E6%A0%88/">获取并还原Flutter-Engine-Crash堆栈</a></p></li><li><p><a href="http://gityuan.com/">http://gityuan.com</a></p></li><li><p><a href="http://w4lle.com/">http://w4lle.com</a></p></li><li><p><a href="https://fucknmb.com/">https://fucknmb.com</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;[基本使用]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;[源码分析]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&gt;Widget&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;Element&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;RenderObject&lt;/a&gt;&lt;/l</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>DevTools</title>
    <link href="http://airshu.github.io/wiki/Flutter/DevTools/"/>
    <id>http://airshu.github.io/wiki/Flutter/DevTools/</id>
    <published>2024-07-26T13:38:12.825Z</published>
    <updated>2024-07-26T13:38:12.825Z</updated>
    
    <content type="html"><![CDATA[<p>开发者工具介绍</p><ul><li>Flutter Inspector：检查 Flutter 应用程序的 UI 组件布局和状态</li><li>Performance View：在 Flutter 应用程序中诊断 UI 性能过低的问题</li><li>CPU Profiler View：Flutter 和 Dart 应用的 CPU 性能检测</li><li>Network View：为 Flutter 应用进行网络性能检测</li><li>为 Flutter 或 Dart 应用进行源码级的调试</li><li>Memory View：在 Flutter 或 Dart 命令行应用中测试内存问题</li><li>Logging View：查看正在运行的 Flutter 或 Dart 的命令行应用程序相关的常规日志和诊断信息</li><li>App Size Tool：分析代码和应用的大小</li></ul><h2 id="Flutter-inspector-工具"><a href="#Flutter-inspector-工具" class="headerlink" title="Flutter inspector 工具"></a>Flutter inspector 工具</h2><p><img src="/wiki/Flutter/DevTools/inspector_screenshot.webp"></p><p>查看 widget 树，诊断布局问题</p><h3 id="Select-Widget-Mode"><a href="#Select-Widget-Mode" class="headerlink" title="Select Widget Mode"></a>Select Widget Mode</h3><p>启动此按钮，可在应用中选中某个Widget进行查看。通过此工具可以快速定位UI的详细信息</p><h3 id="Slow-Animations"><a href="#Slow-Animations" class="headerlink" title="Slow Animations"></a>Slow Animations</h3><p>以五分之一的速度运行动画以便对它们进行优化</p><h3 id="Show-Guidelines-显示引导线"><a href="#Show-Guidelines-显示引导线" class="headerlink" title="Show Guidelines 显示引导线"></a>Show Guidelines 显示引导线</h3><p>覆盖一层引导线以帮助调整布局问题</p><h3 id="Show-Baselines-显示基线"><a href="#Show-Baselines-显示基线" class="headerlink" title="Show Baselines 显示基线"></a>Show Baselines 显示基线</h3><p>针对文字对齐展示文字的基线。对检查文字是否对齐有帮助。</p><h3 id="Highlight-Repaints-高亮重绘区域"><a href="#Highlight-Repaints-高亮重绘区域" class="headerlink" title="Highlight Repaints 高亮重绘区域"></a>Highlight Repaints 高亮重绘区域</h3><p>该选项会为所有的 RenderBox 绘制一层边框，在它们重新绘制时改变颜色。重新绘制时在图层上依次显示不同的颜色。例如，一个小动画可能会导致整个页面一直在重绘。将动画使用RepaintBoundary widget嵌套，可以保证动画只会导致其本身重绘。</p><h3 id="Highlight-Oversized-Images-高亮尺寸过大的图片"><a href="#Highlight-Oversized-Images-高亮尺寸过大的图片" class="headerlink" title="Highlight Oversized Images 高亮尺寸过大的图片"></a>Highlight Oversized Images 高亮尺寸过大的图片</h3><p>在运行的应用程序中高亮并反转消耗过多内存的图像。</p><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><ul><li>对于loading、toast这种动画UI，使用RepaintBoundary包裹</li><li>对于大尺寸的图片，使用cacheHeight、cacheWidth等属性进行优化</li></ul><h2 id="性能视图-Performance-view"><a href="#性能视图-Performance-view" class="headerlink" title="性能视图 (Performance view)"></a>性能视图 (Performance view)</h2><ul><li>Flutter 帧图表（仅 Flutter 应用）</li><li>帧分析标签页（仅 Flutter 应用）</li><li>光栅统计标签页（仅 Flutter 应用）</li><li>时间轴事件跟踪查看器（所有原生 Dart 应用）</li><li>高级调试工具（仅 Flutter 应用）</li></ul><h3 id="Flutter-帧图表"><a href="#Flutter-帧图表" class="headerlink" title="Flutter 帧图表"></a>Flutter 帧图表</h3><h3 id="光栅统计标签页-Raster-Stats"><a href="#光栅统计标签页-Raster-Stats" class="headerlink" title="光栅统计标签页 Raster Stats"></a>光栅统计标签页 Raster Stats</h3><p>如果帧的卡顿来自光栅线程，这个工具也许能够帮助你诊断性能缓慢的原因。生成光栅统计的步骤：</p><ol><li>在应用程序中导航到你看见光栅线程卡顿的画面。</li><li>点击 Take Snapshot 生成快照。</li><li>查看不同图层和它们各自的渲染时间。</li></ol><p><img src="/wiki/Flutter/DevTools/raster-stats-tab.webp" alt="Raster Stats Tab"></p><h3 id="时间线事件表-Timeline-Events"><a href="#时间线事件表-Timeline-Events" class="headerlink" title="时间线事件表 Timeline Events"></a>时间线事件表 Timeline Events</h3><p>时间线事件图表显示了应用程序的所有事件追踪。 Flutter 底层框架在构建帧、绘制场景和跟踪其他活动（如 HTTP 请求时间和垃圾回收）时，会发出时间线事件。这些事件会在时间线中显示出来。你也可以使用 dart:developer Timeline 和 TimelineTask API 发送你自己的时间线事件</p><p><img src="/wiki/Flutter/DevTools/timeline-events-tab.webp"></p><h4 id="技巧-1"><a href="#技巧-1" class="headerlink" title="技巧"></a>技巧</h4><ul><li>时间线添加更多的信息</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  debugProfileBuildsEnabled = <span class="keyword">true</span>;<span class="comment">//timeline中会显示具体的widget构建时间</span></span><br><span class="line">  debugProfilePaintsEnabled = <span class="keyword">true</span>;<span class="comment">//timeline中会显示具体的绘制时间</span></span><br><span class="line">  runApp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>自定义信息</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Timeline.startSync(<span class="string">&quot;Doing Something&quot;</span>);</span><br><span class="line">doSomething();</span><br><span class="line">Timeline.finishSync();</span><br></pre></td></tr></table></figure><h3 id="增强的追踪选项-Enhance-Tracing"><a href="#增强的追踪选项-Enhance-Tracing" class="headerlink" title="增强的追踪选项 Enhance Tracing"></a>增强的追踪选项 Enhance Tracing</h3><p><img src="/wiki/Flutter/DevTools/enhanced-tracing.webp"></p><p>你可以重复操作你想要追踪的行为来查看新的时间线事件，操作后可以在时间线中选择一个构建帧进行查看。</p><h4 id="追踪-widget-的构建-Track-Widget-Builds"><a href="#追踪-widget-的构建-Track-Widget-Builds" class="headerlink" title="追踪 widget 的构建 Track Widget Builds"></a>追踪 widget 的构建 Track Widget Builds</h4><p>想要在时间线中查看 build() 方法的事件，启用 Track Widget Builds 选项，时间线中将出现 widget 对应名称的事件。</p><p><img src="/wiki/Flutter/DevTools/track-widget-builds.webp"></p><p>通过该视图，分析出哪些widget的build构建的次数异常，进而进行优化</p><h4 id="追踪布局-Track-Layouts"><a href="#追踪布局-Track-Layouts" class="headerlink" title="追踪布局 Track Layouts"></a>追踪布局 Track Layouts</h4><p>想要在时间线中查看 RenderObject 布局构建的事件，启用 Track Layouts 选项：</p><p><img src="/wiki/Flutter/DevTools/track-layouts.webp"></p><h4 id="追踪绘制-Track-Paints"><a href="#追踪绘制-Track-Paints" class="headerlink" title="追踪绘制 Track Paints"></a>追踪绘制 Track Paints</h4><p>想要在时间线中查看 RenderObject 的绘制事件，启用 Track Paints 选项：</p><p><img src="/wiki/Flutter/DevTools/track-paints.webp"></p><h3 id="更多调试选项-More-debugging-options"><a href="#更多调试选项-More-debugging-options" class="headerlink" title="更多调试选项 More debugging options"></a>更多调试选项 More debugging options</h3><p>想要诊断渲染图层相关的问题，请先关闭渲染层。下述的选项将会默认启动。</p><p>想要查看你的应用的性能影响，请尝试以相同的操作重现性能问题。在渲染层关闭的情况下，于构建帧图表里选择一个新的构建帧，查看它的时间线细节。如果光栅线程的时间消耗有显著降低，那么你禁用的效果的滥用可能是导致卡顿的主要原因。</p><h4 id="渲染裁剪的图层-Render-Clip-layers"><a href="#渲染裁剪的图层-Render-Clip-layers" class="headerlink" title="渲染裁剪的图层 Render Clip layers"></a>渲染裁剪的图层 Render Clip layers</h4><p>禁用该选项来检查已使用的裁剪图层是否影响了性能。如果禁用后性能有显著提升，请尝试减少你的应用中裁剪效果的使用。</p><h4 id="渲染透明度图层-Render-Opacity-layers"><a href="#渲染透明度图层-Render-Opacity-layers" class="headerlink" title="渲染透明度图层 Render Opacity layers"></a>渲染透明度图层 Render Opacity layers</h4><p>禁用该选项来检查已使用的透明度图层是否影响了性能。如果禁用后性能有显著提升，请尝试减少你的应用中透明度效果的使用。</p><h4 id="渲染物理形状图层-Render-Physical-Shape-layers"><a href="#渲染物理形状图层-Render-Physical-Shape-layers" class="headerlink" title="渲染物理形状图层 Render Physical Shape layers"></a>渲染物理形状图层 Render Physical Shape layers</h4><p>禁用该选项来检查已使用的物理形状图层是否影响了性能，例如阴影和背景特效。如果禁用后性能有显著提升，请尝试减少你的应用中物理效果的使用。</p><p><img src="/wiki/Flutter/DevTools/more-debugging-options.webp"></p><h2 id="CPU探测视图-CPU-profiler"><a href="#CPU探测视图-CPU-profiler" class="headerlink" title="CPU探测视图 CPU profiler"></a>CPU探测视图 CPU profiler</h2><p>单击“Record”开始记录 CPU 剖析。 当完成录制后，单击“Stop”。  此时，CPU 分析数据将从 VM 中提取并显示在分析器视图中（Call tree, Bottom up, Method table, and Flame chart）</p><h3 id="Bottom-Up"><a href="#Bottom-Up" class="headerlink" title="Bottom Up"></a>Bottom Up</h3><p>此表提供了 CPU 配置文件的自下而上表示。 这意味着自下而上表中的每个顶级方法或根实际上是一个或多个 CPU 样本的调用堆栈中的顶级方法。 换句话说，自下而上的表中的每个顶级方法都是自上而下的表（调用树）的叶节点。 在此表中，可以展开方法以显示其调用者。</p><h4 id="Total-Time"><a href="#Total-Time" class="headerlink" title="Total Time"></a>Total Time</h4><h4 id="Self-Time"><a href="#Self-Time" class="headerlink" title="Self Time"></a>Self Time</h4><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><h3 id="Call-tree-调用树"><a href="#Call-tree-调用树" class="headerlink" title="Call tree 调用树"></a>Call tree 调用树</h3><p>自上而下的调用展示</p><h3 id="CPU-Flame-Chart-CPU火焰图"><a href="#CPU-Flame-Chart-CPU火焰图" class="headerlink" title="CPU Flame Chart CPU火焰图"></a>CPU Flame Chart CPU火焰图</h3><p><img src="/wiki/Flutter/DevTools/cpu-flame-chart.webp"></p><p>火焰图是一种可视化工具，用于显示方法调用的时间分布。 矩形的宽度表示方法的执行时间。 矩形的颜色表示方法的深度，即方法调用堆栈的深度。上面调用下面的方法。</p><h3 id="CPU-sampling-rate"><a href="#CPU-sampling-rate" class="headerlink" title="CPU sampling rate"></a>CPU sampling rate</h3><h2 id="内存视图-Memory-view"><a href="#内存视图-Memory-view" class="headerlink" title="内存视图 Memory view"></a>内存视图 Memory view</h2><p><img src="/wiki/Flutter/DevTools/memory_chart_anatomy.webp"></p><h3 id="Root-object-retaining-path-and-reachability"><a href="#Root-object-retaining-path-and-reachability" class="headerlink" title="Root object, retaining path, and reachability"></a>Root object, retaining path, and reachability</h3><h3 id="Shallow-size-vs-retained-size"><a href="#Shallow-size-vs-retained-size" class="headerlink" title="Shallow size vs retained size"></a>Shallow size vs retained size</h3><h3 id="Dart中的内存泄漏"><a href="#Dart中的内存泄漏" class="headerlink" title="Dart中的内存泄漏"></a>Dart中的内存泄漏</h3><h2 id="技巧-2"><a href="#技巧-2" class="headerlink" title="技巧"></a>技巧</h2><ul><li>小心闭包函数的使用</li><li>小心context的传递。如果闭包的生命周期在widget内，则可以传递</li><li>注意widget和state，state中不要引用widget中的context，widget是短生命的，而state是长生命的</li></ul><p>Flutter Framework的每一层都提供了函数来输出当前状态或事件到控制台</p><ul><li><p>debugDumpApp：输出整个应用程序的状态</p></li><li><p>debugDumpRenderTree：输出渲染树，用于分析布局问题</p></li><li><p>debugDumpLayerTree：输出图层树，用于分析compositing问题</p></li><li><p>debugPaintSize：设置为true时，每个box外都显示一个亮蓝色边界</p></li><li><p>debugPaintBaselineEnabled： 文本的基线会高亮</p></li><li><p>debugPaintPointersEnabled： 被点击的对象以蓝绿色显示，用于检查hit test是否正确</p></li><li><p>debugPaintLayerBordersEnabled：橙色显示图层边界，用于检查是否需要使用RepaintBoundary</p></li><li><p>debugPaintLayerBordersEnabled - 查看 layer 界线</p></li><li><p>debugRepaintRainbowEnabled：每次重绘时，都会有不同的颜色，用于检查重绘区域</p></li><li><p>debugProfileBuildsEnabled - 在观测台里显示构建树</p></li><li><p>debugProfilePaintsEnabled</p></li><li><p>debugPrintBuildScope：打印buildScope时的信息</p></li><li><p>debugPrintScheduleBuildForStacks：打印调度构建堆栈</p></li><li><p>debugPrintGlobalKeyedWidgetLifecycle：GlobalKey的生命周期信息</p></li><li><p>debugPrintRebuildDirtyWidgets：打印重建的widget</p><ul><li>结合 debugPrintScheduleBuildForStacks，可以观察 widget 的 dirty&#x2F;clean 生命周期</li><li>结合 debugProfileBuildsEnabled，可以在 DevTools Timeline 中观察到详细事件信息</li></ul></li><li><p>debugPrintMarkNeedsLayoutStacks：打印markNeedsLayout方法调用时的堆栈信息</p></li><li><p>debugPrintMarkNeedsPaintStacks：打印markNeedsPaint方法调用时的堆栈信息</p></li></ul><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/7260499321983893565">Flutter 调试工具篇 | 壹 - 使用 Flutter Inspector 分析界面</a></li><li><a href="https://flutter.cn/docs/tools/devtools/performance">性能视图</a></li><li><a href="https://flutter.cn/docs/tools/devtools/overview">https://flutter.cn/docs/tools/devtools/overview</a></li><li><a href="https://blog.csdn.net/qq_41818873/article/details/130618157">Flutter性能分析工具使用</a></li><li><a href="https://medium.com/@fluttergems/mastering-dart-flutter-devtools-cpu-profiler-view-part-6-of-8-31e24eae6bf8">Mastering Dart &amp; Flutter DevTools — Part 6: CPU Profiler View</a></li><li><a href="https://medium.com/@fluttergems/mastering-dart-flutter-devtools-part-7-memory-view-e7f5aaf07e15">Mastering Dart &amp; Flutter DevTools — Part 7: Memory View</a></li><li><a href="https://medium.com/@fluttergems/mastering-dart-flutter-devtools-performance-view-part-8-of-8-4ae762f91230">Mastering Dart &amp; Flutter DevTools — Part 8: Performance View</a></li><li><a href="https://www.sunmoonblog.com/2020/01/10/flutter-performance-tools/">Flutter Performance 分析工具简介</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开发者工具介绍&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Flutter Inspector：检查 Flutter 应用程序的 UI 组件布局和状态&lt;/li&gt;
&lt;li&gt;Performance View：在 Flutter 应用程序中诊断 UI 性能过低的问题&lt;/li&gt;
&lt;li&gt;CPU Pr</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Sliver布局模型</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Sliver%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Sliver%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-07-25T15:39:46.453Z</published>
    <updated>2024-07-25T15:40:01.140Z</updated>
    
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Box布局模型</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Box%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Box%E5%B8%83%E5%B1%80%E6%A8%A1%E5%9E%8B/</id>
    <published>2024-07-25T15:39:35.199Z</published>
    <updated>2024-07-25T15:40:13.237Z</updated>
    
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Composition过程</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Composition%E8%BF%87%E7%A8%8B/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Composition%E8%BF%87%E7%A8%8B/</id>
    <published>2024-07-25T15:08:20.266Z</published>
    <updated>2024-07-27T03:45:43.967Z</updated>
    
    <content type="html"><![CDATA[<p>经过Build、Layout、Paint后，Render Tree变成Layer Tree，那么Layer Tree是如何合成，以变成最终的渲染数据呢？这就是Composition过程。</p><h2 id="Mark阶段"><a href="#Mark阶段" class="headerlink" title="Mark阶段"></a>Mark阶段</h2><p>Framework使用_neesaAddToScene字段标识当前图层是否需要进行合成，通常当一个Layer节点有子节点的变化（adoptChild、dropChild）或者Layer节点本身有变化时，需要将该标识设置为true，表示当前图层发生改变，需要重新合成。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">set</span> alpha(<span class="built_in">int?</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value != _alpha) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="number">255</span> || _alpha == <span class="number">255</span>) &#123;</span><br><span class="line">        engineLayer = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      _alpha = value;</span><br><span class="line">      markNeedsAddToScene();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> elevation(<span class="built_in">double?</span> value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value != _elevation) &#123;</span><br><span class="line">      _elevation = value;</span><br><span class="line">      markNeedsAddToScene();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> markNeedsAddToScene() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_needsAddToScene) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _needsAddToScene = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Flush阶段"><a href="#Flush阶段" class="headerlink" title="Flush阶段"></a>Flush阶段</h2><p>合成的Flush阶段是从renderView.compositeFrame方法开始</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderView</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> compositeFrame() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> ui.SceneBuilder builder = ui.SceneBuilder();</span><br><span class="line">      <span class="keyword">final</span> ui.Scene scene = layer!.buildScene(builder);<span class="comment">//Layer Tree的最终产物</span></span><br><span class="line">      <span class="keyword">if</span> (automaticSystemUiAdjustment) &#123;</span><br><span class="line">        _updateSystemChrome();</span><br><span class="line">      &#125;</span><br><span class="line">      _view.render(scene);<span class="comment">//请求渲染</span></span><br><span class="line">      scene.dispose();<span class="comment">//渲染完成，释放资源</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContainerLayer</span> </span>&#123;</span><br><span class="line">  ui.Scene buildScene(ui.SceneBuilder builder) &#123;</span><br><span class="line">    updateSubtreeNeedsAddToScene();<span class="comment">//1、计算哪些Layer需要合成</span></span><br><span class="line">    addToScene(builder);<span class="comment">//2、将Layer Tree映射到Engine</span></span><br><span class="line">    <span class="keyword">if</span> (subtreeHasCompositionCallbacks) &#123;</span><br><span class="line">      _fireCompositionCallbacks(includeChildren: <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _needsAddToScene = <span class="keyword">false</span>;<span class="comment">//合成完成</span></span><br><span class="line">    <span class="keyword">final</span> ui.Scene scene = builder.build();<span class="comment">//真正的合成逻辑</span></span><br><span class="line">    <span class="keyword">return</span> scene;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> updateSubtreeNeedsAddToScene() &#123;</span><br><span class="line">    <span class="keyword">super</span>.updateSubtreeNeedsAddToScene();<span class="comment">//先执行父类逻辑，更新自身标记</span></span><br><span class="line">    Layer? child = firstChild;</span><br><span class="line">    <span class="keyword">while</span> (child != <span class="keyword">null</span>) &#123;<span class="comment">//遍历每个子节点，完成更新</span></span><br><span class="line">      child.updateSubtreeNeedsAddToScene();</span><br><span class="line">      _needsAddToScene = _needsAddToScene || child._needsAddToScene;</span><br><span class="line">      child = child.nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> addToScene(ui.SceneBuilder builder) &#123;</span><br><span class="line">    addChildrenToScene(builder);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> addChildrenToScene(ui.SceneBuilder builder) &#123;</span><br><span class="line">    Layer? child = firstChild;</span><br><span class="line">    <span class="keyword">while</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      child._addToSceneWithRetainedRendering(builder);</span><br><span class="line">      child = child.nextSibling;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> _addToSceneWithRetainedRendering(ui.SceneBuilder builder) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_needsAddToScene &amp;&amp; _engineLayer != <span class="keyword">null</span>) &#123;</span><br><span class="line">      builder.addRetained(_engineLayer!);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    addToScene(builder);<span class="comment">//上屏操作，不同子类不同实现</span></span><br><span class="line">    _needsAddToScene = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;经过Build、Layout、Paint后，Render Tree变成Layer Tree，那么Layer Tree是如何合成，以变成最终的渲染数据呢？这就是Composition过程。&lt;/p&gt;
&lt;h2 id=&quot;Mark阶段&quot;&gt;&lt;a href=&quot;#Mark阶段&quot; class</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>首帧渲染</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E9%A6%96%E5%B8%A7%E6%B8%B2%E6%9F%93/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E9%A6%96%E5%B8%A7%E6%B8%B2%E6%9F%93/</id>
    <published>2024-07-25T13:33:15.269Z</published>
    <updated>2024-07-25T13:33:15.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关键类"><a href="#关键类" class="headerlink" title="关键类"></a>关键类</h2><h3 id="Widget关键类"><a href="#Widget关键类" class="headerlink" title="Widget关键类"></a>Widget关键类</h3><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E9%A6%96%E5%B8%A7%E6%B8%B2%E6%9F%93/Widget%E5%85%B3%E9%94%AE%E7%B1%BB.png"></p><p>Widget是对Element的配置或描述。Widget的子类主要有3类：</p><ul><li><p>RenderObjectWidget的子类，可以进行Layout、Paint等逻辑</p><ul><li>SingleChildRenderObjectWidget（单子节点容器）</li><li>LeafRenderObjectWidget（叶子节点）</li><li>MultiChildRenderObjectWidget（多叶子节点容器）</li></ul></li><li><p>StatelessWidget和StatefulWidget，自身不具备绘制能力，用来组织和配置RenderObjectWidget类型的Widget</p></li><li><p>ProxyWidget，具体又分为ParentDataWidget和InheritedWidget，为其子节点提供额外的数据</p></li></ul><h3 id="Element关键类"><a href="#Element关键类" class="headerlink" title="Element关键类"></a>Element关键类</h3><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E9%A6%96%E5%B8%A7%E6%B8%B2%E6%9F%93/Element%E5%85%B3%E9%94%AE%E7%B1%BB.png"></p><p>每个Element都有一个对应的Widget，其主要工作都处于渲染流水线的构建阶段（build）。</p><h3 id="RenderObject关键类"><a href="#RenderObject关键类" class="headerlink" title="RenderObject关键类"></a>RenderObject关键类</h3><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E9%A6%96%E5%B8%A7%E6%B8%B2%E6%9F%93/RenderObject%E5%85%B3%E9%94%AE%E7%B1%BB.png"></p><p>RenderView是整个Render Tree的根节点，负责布局（layout）、绘制（paint）。</p><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/%E9%A6%96%E5%B8%A7%E6%B8%B2%E6%9F%93/%E4%B8%89%E6%A3%B5%E6%A0%91%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F.png"></p><h2 id="根节点构建流程"><a href="#根节点构建流程" class="headerlink" title="根节点构建流程"></a>根节点构建流程</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> runApp(Widget app) &#123;</span><br><span class="line">  WidgetsFlutterBinding.ensureInitialized()</span><br><span class="line">    ..scheduleAttachRootWidget(app)</span><br><span class="line">    ..scheduleWarmUpFrame();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> scheduleAttachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">    Timer.run(() &#123;</span><br><span class="line">      attachRootWidget(rootWidget);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> attachRootWidget(Widget rootWidget) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span> isBootstrapFrame = renderViewElement == <span class="keyword">null</span>;</span><br><span class="line">    _readyToProduceFrames = <span class="keyword">true</span>;</span><br><span class="line">    _renderViewElement = RenderObjectToWidgetAdapter&lt;RenderBox&gt;(</span><br><span class="line">      container: renderView,</span><br><span class="line">      debugShortDescription: <span class="string">&#x27;[root]&#x27;</span>,</span><br><span class="line">      child: rootWidget,</span><br><span class="line">    ).attachToRenderTree(buildOwner!, renderViewElement <span class="keyword">as</span> RenderObjectToWidgetElement&lt;RenderBox&gt;?);</span><br><span class="line">    <span class="keyword">if</span> (isBootstrapFrame) &#123;</span><br><span class="line">      SchedulerBinding.instance.ensureVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  RenderObjectToWidgetElement&lt;T&gt; attachToRenderTree(BuildOwner owner, [ RenderObjectToWidgetElement&lt;T&gt;? element ]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (element == <span class="keyword">null</span>) &#123;<span class="comment">//首帧构建</span></span><br><span class="line">      owner.lockState(() &#123;</span><br><span class="line">        element = createElement();<span class="comment">//创建Widget对应的Element</span></span><br><span class="line">        <span class="keyword">assert</span>(element != <span class="keyword">null</span>);</span><br><span class="line">        element!.assignOwner(owner);<span class="comment">//绑定BuildOwner</span></span><br><span class="line">      &#125;);</span><br><span class="line">      owner.buildScope(element!, () &#123;<span class="comment">//开始子节点的解析与挂载</span></span><br><span class="line">        element!.mount(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element._newWidget = <span class="keyword">this</span>;</span><br><span class="line">      element.markNeedsBuild();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element!;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//binding.dart</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element?</span> parent, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(parent == <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    _rebuild();<span class="comment">//开始构建</span></span><br><span class="line">    <span class="keyword">assert</span>(_child != <span class="keyword">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _rebuild() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      _child = updateChild(_child, (widget <span class="keyword">as</span> RenderObjectToWidgetAdapter&lt;T&gt;).child, _rootChildSlot);<span class="comment">//build整个tree</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (exception, stack) &#123;</span><br><span class="line">      <span class="keyword">final</span> FlutterErrorDetails details = FlutterErrorDetails(</span><br><span class="line">        exception: exception,</span><br><span class="line">        stack: stack,</span><br><span class="line">        <span class="keyword">library</span>: <span class="string">&#x27;widgets library&#x27;</span>,</span><br><span class="line">        context: ErrorDescription(<span class="string">&#x27;attaching to the render tree&#x27;</span>),</span><br><span class="line">      );</span><br><span class="line">      FlutterError.reportError(details);</span><br><span class="line">      <span class="keyword">final</span> Widget error = ErrorWidget.builder(details);</span><br><span class="line">      _child = updateChild(<span class="keyword">null</span>, error, _rootChildSlot);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//framework.dart</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> mount(<span class="built_in">Element?</span> parent, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">    _renderObject = (widget <span class="keyword">as</span> RenderObjectWidget).createRenderObject(<span class="keyword">this</span>);<span class="comment">//创建Widget对应的RenderObject</span></span><br><span class="line">    attachRenderObject(newSlot);</span><br><span class="line">    <span class="keyword">super</span>.performRebuild(); <span class="comment">// clears the &quot;dirty&quot; flag</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">Element?</span> updateChild(<span class="built_in">Element?</span> child, Widget? newWidget, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newWidget == <span class="keyword">null</span>) &#123;<span class="comment">//如果新的Widget为空，则销毁child</span></span><br><span class="line">      <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">        deactivateChild(child);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Element</span> newChild;</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="built_in">bool</span> hasSameSuperclass = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (hasSameSuperclass &amp;&amp; child.widget == newWidget) &#123;</span><br><span class="line">        <span class="keyword">if</span> (child.slot != newSlot) &#123;</span><br><span class="line">          updateSlotForChild(child, newSlot);</span><br><span class="line">        &#125;</span><br><span class="line">        newChild = child;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasSameSuperclass &amp;&amp; Widget.canUpdate(child.widget, newWidget)) &#123;<span class="comment">//检查新旧Widget是否可以更新，默认比较类型和key</span></span><br><span class="line">        <span class="keyword">if</span> (child.slot != newSlot) &#123;</span><br><span class="line">          updateSlotForChild(child, newSlot);</span><br><span class="line">        &#125;</span><br><span class="line">        child.update(newWidget);</span><br><span class="line">        newChild = child;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        deactivateChild(child);</span><br><span class="line">        newChild = inflateWidget(newWidget, newSlot);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newChild = inflateWidget(newWidget, newSlot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newChild;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">Element</span> inflateWidget(Widget newWidget, <span class="built_in">Object?</span> newSlot) &#123;</span><br><span class="line">    <span class="keyword">final</span> Key? key = newWidget.key;</span><br><span class="line">    <span class="keyword">if</span> (key <span class="keyword">is</span> GlobalKey) &#123;<span class="comment">//globalkey的处理</span></span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Element?</span> newChild = _retakeInactiveElement(key, newWidget);</span><br><span class="line">      <span class="keyword">if</span> (newChild != <span class="keyword">null</span>) &#123;</span><br><span class="line">        newChild._activateWithParent(<span class="keyword">this</span>, newSlot);</span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">Element?</span> updatedChild = updateChild(newChild, newWidget, newSlot);</span><br><span class="line">        <span class="keyword">return</span> updatedChild!;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">Element</span> newChild = newWidget.createElement();<span class="comment">//创建新的Element</span></span><br><span class="line">    newChild.mount(<span class="keyword">this</span>, newSlot);</span><br><span class="line">    <span class="keyword">return</span> newChild;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关键类&quot;&gt;&lt;a href=&quot;#关键类&quot; class=&quot;headerlink&quot; title=&quot;关键类&quot;&gt;&lt;/a&gt;关键类&lt;/h2&gt;&lt;h3 id=&quot;Widget关键类&quot;&gt;&lt;a href=&quot;#Widget关键类&quot; class=&quot;headerlink&quot; title=&quot;Wid</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Android引擎启动流程</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%E5%BC%95%E6%93%8E%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%E5%BC%95%E6%93%8E%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2024-07-25T13:33:15.268Z</published>
    <updated>2024-07-25T13:33:15.269Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Embedder启动流程<ul><li>FlutterEngine初始化</li><li>FlutterView初始化</li><li>Framework启动</li><li>Engine入口</li></ul></li><li>Engine启动流程<ul><li>Engine关键类</li><li>JNI接口绑定</li><li>Settings解析</li></ul></li><li>Surface启动流程<ul><li>Flutter绘制体系介绍</li><li>PlatformViewAndroid初始化</li><li>Surface初始化</li></ul></li><li>Dart Runtime启动流程<ul><li>Dart Runtime介绍</li><li>Dart VM创建流程</li><li>Isolate启动流程</li></ul></li><li>Framework启动流程<ul><li>Binding启动流程</li></ul></li></ul><p>Flutter是如何在Android的基础上启动的呢？查看Flutter项目的Android端代码，会发现Activity是继承FlutterActivity，Application是继承FlutterApplication的，那么他们是如何链接Native和Flutter的呢？</p><ul><li>FlutterApplication： onCreate过程中进行初始化配置，加载libflutter.so，注册JNI方法</li><li>FlutterActivity：onCreate过程中进行创建FlutterView、Dart虚拟机、Enigine、Isolate、taskRunner等对象，最终执行到Dart的main方法</li></ul><h2 id="FlutterApplication启动流程"><a href="#FlutterApplication启动流程" class="headerlink" title="FlutterApplication启动流程"></a>FlutterApplication启动流程</h2><h2 id="FlutterActivity启动流程"><a href="#FlutterActivity启动流程" class="headerlink" title="FlutterActivity启动流程"></a>FlutterActivity启动流程</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://gityuan.com/2019/06/22/flutter_booting/">深入理解Flutter引擎启动</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Embedder启动流程&lt;ul&gt;
&lt;li&gt;FlutterEngine初始化&lt;/li&gt;
&lt;li&gt;FlutterView初始化&lt;/li&gt;
&lt;li&gt;Framework启动&lt;/li&gt;
&lt;li&gt;Engine入口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Engine启动流</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>RenderObject</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RenderObject/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RenderObject/</id>
    <published>2024-07-25T13:33:15.218Z</published>
    <updated>2024-07-25T13:33:15.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>RenderObject表示渲染树的一个对象，其职责包括：Layout、Paint、Hit Testing。</p><p><strong>作用：</strong></p><ul><li>布局，从RenderBox开始，对RenderObject Tree从上至下进行布局。</li><li>绘制，通过Canvas对象，RenderObject可以绘制自身以及其在RenderObject Tree中的子节点。</li><li>点击测试，RenderObject从上至下传递点击事件，并通过其位置和behavior来控制是否响应点击事件。</li></ul><p>插槽（slot）：所谓插槽，就是预留一个接口或位置，由其他对象来接入或占据。</p><p>RenderObject拥有一个parent和parentData插槽（slot）：</p><ul><li>parentData：负责存储父节点所需要的子节点的布局信息。该成员只能通过setupParentData方法赋值，RenderObject的子类通过重写该方法将ParentData的子类赋值给parentData，已扩展ParentData功能。</li><li>layout()：布局阶段，父节点会调用子节点的该方法。</li><li>markNeedsLayout()：标记下一个frame重新layout。</li><li>paint()：绘制</li><li>layer：</li><li>isRepaintBoundary：绘制边界点，单独的一层渲染，提升性能</li><li>needsCompositing：</li></ul><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RenderObject/RenderObjectClassDiagram.png"></p><h3 id="RenderObject子类"><a href="#RenderObject子类" class="headerlink" title="RenderObject子类"></a>RenderObject子类</h3><ul><li>RenderView：Render Object Tree的根节点</li><li>RenderBox：采用2D笛卡尔坐标系中的渲染对象。它实现了一个内在的尺寸调整协议，它允许您在没有完全铺设的情况下测量一个子级，以这样的方式，如果该子级改变了尺寸，父级将再次布置（考虑到子级的新尺寸）。若对坐标系统没有限制，可直接继承它来实现自定义RenderObject。size属性用来保存控件的高宽。其layout是通过在组件树中从上往下传递BoxConstraints对象实现的。<ul><li>performResize()：测量</li><li>performLayout()：布局</li></ul></li><li>RenderView：渲染对象的根。它有单独的子级，它必须是一个RenderBox。因此，如果你想在渲染树中有一个自定义的RenderObject子类，你有两种选择：你可能需要替换RenderView本身，或者你需要一个RenderBox作为它的子类。</li><li>RenderAbstractViewport：内部较大的渲染对象的界面。其渲染对象（如RenderViewport）显示其内容的一部分，可以通过ViewportOffset进行控制。</li><li>RenderSliver：在视图中实现滚动效果的渲染对象的基类。RenderViewport有一组子Sliver，每个Sliver依次排列，覆盖过程中的视图。而RenderSliver则控制着Sliver的绘制渲染。</li></ul><p>RenderObjectWithChildMixin为只有一个child的RenderObject提供child管理模型，ContainerRenderObjectMixin用于为多个child的RenderObject提供child管理模型。</p><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RenderObject/RenderObject_XMind.png"></p><h3 id="核心函数比较"><a href="#核心函数比较" class="headerlink" title="核心函数比较"></a>核心函数比较</h3><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RenderObject/RendObject_2.png"></p><table><thead><tr><th>作用</th><th>Flutter RenderObject</th><th>Android View</th></tr></thead><tbody><tr><td>绘制</td><td>paint()</td><td>draw()&#x2F;onDraw()</td></tr><tr><td>布局</td><td>performLayout()&#x2F;layout()</td><td>measure()&#x2F;onMeasure(), layout()&#x2F;onLayout()</td></tr><tr><td>布局约束</td><td>Constraints</td><td>MeasureSpec</td></tr><tr><td>布局协议1</td><td>performLayout() 的 Constraints 参数表示父节点对子节点的布局限制</td><td>measure() 的两个参数表示父节点对子节点的布局限制</td></tr><tr><td>布局协议2</td><td>performLayout() 应调用各子节点的 layout()</td><td>onLayout() 应调用各子节点的 layout()</td></tr><tr><td>布局参数</td><td>parentData</td><td>mLayoutParams</td></tr><tr><td>请求布局</td><td>markNeedsLayout()</td><td>requestLayout()</td></tr><tr><td>请求绘制</td><td>markNeedsPaint()</td><td>invalidate()</td></tr><tr><td>添加</td><td>child adoptChild()</td><td>addView()</td></tr><tr><td>移除</td><td>child dropChild()</td><td>removeView()</td></tr><tr><td>关联到窗口&#x2F;树</td><td>attach()</td><td>onAttachedToWindow()</td></tr><tr><td>从窗口&#x2F;树取消关联</td><td>detach()</td><td>onDetachedFromWindow()</td></tr><tr><td>获取 parent</td><td>parent</td><td>getParent()</td></tr><tr><td>触摸事件</td><td>hitTest()</td><td>onTouch()</td></tr><tr><td>用户输入事件</td><td>handleEvent()</td><td>onKey()</td></tr><tr><td>旋转事件</td><td>rotate()</td><td>onConfigurationChanged()</td></tr></tbody></table><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RenderObject/renderobject_1.png"></p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>Widget中有对应的createRenderObject方法，mount时调用，用于创建Widget对应的RenderObject。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RenderObjectElement</span></span><br><span class="line"><span class="keyword">void</span> mount(<span class="built_in">Element</span> parent, <span class="built_in">dynamic</span> newSlot) &#123;</span><br><span class="line">  <span class="keyword">super</span>.mount(parent, newSlot);</span><br><span class="line">  _renderObject = widget.createRenderObject(<span class="keyword">this</span>);</span><br><span class="line">  attachRenderObject(newSlot);</span><br><span class="line">  _dirty = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>当RenderObject需要（重新）布局时调用markNeedLayout，从而被PipelineOwner收集，并在下一帧刷新时触发Layout操作</p><h3 id="markNeedsLayout调用场景"><a href="#markNeedsLayout调用场景" class="headerlink" title="markNeedsLayout调用场景"></a>markNeedsLayout调用场景</h3><ul><li>Render Object 被添加到『 RenderObject Tree 』;</li><li>子节点 adopt、drop、move；</li><li>由子节点的markNeedsLayout方法传递调用；</li><li>Render Object 自身与布局相关的属性发生变化，如RenderFlex的排版方向有变化时：</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> direction(Axis value) &#123;</span><br><span class="line">  <span class="keyword">if</span> (_direction != value) &#123;</span><br><span class="line">    _direction = value;</span><br><span class="line">    markNeedsLayout();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Relayout-Boundary"><a href="#Relayout-Boundary" class="headerlink" title="Relayout Boundary"></a>Relayout Boundary</h3><p>若某个 Render Object 的布局变化不会影响到其父节点的布局，则该 Render Object 就是『 Relayout Boundary 』。<br>Relayout Boundary 是一项重要的优化措施，可以避免不必要的 re-layout。<br>当某个 Render Object 是 Relayout Boundary 时，会切断 layout dirty 向父节点传播，即下一帧刷新时父节点无需 re-layout。</p><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RenderObject/RelayoutBoundary.png"></p><ul><li>若RD节点出现 layout dirty，由于其自身、其父节点RA、RRoot都不是 Relayout Boundary，最终 layout dirty 传播到根节点RenderView，导致整颗『 RenderObject Tree 』重新布局；</li><li>若RF节点出现 layout dirty，由于其父节点RB为 Relayout Boundary，layout dirty 传播到RB即结束，最终需要重新布局的只有RB、RF两个节点；</li><li>若RG节点出现 layout dirty，由于其自身就是 Relayout Boundary，最终需要重新布局的只有RG自己。</li></ul><p>那么，要成为Relayout Boundary，需要什么条件？</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> layout(Constraints constraints, &#123; <span class="built_in">bool</span> parentUsesSize = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">    RenderObject relayoutBoundary;</span><br><span class="line">    <span class="keyword">if</span> (!parentUsesSize || sizedByParent || constraints.isTight || parent <span class="keyword">is</span>! RenderObject) &#123;</span><br><span class="line">      relayoutBoundary = <span class="keyword">this</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      relayoutBoundary = (parent <span class="keyword">as</span> RenderObject)._relayoutBoundary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">null</span> &amp;&amp; relayoutBoundary != _relayoutBoundary) &#123;</span><br><span class="line">      visitChildren(_cleanChildRelayoutBoundary);</span><br><span class="line">    &#125;</span><br><span class="line">    _relayoutBoundary = relayoutBoundary;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>满足以下条件之一即可：</p><ul><li>parentUsesSize为false，即父节点在 layout 时不会使用当前节点的 size 信息(也就是当前节点的排版信息对父节点无影响)；</li><li>sizedByParent为true，即当前节点的 size 完全由父节点的 constraints 决定，即若在两次 layout 中传递下来的 constraints 相同，则两次 layout 后当前节点的 size 也相同；</li><li>传给当前节点的 constraints 是紧凑型 (Tight)，其效果与sizedByParent为true是一样的，即当前节点的 layout 不会改变其 size，size 由 constraints 唯一确定；</li><li>父节点不是 RenderObject 类型(主要针对根节点，其父节点为nil)。</li></ul><h3 id="markNeedsLayout"><a href="#markNeedsLayout" class="headerlink" title="markNeedsLayout"></a>markNeedsLayout</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> markNeedsLayout() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_needsLayout) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">this</span>) &#123;</span><br><span class="line">    markParentNeedsLayout();</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    _needsLayout = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">      owner._nodesNeedingLayout.add(<span class="keyword">this</span>);</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>若当前 Render Object 不是 Relayout Boundary，则 layout 请求向上传播给父节点(即 layout 范围扩大到父节点，这是一个递归过程，直到遇到 Relayout Boundary)；</li><li>若当前 Render Object 是 Relayout Boundary，则 layout 请求到该节点为此，不会传播到其父节点。</li></ul><h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> layout(Constraints constraints, &#123; <span class="built_in">bool</span> parentUsesSize = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">  RenderObject relayoutBoundary;</span><br><span class="line">  <span class="keyword">if</span> (!parentUsesSize || sizedByParent || constraints.isTight || parent <span class="keyword">is</span>! RenderObject) &#123;</span><br><span class="line">    relayoutBoundary = <span class="keyword">this</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    relayoutBoundary = (parent <span class="keyword">as</span> RenderObject)._relayoutBoundary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _constraints = constraints;</span><br><span class="line">  <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">null</span> &amp;&amp; relayoutBoundary != _relayoutBoundary) &#123;</span><br><span class="line">    visitChildren(_cleanChildRelayoutBoundary);</span><br><span class="line">  &#125;</span><br><span class="line">  _relayoutBoundary = relayoutBoundary;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sizedByParent) &#123;</span><br><span class="line">    performResize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  performLayout();</span><br><span class="line">  markNeedsSemanticsUpdate();</span><br><span class="line">  </span><br><span class="line">  _needsLayout = <span class="keyword">false</span>;</span><br><span class="line">  markNeedsPaint();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>layout方法是触发Render Object更新布局信息的主要入口点。一般情况下，由父节点调用子节点的layout方法来更新其整体布局。<br>RenderObject的子类不应重写该方法，可按需重写performResize或&#x2F;和performLayout方法。<br>当前 Render Object 的布局受到layout方法参数constraints的约束。</p><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RenderObject/LayputDataFlow.png"></p><p>如上图，『 Render Object Tree 』的 layout 是一次深度优先遍历的过程。<br>优先 layout 子节点，之后 layout 父节点。<br>父节点向子节点传递 layout constraints，子节点在 layout 时需遵守这些约束。<br>作为子节点 layout 的结果，父节点在 layout 时可以使用子节点的 size。</p><p>在上述layout代码第19~21行，若sizedByParent为true，则调用performResize来计算该 Render Object 的 size。</p><p>sizedByParent为true的 Render Object 需重写performResize方法，在该方法中仅根据constraints来计算 size。<br>如RenderBox中定义的performResize的默认行为：取constraints约束下的最小 size：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">void</span> performResize() &#123;</span><br><span class="line">  <span class="comment">// default behavior for subclasses that have sizedByParent = true</span></span><br><span class="line">  size = constraints.smallest;</span><br><span class="line">  <span class="keyword">assert</span>(size.isFinite);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若父节点 layout 依赖子节点的 size，在调用layout方法时需将parentUsesSize参数设为true。<br>因为，在这种情况下若子节点 re-layout 导致其 size 发生变化，需要及时通知父节点，父节点也需要 re-layout (即 layout dirty 范围需要向上传播)。<br>这一切都是通过上节介绍过的 Relayout Boundary 来实现。</p><h3 id="performLayout"><a href="#performLayout" class="headerlink" title="performLayout"></a>performLayout</h3><p>本质上，layout是一个模板方法，具体的布局工作由performLayout方法完成。<br>RenderObject#performLayout是一个抽象方法，子类需重写。</p><p>关于performLayout有几点需要注意：</p><ul><li>该方法由layout方法调用，在需要 re-layout 时应调用layout方法，而不是performLayout；</li><li>若sizedByParent为true，则该方法不应改变当前 Render Object 的 size ( 其 size 由performResize方法计算)；</li><li>若sizedByParent为false，则该方法不仅要执行 layout 操作，还要计算当前 Render Object 的 size；</li><li>在该方法中，需对其所有子节点调用layout方法以执行所有子节点的 layout 操作，如果当前 Render Object 依赖子节点的布局信息，需将parentUsesSize参数设为true。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RenderFlex</span></span><br><span class="line"><span class="keyword">void</span> performLayout() &#123;</span><br><span class="line">  RenderBox child = firstChild;</span><br><span class="line">  <span class="keyword">while</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> FlexParentData childParentData = child.parentData;</span><br><span class="line">    BoxConstraints innerConstraints = BoxConstraints(minHeight: constraints.maxHeight, maxHeight: constraints.maxHeight);</span><br><span class="line">    child.layout(innerConstraints, parentUsesSize: <span class="keyword">true</span>);</span><br><span class="line">    child = childParentData.nextSibling;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  size = constraints.constrain(Size(idealSize, crossSize));</span><br><span class="line">  </span><br><span class="line">  child = firstChild;</span><br><span class="line">  <span class="keyword">while</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> FlexParentData childParentData = child.parentData;</span><br><span class="line">    <span class="built_in">double</span> childCrossPosition = crossSize / <span class="number">2.0</span> - _getCrossSize(child) / <span class="number">2.0</span>;</span><br><span class="line">    childParentData.offset = Offset(childMainPosition, childCrossPosition);</span><br><span class="line">    child = childParentData.nextSibling;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码片段截取自RenderFlex，可以看到它大概做了3件事：</p><ul><li>对所有子节点逐个调用layout方法；</li><li>计算当前 Render Object 的 size；</li><li>将与子节点布局有关的信息存储到相应子节点的parentData中。</li></ul><blockquote><p>RenderFlex继承自RenderBox，是常用的Row、Column对应的 Render Object</p></blockquote><h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><h3 id="markNeedsPaint"><a href="#markNeedsPaint" class="headerlink" title="markNeedsPaint"></a>markNeedsPaint</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> markNeedsPaint() &#123;</span><br><span class="line">  <span class="keyword">if</span> (isRepaintBoundary) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(_layer <span class="keyword">is</span> OffsetLayer);</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">      owner._nodesNeedingPaint.add(<span class="keyword">this</span>);</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">is</span> RenderObject) &#123;</span><br><span class="line">    <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent;</span><br><span class="line">    parent.markNeedsPaint();</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>)</span><br><span class="line">      owner.requestVisualUpdate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>markNeedsPaint内部逻辑与markNeedsLayout都非常相似：</p><ul><li>若当前 Render Object 是 Repaint Boundary，则将其添加到PipelineOwner#_nodesNeedingPaint中，Paint request 也随之结束；</li><li>否则，Paint request 向父节点传播，即需要 re-paint 的范围扩大到父节点(这是一个递归的过程)；</li><li>有一个特例，那就是『 Render Object Tree 』的根节点，即 RenderView，它的父节点为 nil，此时只需调用PipelineOwner#requestVisualUpdate即可。</li></ul><h3 id="Repaint-Boundary"><a href="#Repaint-Boundary" class="headerlink" title="Repaint Boundary"></a>Repaint Boundary</h3><p>Repaint Boundary 有以下特点：</p><ul><li>每个 Repaint Boundary 都有一个独属于自己的 OffsetLayer (ContainerLayer)，其自身及子孙节点的绘制结果都将 attach 到以该 layer 为根节点的子树上；</li><li>每个 Repaint Boundary 都有一个独属于自己的 PaintingContext (包括背后的 Canvas)，从而使得其绘制与父节点完全隔离开。</li></ul><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RenderObject/RepaintBoundary.png"></p><p>如上图，由于Root&#x2F;RA&#x2F;RC&#x2F;RG&#x2F;RI是 Repaint Boundary，所以它们都有对应的 OffsetLayer。<br>同时，由于每个 Repaint Boundary 都有属于自己的 PaintingContext，所以它们都有对应的 PictureLayer，用于呈现具体的绘制结果。<br>对于那些不是 Repaint Boundary 的节点，将会绘制到最近的 Repaint Boundary 祖先节点提供的 PictureLayer 上。</p><blockquote><p>Repaint Boundary 会影响兄弟节点的绘制，如由于RC是 Repaint Boundary，导致RB、RD被绘制到不同的 PictureLayer 上。</p></blockquote><blockquote><p>实现中，『 Layer Tree 』往往会比上图所示更复杂，由于每个 Render Object 在绘制过程中都可以自主引入更多的 layer。</p></blockquote><h3 id="paint"><a href="#paint" class="headerlink" title="paint"></a>paint</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123; &#125;</span><br></pre></td></tr></table></figure><p>paint方法主要有2项任务：</p><ul><li>当前 Render Object 本身的绘制，如：RenderImage，其paint方法主要职责就是 image 的渲染</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">  paintImage(</span><br><span class="line">    canvas: context.canvas,</span><br><span class="line">    rect: offset &amp; size,</span><br><span class="line">    image: _image,</span><br><span class="line">    ...</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>绘制子节点，如：RenderTable，其paint方法主要职责是依次对每个子节点调用PaintingContext#paintChild方法进行绘制：</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paint(PaintingContext context, Offset offset) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">int</span> index = <span class="number">0</span>; index &lt; _children.length; index += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> RenderBox child = _children[index];</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> BoxParentData childParentData = child.parentData;</span><br><span class="line">      context.paintChild(child, childParentData.offset + offset);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="串起来"><a href="#串起来" class="headerlink" title="串起来"></a>串起来</h3><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/RenderObject/RenderObject-Paint-Line.png"></p><h4 id="PipelineOwner-flushPaint"><a href="#PipelineOwner-flushPaint" class="headerlink" title="PipelineOwner#flushPaint"></a>PipelineOwner#flushPaint</h4><p>当新一帧开始时，会触发PipelineOwner#flushPaint方法，进而对dirty Render Object进行re-paint</p><h4 id="PaintingContext-repaintCompositedChild"><a href="#PaintingContext-repaintCompositedChild" class="headerlink" title="PaintingContext#repaintCompositedChild"></a>PaintingContext#repaintCompositedChild</h4><p>作用：</p><ol><li>创建layer</li><li>为RenderObject的绘制准备context并发起绘制流程</li></ol><h4 id="RenderObject-paintWithContext"><a href="#RenderObject-paintWithContext" class="headerlink" title="RenderObject#_paintWithContext"></a>RenderObject#_paintWithContext</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _paintWithContext(PaintingContext context, Offset offset) &#123;</span><br><span class="line">  paint(context, offset);<span class="comment">//子类实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PaintingContext-paintChild"><a href="#PaintingContext-paintChild" class="headerlink" title="PaintingContext#paintChild"></a>PaintingContext#paintChild</h4><p>对于当前绘制子节点，若是 Repaint Boundary，则需要在独立的 layer 上进行绘制，否则直接调用子节点的_paintWithContext方法在当前上下文(paint context)中绘制：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> paintChild(RenderObject child, Offset offset) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.isRepaintBoundary) &#123;</span><br><span class="line">      stopRecordingIfNeeded();</span><br><span class="line">      _compositeChild(child, offset);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child._wasRepaintBoundary) &#123;</span><br><span class="line">      child._layerHandle.layer = <span class="keyword">null</span>;</span><br><span class="line">      child._paintWithContext(<span class="keyword">this</span>, offset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      child._paintWithContext(<span class="keyword">this</span>, offset);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> stopRecordingIfNeeded() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!_isRecording)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  _currentLayer.picture = _recorder.endRecording();</span><br><span class="line">  _currentLayer = <span class="keyword">null</span>;</span><br><span class="line">  _recorder = <span class="keyword">null</span>;</span><br><span class="line">  _canvas = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PaintingContext-compositeChild"><a href="#PaintingContext-compositeChild" class="headerlink" title="PaintingContext#_compositeChild"></a>PaintingContext#_compositeChild</h4><p>在_compositeChild中，通过repaintCompositedChild对子节点发起新一轮的绘制，并将绘制结果(child._layer)添加到『 Layer Tree 』中：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _compositeChild(RenderObject child, Offset offset) &#123;</span><br><span class="line">  <span class="keyword">assert</span>(!_isRecording);</span><br><span class="line">  <span class="keyword">assert</span>(child.isRepaintBoundary);</span><br><span class="line">  <span class="keyword">assert</span>(_canvas == <span class="keyword">null</span> || _canvas.getSaveCount() == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  repaintCompositedChild(child, debugAlsoPaintedParent: <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> OffsetLayer childOffsetLayer = child._layer;</span><br><span class="line">  childOffsetLayer.offset = offset;</span><br><span class="line">  appendLayer(child._layer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跑起来"><a href="#跑起来" class="headerlink" title="跑起来"></a>跑起来</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zxfcumtcs.github.io/2021/03/27/deepinto-flutter-renderobject/">深入浅出 Flutter Framework 之 RenderObject</a></li><li><a href="https://book.flutterchina.club/chapter14/render_object.html">Flutter实战-RenderObject（布局、绘制、点击测试）</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;RenderObject表示渲染树的一个对象，其职责包括：Layout、Paint、Hit Testing。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Paint过程</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Paint%E8%BF%87%E7%A8%8B/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Paint%E8%BF%87%E7%A8%8B/</id>
    <published>2024-07-25T13:33:15.217Z</published>
    <updated>2024-07-27T03:23:26.744Z</updated>
    
    <content type="html"><![CDATA[<p>经过Build流程，Render Tree中绘制相关的基础信息已经完成更新；经过Layout流程，Render Tree中每个节点的大小和位置完成计算与存储，接下来进入Paint流程：基于Layout的信息生成绘制指令。</p><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Paint%E8%BF%87%E7%A8%8B/paint.png"></p><p>Render Tree和Layer Tree的对应关系</p><p>使用Layer Tree的好处是可以做Paint流程的局部更新。Render Tree中，每个RenderObject对象都拥有一个needsCompositing属性，用于判断自身及子节点是否有一个要去合成的图层，同是还有一个_needsCompositingBitsUpdate字段<br>用于标记该属性是否需要更新。Flutter在Paint开始前首先会完成needsCompositing属性的更新，然后开始正式绘制。</p><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Paint%E8%BF%87%E7%A8%8B/layer1.png"></p><p>Layer的子类分为以下几种类型：</p><ul><li>ContainerLayer：容器层，用于包含其他Layer。</li><li>PictureLayer：执行实际绘制的节点。通过_picture字段持有一个ui.PictureRecorder对象，用于Engine进行对应绘制指令的记录。</li><li>TextureLayer、PlatformLayer：渲染源将有外部提供</li></ul><h2 id="Compositing-State-Mark阶段"><a href="#Compositing-State-Mark阶段" class="headerlink" title="Compositing-State Mark阶段"></a>Compositing-State Mark阶段</h2><p>当Render Tree需要挂载（mount）或卸载（unmount）一个子节点时，就会调用markNeedsCompositingBitsUpdate方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> </span>&#123;</span><br><span class="line">   <span class="keyword">void</span> markNeedsCompositingBitsUpdate() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_needsCompositingBitsUpdate) &#123;<span class="comment">//已经标记过需要更新</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _needsCompositingBitsUpdate = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (parent <span class="keyword">is</span> RenderObject) &#123;<span class="comment">//处理父节点</span></span><br><span class="line">      <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent! <span class="keyword">as</span> RenderObject;</span><br><span class="line">      <span class="keyword">if</span> (parent._needsCompositingBitsUpdate) &#123;<span class="comment">//如果父节点标记过，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((!_wasRepaintBoundary || !isRepaintBoundary) &amp;&amp; !parent.isRepaintBoundary) &#123;<span class="comment">//非绘制边界才需要标记父节点</span></span><br><span class="line">        parent.markNeedsCompositingBitsUpdate();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">      owner!._nodesNeedingCompositingBitsUpdate.add(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Compositing-State-Flush阶段"><a href="#Compositing-State-Flush阶段" class="headerlink" title="Compositing-State Flush阶段"></a>Compositing-State Flush阶段</h2><p>Layout完成之后将调用pipelineOwner.flushCompositingBits()</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PipelineOwner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> flushCompositingBits() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!kReleaseMode) &#123;</span><br><span class="line">      Timeline.startSync(<span class="string">&#x27;UPDATING COMPOSITING BITS&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    _nodesNeedingCompositingBitsUpdate.sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth);<span class="comment">//优先遍历祖先节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> RenderObject node <span class="keyword">in</span> _nodesNeedingCompositingBitsUpdate) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node._needsCompositingBitsUpdate &amp;&amp; node.owner == <span class="keyword">this</span>) &#123;</span><br><span class="line">        node._updateCompositingBits();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _nodesNeedingCompositingBitsUpdate.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> PipelineOwner child <span class="keyword">in</span> _children) &#123;</span><br><span class="line">      child.flushCompositingBits();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!kReleaseMode) &#123;</span><br><span class="line">      Timeline.finishSync();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> _updateCompositingBits() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_needsCompositingBitsUpdate) &#123;<span class="comment">//第1步，无更新直接返回</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span> oldNeedsCompositing = _needsCompositing;</span><br><span class="line">    _needsCompositing = <span class="keyword">false</span>;<span class="comment">//默认不需要合成，即单独使用一个图层</span></span><br><span class="line">    visitChildren((RenderObject child) &#123;<span class="comment">//第2步，遍历每个子节点</span></span><br><span class="line">      child._updateCompositingBits();</span><br><span class="line">      <span class="keyword">if</span> (child.needsCompositing) &#123;<span class="comment">//如果子节点需要合成，则父节点也需要，直到遇到绘制边界</span></span><br><span class="line">        _needsCompositing = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (isRepaintBoundary || alwaysNeedsCompositing) &#123;<span class="comment">//第3步，判断是否需要合成，即是否是一个独立图层</span></span><br><span class="line">      _needsCompositing = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isRepaintBoundary &amp;&amp; _wasRepaintBoundary) &#123;<span class="comment">//第4步，</span></span><br><span class="line">      _needsPaint = <span class="keyword">false</span>;</span><br><span class="line">      _needsCompositedLayerUpdate = <span class="keyword">false</span>;</span><br><span class="line">      owner?._nodesNeedingPaint.remove(<span class="keyword">this</span>);</span><br><span class="line">      _needsCompositingBitsUpdate = <span class="keyword">false</span>;</span><br><span class="line">      markNeedsPaint();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldNeedsCompositing != _needsCompositing) &#123;<span class="comment">//判断_needsCompositing是否发生变化</span></span><br><span class="line">      _needsCompositingBitsUpdate = <span class="keyword">false</span>;</span><br><span class="line">      markNeedsPaint();<span class="comment">//图层发生变化，需要重绘</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _needsCompositingBitsUpdate = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Paint-Mark阶段"><a href="#Paint-Mark阶段" class="headerlink" title="Paint Mark阶段"></a>Paint Mark阶段</h2><p>Paint和Layout的脏节点标记逻辑比较类似，RenderObject中对绘制有影响的属性更新了就会进行标记，比如RenderImage的image属性</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> image(ui.Image? value) &#123;</span><br><span class="line">  <span class="keyword">if</span> (value == _image) &#123;<span class="comment">//没有改变</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; _image != <span class="keyword">null</span> &amp;&amp; value.isCloneOf(_image!)) &#123;</span><br><span class="line">    value.dispose();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  _image?.dispose();</span><br><span class="line">  _image = value;</span><br><span class="line">  markNeedsPaint();</span><br><span class="line">  <span class="keyword">if</span> (_width == <span class="keyword">null</span> || _height == <span class="keyword">null</span>) &#123;</span><br><span class="line">    markNeedsLayout();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>markNeedsPaint方法的逻辑如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> markNeedsPaint() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_needsPaint) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _needsPaint = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (isRepaintBoundary &amp;&amp; _wasRepaintBoundary) &#123;<span class="comment">//第一种情况，如果是绘制边界</span></span><br><span class="line">      <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        owner!._nodesNeedingPaint.add(<span class="keyword">this</span>);<span class="comment">//重新加入到需要绘制的列表中</span></span><br><span class="line">        owner!.requestVisualUpdate();<span class="comment">//请求渲染</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">is</span> RenderObject) &#123;<span class="comment">//第二种情况，父节点不是绘制边界</span></span><br><span class="line">      <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent! <span class="keyword">as</span> RenderObject;</span><br><span class="line">      parent.markNeedsPaint();<span class="comment">//父节点也受影响，直接向上标记</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;<span class="comment">//第三种情况，非RenderObject</span></span><br><span class="line">        owner!.requestVisualUpdate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Paint-Flush阶段"><a href="#Paint-Flush阶段" class="headerlink" title="Paint Flush阶段"></a>Paint Flush阶段</h2><p>当flushCompositingBits完成之后，会调用pipelineOwner.flushPaint()</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PipelineOwner</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> flushPaint() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingPaint;</span><br><span class="line">      _nodesNeedingPaint = &lt;RenderObject&gt;[];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Sort the dirty nodes in reverse order (deepest first).</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> RenderObject node <span class="keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; b.depth - a.depth)) &#123;<span class="comment">//从深到浅遍历</span></span><br><span class="line">        <span class="keyword">if</span> ((node._needsPaint || node._needsCompositedLayerUpdate) &amp;&amp; node.owner == <span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (node._layerHandle.layer!.attached) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node._needsPaint) &#123;</span><br><span class="line">              PaintingContext.repaintCompositedChild(node);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              PaintingContext.updateLayerProperties(node);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node._skippedPaintingOnLayer();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> PipelineOwner child <span class="keyword">in</span> _children) &#123;</span><br><span class="line">        child.flushPaint();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintingContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> repaintCompositedChild(RenderObject child, &#123; <span class="built_in">bool</span> debugAlsoPaintedParent = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">    _repaintCompositedChild(</span><br><span class="line">      child,</span><br><span class="line">      debugAlsoPaintedParent: debugAlsoPaintedParent,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _repaintCompositedChild(</span><br><span class="line">    RenderObject child, &#123;</span><br><span class="line">    <span class="built_in">bool</span> debugAlsoPaintedParent = <span class="keyword">false</span>,</span><br><span class="line">    PaintingContext? childContext,</span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    OffsetLayer? childLayer = child._layerHandle.layer <span class="keyword">as</span> OffsetLayer?;</span><br><span class="line">    <span class="keyword">if</span> (childLayer == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> OffsetLayer layer = child.updateCompositedLayer(oldLayer: <span class="keyword">null</span>);<span class="comment">//没有就创建一个OffsetLayer</span></span><br><span class="line">      child._layerHandle.layer = childLayer = layer;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      childLayer.removeAllChildren();<span class="comment">//移除子节点</span></span><br><span class="line">      <span class="keyword">final</span> OffsetLayer updatedLayer = child.updateCompositedLayer(oldLayer: childLayer);</span><br><span class="line">    &#125;</span><br><span class="line">    child._needsCompositedLayerUpdate = <span class="keyword">false</span>;</span><br><span class="line">    childContext ??= PaintingContext(childLayer, child.paintBounds);</span><br><span class="line">    child._paintWithContext(childContext, Offset.zero);<span class="comment">//绘制当前图层</span></span><br><span class="line">    childContext.stopRecordingIfNeeded();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> _paintWithContext(PaintingContext context, Offset offset) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_needsLayout) &#123;<span class="comment">//存在Layout未处理的节点</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RenderObject? debugLastActivePaint;</span><br><span class="line">    _needsPaint = <span class="keyword">false</span>;</span><br><span class="line">    _needsCompositedLayerUpdate = <span class="keyword">false</span>;</span><br><span class="line">    _wasRepaintBoundary = isRepaintBoundary;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      paint(context, offset);<span class="comment">//开始绘制，具体的绘制逻辑在子类中</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      _reportException(<span class="string">&#x27;paint&#x27;</span>, e, stack);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>PipelineOwner是『RenderObject Tree』与『RendererBinding』间的桥梁，在两者间起到沟通协调的作用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">  pipelineOwner.flushLayout();</span><br><span class="line">  pipelineOwner.flushCompositingBits();</span><br><span class="line">  pipelineOwner.flushPaint();</span><br><span class="line">  renderView.compositeFrame(); <span class="comment">// this sends the bits to the GPU</span></span><br><span class="line">  pipelineOwner.flushSemantics(); <span class="comment">// this also sends the semantics to the OS.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>Root Widget(RenderObjectToWidgetAdapter)</li><li>『 Element Tree 』的根节点(RenderObjectToWidgetElement)</li><li>『 RenderObject Tree 』的根节点(RenderView)</li><li>『 Layer Tree 』的根节点(TransformLayer)</li></ul><ol><li><p>确定当前组件的布局边界。</p></li><li><p>判断是否需要重新布局，如果没必要会直接返回，反之才需要重新布局。不需要布局时需要同时满足三个条件：</p><ul><li><p>当前组件没有被标记为需要重新布局。</p></li><li><p>父组件传递的约束没有发生变化。</p></li><li><p>当前组件的布局边界也没有发生变化时。</p></li></ul></li><li><p>调用 performLayout() 进行布局，因为 performLayout() 中又会调用子组件的 layout 方法，所以这时一个递归的过程，递归结束后整个组件树的布局也就完成了。</p></li><li><p>请求重绘。</p></li></ol><h2 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h2><p><strong>大致流程：</strong></p><p>第一次绘制时，从上到下递归绘制子节点，每当遇到一个边界节点，判断如果该节点的layer属性是否为空，是就创建一个新的OffsetLayer并赋值给它；不是则使用。然后将layer传递给子节点，接下来：</p><ol><li>如果子节点是非边界节点，且需要绘制，则：<ul><li>第一次绘制：创建一个Canvas对象和一个PictureLayer，然后将它们绑定，后续调用Canvas绘制都会落到和其绑定的PictureLayer上，接着这个PictureLayer会加入到边界节点的layer中；</li><li>不是第一次绘制：复用已有的边界节点和Canvas对象；</li></ul></li><li>如果子节点是边界节点，则对子节点递归上述过程。当子树递归完成后，就要将子节点的layer添加到父级layer中。</li></ol><p>RenderObject调用markNeedsRepaint来发起重绘：</p><ol><li>从当前节点一直往父级查找，直到找到一个<strong>绘制边界点</strong>时终止查找，然后会将该绘制边界点添加到其PiplineOwner的_nodesNeedingPaint列表中。</li><li>在查找的过程中，会将自己到绘制边界点路径上所有节点的_needPaint属性设置为true，表示需要重绘。</li><li>请求新的frame，执行重绘流程。下一个frame就会走drawFrame流程，涉及到flushCompositingBits、flushPaint 和 compositeFrame 三个函数。</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> markNeedsPaint() &#123;</span><br><span class="line">  <span class="keyword">if</span> (_needsPaint) <span class="keyword">return</span>;</span><br><span class="line">  _needsPaint = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (isRepaintBoundary) &#123; <span class="comment">// 如果是当前节点是边界节点</span></span><br><span class="line">      owner!._nodesNeedingPaint.add(<span class="keyword">this</span>); <span class="comment">//将当前节点添加到需要重新绘制的列表中。</span></span><br><span class="line">      owner!.requestVisualUpdate(); <span class="comment">// 请求新的frame，该方法最终会调用scheduleFrame()</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent <span class="keyword">is</span> RenderObject) &#123; <span class="comment">// 若不是边界节点且存在父节点</span></span><br><span class="line">    <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent! <span class="keyword">as</span> RenderObject;</span><br><span class="line">    parent.markNeedsPaint(); <span class="comment">// 递归调用父节点的markNeedsPaint</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是根节点，直接请求新的 frame 即可</span></span><br><span class="line">    <span class="keyword">if</span> (owner != <span class="keyword">null</span>)</span><br><span class="line">      owner!.requestVisualUpdate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href>Flutter内核源码剖析</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;经过Build流程，Render Tree中绘制相关的基础信息已经完成更新；经过Layout流程，Render Tree中每个节点的大小和位置完成计算与存储，接下来进入Paint流程：基于Layout的信息生成绘制指令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/wiki/Flu</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>PipelineOwner</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/PipelineOwner/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/PipelineOwner/</id>
    <published>2024-07-25T13:33:15.217Z</published>
    <updated>2024-07-25T15:27:46.958Z</updated>
    
    <content type="html"><![CDATA[<p>在runApp时，RenderBinding创建PipelineOwner。PipelineOwner的作用：</p><ul><li>不断收集Dirty Render Objects</li><li>驱动Rendering Pipeline刷新UI</li></ul><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/PipelineOwner/PipelineOwner.PNG"></p><h3 id="Dirty-RenderObjects"><a href="#Dirty-RenderObjects" class="headerlink" title="Dirty RenderObjects"></a>Dirty RenderObjects</h3><p>Render Object 有4种<code>Dirty State</code>需要PipelineOwner维护：</p><ul><li>Needing Layout：Render Object需要重新layout</li><li>Needing Compositing Bits Update：Render Object合成标志位有变化</li><li>Needing Paint：Render Object需要重新绘制</li><li>Needing Semantice：Render Object辅助信息有变化</li></ul><h2 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h2><h3 id="Dirty-RenderObjects-1"><a href="#Dirty-RenderObjects-1" class="headerlink" title="Dirty RenderObjects"></a>Dirty RenderObjects</h3><p>Render Object有4种Dirty State需要PipelineOwner维护：</p><ul><li>Needing Layout：Render Object需要重新layout</li><li>Needing Compositing Bits Update：Render Object合成标志位有变化</li><li>Needing Paint：Render Object需要重新绘制</li><li>Needing Semantice：Render Object辅助信息有变化</li></ul><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/PipelineOwner/RenderObject_PipelineOwner_RendererBinding.png"></p><ul><li>当 RenderObject 需要重新 layout 时，调用markNeedsLayout方法，该方法会将当前 RenderObject 加入 PipelineOwner#_nodesNeedingLayout或传给父节点去处理；</li><li>当 RenderObject 的 Compositing Bits 有变化时，调用markNeedsCompositingBitsUpdate方法，该方法会将当前 RenderObject 加入 PipelineOwner#_nodesNeedingCompositingBitsUpdate或传给父节点去处理；</li><li>当 RenderObject 需要重新 paint 时，调用markNeedsPaint方法，该方法会将当前 RenderObject 加入PipelineOwner#_nodesNeedingPaint或传给父节点处理；</li><li>当 RenderObject 的辅助信息(Semantics)有变化时，调用markNeedsSemanticsUpdate方法，该方法会将当前 RenderObject 加入 PipelineOwner#_nodesNeedingSemantics或传给父节点去处理</li></ul><h3 id="Request-Visual-Update"><a href="#Request-Visual-Update" class="headerlink" title="Request Visual Update"></a>Request Visual Update</h3><p>上述4个markNeeds*方法，除了markNeedsCompositingBitsUpdate，其他方法最后都会调用PipelineOwner#requestVisualUpdate。<br>之所以markNeedsCompositingBitsUpdate不会调用PipelineOwner#requestVisualUpdate，是因为其不会单独出现，一定是伴随其他3个之一一起出现的。</p><h3 id="Handle-Draw-Frame"><a href="#Handle-Draw-Frame" class="headerlink" title="Handle Draw Frame"></a>Handle Draw Frame</h3><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/PipelineOwner/RendererBinding_handleDrawFrame.png"></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderBinding</span> </span>&#123;</span><br><span class="line">  <span class="comment">//系统vsync触发帧刷新，PipelineOwner构建RenderObject树</span></span><br><span class="line">  <span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">    pipelineOwner.flushLayout();</span><br><span class="line">    pipelineOwner.flushCompositingBits();</span><br><span class="line">    pipelineOwner.flushPaint();</span><br><span class="line">    renderView.compositeFrame(); <span class="comment">// this sends the bits to the GPU</span></span><br><span class="line">    pipelineOwner.flushSemantics(); <span class="comment">// this also sends the semantics to the OS.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Flush-Layout"><a href="#Flush-Layout" class="headerlink" title="Flush Layout"></a>Flush Layout</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PipelineOwner</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> flushLayout() &#123;</span><br><span class="line">    <span class="keyword">while</span> (_nodesNeedingLayout.isNotEmpty) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout;</span><br><span class="line">      _nodesNeedingLayout = &lt;RenderObject&gt;[];</span><br><span class="line">      <span class="keyword">for</span> (RenderObject node <span class="keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node._needsLayout &amp;&amp; node.owner == <span class="keyword">this</span>)</span><br><span class="line">          node._layoutWithoutResize();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> flushCompositingBits() &#123;</span><br><span class="line">    _nodesNeedingCompositingBitsUpdate.sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> RenderObject node <span class="keyword">in</span> _nodesNeedingCompositingBitsUpdate) &#123;</span><br><span class="line">      <span class="keyword">if</span> (node._needsCompositingBitsUpdate &amp;&amp; node.owner == <span class="keyword">this</span>) &#123;</span><br><span class="line">        node._updateCompositingBits();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _nodesNeedingCompositingBitsUpdate.clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> PipelineOwner child <span class="keyword">in</span> _children) &#123;</span><br><span class="line">      child.flushCompositingBits();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> flushPaint() &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingPaint;</span><br><span class="line">      _nodesNeedingPaint = &lt;RenderObject&gt;[];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> RenderObject node <span class="keyword">in</span> dirtyNodes..sort((RenderObject a, RenderObject b) =&gt; b.depth - a.depth)) &#123;</span><br><span class="line">        <span class="keyword">assert</span>(node._layerHandle.layer != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((node._needsPaint || node._needsCompositedLayerUpdate) &amp;&amp; node.owner == <span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (node._layerHandle.layer!.attached) &#123;</span><br><span class="line">            <span class="keyword">assert</span>(node.isRepaintBoundary);</span><br><span class="line">            <span class="keyword">if</span> (node._needsPaint) &#123;</span><br><span class="line">              PaintingContext.repaintCompositedChild(node);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              PaintingContext.updateLayerProperties(node);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node._skippedPaintingOnLayer();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> PipelineOwner child <span class="keyword">in</span> _children) &#123;</span><br><span class="line">        child.flushPaint();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/PipelineOwner/PaintingPipeline.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在runApp时，RenderBinding创建PipelineOwner。PipelineOwner的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不断收集Dirty Render Objects&lt;/li&gt;
&lt;li&gt;驱动Rendering Pipeline刷新UI&lt;/li&gt;
&lt;/ul</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>InheritedWidget</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/InheritedWidget/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/InheritedWidget/</id>
    <published>2024-07-25T13:33:15.216Z</published>
    <updated>2024-07-25T13:33:15.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h2><ul><li>InheritedWidget</li><li>ProxyWidget</li><li>InheritedElement</li></ul><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>提供一种在widget树中从上到下共享数据的方式。当前节点和关联节点同时注册。当build时，会检查是否需要刷新。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InheritedWidgetTestRoute</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _InheritedWidgetTestRouteState createState() =&gt; _InheritedWidgetTestRouteState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_InheritedWidgetTestRouteState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">InheritedWidgetTestRoute</span>&gt; </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: ShareDataWidget(</span><br><span class="line">        <span class="comment">//使用ShareDataWidget</span></span><br><span class="line">        data: count,</span><br><span class="line">        child: Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Padding(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.only(bottom: <span class="number">20.0</span>),</span><br><span class="line">              child: TestInheritWidget(), <span class="comment">//子widget中依赖ShareDataWidget</span></span><br><span class="line">            ),</span><br><span class="line">            ElevatedButton(</span><br><span class="line">              child: <span class="keyword">const</span> Text(<span class="string">&quot;Increment&quot;</span>),</span><br><span class="line">              <span class="comment">//每点击一次，将count自增，然后重新build,ShareDataWidget的data将被更新</span></span><br><span class="line">              onPressed: () =&gt; setState(() =&gt; ++count),</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestInheritWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _TestInheritWidgetState createState() =&gt; _TestInheritWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_TestInheritWidgetState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TestInheritWidget</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">//使用InheritedWidget中的共享数据</span></span><br><span class="line">    <span class="keyword">return</span> Text(ShareDataWidget.of(context)!.data.toString());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didChangeDependencies() &#123;</span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">    <span class="comment">//父或祖先widget中的InheritedWidget改变(updateShouldNotify返回true)时会被调用。</span></span><br><span class="line">    <span class="comment">//如果build中没有依赖InheritedWidget，则此回调不会被调用。</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;_TestInheritWidgetState  Dependencies change&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> didUpdateWidget(<span class="keyword">covariant</span> TestInheritWidget oldWidget) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;_TestInheritWidgetState   didUpdateWidget&#x27;</span>);</span><br><span class="line">    <span class="keyword">super</span>.didUpdateWidget(oldWidget);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShareDataWidget</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  ShareDataWidget(&#123;Key? key, <span class="keyword">required</span> Widget child, <span class="keyword">required</span> <span class="keyword">this</span>.data&#125;) : <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> ShareDataWidget? of(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> context.dependOnInheritedWidgetOfExactType&lt;ShareDataWidget&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> updateShouldNotify(<span class="keyword">covariant</span> ShareDataWidget oldWidget) &#123;</span><br><span class="line">    <span class="keyword">return</span> oldWidget.data != data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h2><p>Element中，_inheritedWidgets保存了所有上级节点的InheritedElement。mounted方法会调用_updateInheritance方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">Type</span>, InheritedElement&gt;? _inheritedWidgets;</span><br><span class="line"><span class="comment">/// <span class="language-markdown">Element中</span></span></span><br><span class="line"><span class="keyword">void</span> _updateInheritance() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(_lifecycleState == _ElementLifecycle.active);</span><br><span class="line">  _inheritedWidgets = _parent?._inheritedWidgets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">InheritedElement中</span></span></span><br><span class="line"><span class="keyword">void</span> _updateInheritance() &#123;</span><br><span class="line">  <span class="keyword">assert</span>(_lifecycleState == _ElementLifecycle.active);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">Type</span>, InheritedElement&gt;? incomingWidgets = _parent?._inheritedWidgets;</span><br><span class="line">  <span class="keyword">if</span> (incomingWidgets != <span class="keyword">null</span>)</span><br><span class="line">    _inheritedWidgets = HashMap&lt;<span class="built_in">Type</span>, InheritedElement&gt;.of(incomingWidgets);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    _inheritedWidgets = HashMap&lt;<span class="built_in">Type</span>, InheritedElement&gt;();</span><br><span class="line">  _inheritedWidgets![widget.runtimeType] = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dependOnInheritedWidgetOfExactType"><a href="#dependOnInheritedWidgetOfExactType" class="headerlink" title="dependOnInheritedWidgetOfExactType"></a>dependOnInheritedWidgetOfExactType</h3><p>在需要使用数据的的地方，会调用dependOnInheritedWidgetOfExactType这个方法来获取相应的数据。而这个方法的Element中的实现如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">T? dependOnInheritedWidgetOfExactType&lt;T <span class="keyword">extends</span> InheritedWidget&gt;(&#123;<span class="built_in">Object?</span> aspect&#125;) &#123;</span><br><span class="line">  <span class="keyword">final</span> InheritedElement? ancestor = _inheritedWidgets == <span class="keyword">null</span> ? <span class="keyword">null</span> : _inheritedWidgets![T];<span class="comment">//先看以前有没有这个祖先</span></span><br><span class="line">  <span class="keyword">if</span> (ancestor != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> dependOnInheritedElement(ancestor, aspect: aspect) <span class="keyword">as</span> T;</span><br><span class="line">  &#125;</span><br><span class="line">  _hadUnsatisfiedDependencies = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InheritedWidget dependOnInheritedElement(InheritedElement ancestor, &#123; <span class="built_in">Object?</span> aspect &#125;) &#123;</span><br><span class="line">  _dependencies ??= HashSet&lt;InheritedElement&gt;();</span><br><span class="line">  _dependencies!.add(ancestor);<span class="comment">//将祖先添加到依赖列表</span></span><br><span class="line">  ancestor.updateDependencies(<span class="keyword">this</span>, aspect);<span class="comment">//祖先也将自己添加到他的依赖列表中</span></span><br><span class="line">  <span class="keyword">return</span> ancestor.widget <span class="keyword">as</span> InheritedWidget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从根节点到子节点，以runtimeType作为key，保存最新的Element对象。getElementForInheritedWidgetOfExactType方法可以通过类型查找离自己最近的类型的对象。<br>dependOnInheritedWidgetOfExactType方法会注册依赖，当InheritedWidget发生变化时就会更新依赖它的子组件。</p><h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><p>当进行build的时候，ProxyElement这个节点会调用updated方法，如下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> update(ProxyWidget newWidget) &#123;</span><br><span class="line">  <span class="keyword">final</span> ProxyWidget oldWidget = widget <span class="keyword">as</span> ProxyWidget;</span><br><span class="line">  <span class="keyword">super</span>.update(newWidget);</span><br><span class="line">  updated(oldWidget);</span><br><span class="line">  rebuild(force: <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> updated(InheritedWidget oldWidget) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((widget <span class="keyword">as</span> InheritedWidget).updateShouldNotify(oldWidget)) &#123;<span class="comment">//是否需要通知，这个方法我们要重写</span></span><br><span class="line">    <span class="keyword">super</span>.updated(oldWidget);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> updated(<span class="keyword">covariant</span> ProxyWidget oldWidget) &#123;</span><br><span class="line">  notifyClients(oldWidget);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> notifyClients(InheritedWidget oldWidget) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> <span class="built_in">Element</span> dependent <span class="keyword">in</span> _dependents.keys) &#123;</span><br><span class="line">    notifyDependent(oldWidget, dependent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> notifyDependent(<span class="keyword">covariant</span> InheritedWidget oldWidget, <span class="built_in">Element</span> dependent) &#123;</span><br><span class="line">  dependent.didChangeDependencies();<span class="comment">//生命周期回调方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="updateShouldNotify"><a href="#updateShouldNotify" class="headerlink" title="updateShouldNotify"></a>updateShouldNotify</h3><p>控制依赖于InheritedWidget的组件是否需要重建。如果为true，则当InheritedWidget发生变化时，依赖于它的组件会被rebuild，其Element的didChangeDependencies会被调用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/6943515602191384613">InheritedWidget的使用和源码分析</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;相关API&quot;&gt;&lt;a href=&quot;#相关API&quot; class=&quot;headerlink&quot; title=&quot;相关API&quot;&gt;&lt;/a&gt;相关API&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;InheritedWidget&lt;/li&gt;
&lt;li&gt;ProxyWidget&lt;/li&gt;
&lt;li&gt;Inheri</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>PaintingContext</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/PaintingContext/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/PaintingContext/</id>
    <published>2024-07-25T13:33:15.216Z</published>
    <updated>2024-07-25T13:33:15.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/PaintingContext/PaintingContext_1.png"></p><ul><li>继承自ClipContext，提供裁剪相关辅助方法</li><li>PictureLayer _currentLayer、_recorder、_canvas用于具体的绘制操作</li><li>ContainerLayer _containerLayer, Layer树的根节点</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><p>Canvas是 Engine(C++) 层到 Framework(Dart) 层的桥接，真正的功能在 Engine 层实现。Canvas 向 Framework 层曝露了与绘制相关的基础接口，如：draw<em>、clip</em>、transform以及scale等，RenderObject 正是通过这些基础接口完成绘制任务的。</p><blockquote><p>通过这套接口进行的所有操作都将被PictureRecorder记录下来。</p></blockquote><p>除了正常的绘制操作(draw*)，Canvas 还支持矩阵变换(transformation matrix)、区域裁剪(clip region)，它们将作用于其后在该 Canvas 上进行的所有绘制操作。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> scale(<span class="built_in">double</span> sx, [<span class="built_in">double</span> sy]);</span><br><span class="line"><span class="keyword">void</span> rotate(<span class="built_in">double</span> radians) native;</span><br><span class="line"><span class="keyword">void</span> transform(Float64List matrix4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> clipRect(Rect rect, &#123; ClipOp clipOp = ClipOp.intersect, <span class="built_in">bool</span> doAntiAlias = <span class="keyword">true</span> &#125;);</span><br><span class="line"><span class="keyword">void</span> clipPath(Path path, &#123;<span class="built_in">bool</span> doAntiAlias = <span class="keyword">true</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> drawColor(Color color, BlendMode blendMode);</span><br><span class="line"><span class="keyword">void</span> drawLine(Offset p1, Offset p2, Paint paint);</span><br><span class="line"><span class="keyword">void</span> drawRect(Rect rect, Paint paint);</span><br><span class="line"><span class="keyword">void</span> drawCircle(Offset c, <span class="built_in">double</span> radius, Paint paint);</span><br><span class="line"><span class="keyword">void</span> drawImage(Image image, Offset p, Paint paint);</span><br><span class="line"><span class="keyword">void</span> drawParagraph(Paragraph paragraph, Offset offset);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Picture"><a href="#Picture" class="headerlink" title="Picture"></a>Picture</h3><p>其本质是一系列「graphical operations」的集合，对 Framework 层透明。<br>Future<Image> toImage(int width, int height)，通过toImage方法可以将其记录的所有操作经光栅化后生成Image对象。</Image></p><h3 id="PictureRecorder"><a href="#PictureRecorder" class="headerlink" title="PictureRecorder"></a>PictureRecorder</h3><p>其主要作用是记录在Canvas上执行的「graphical operations」，通过Picture#endRecording最终生成Picture。</p><h3 id="Scene"><a href="#Scene" class="headerlink" title="Scene"></a>Scene</h3><p>一系列 Picture、Texture 合成的结果。UI 帧刷新时，在 Rendering Pipeline 中 Flutter UI 经 build、layout、paint 等步骤后最终生成 Scene。<br>其后通过window.render将该 Scene 送入 Engine 层，最终经 GPU 光栅化后显示在屏幕上。</p><h3 id="SceneBuilder"><a href="#SceneBuilder" class="headerlink" title="SceneBuilder"></a>SceneBuilder</h3><p>用于将多个图层(Layer)、Picture、Texture 合成为 Scene。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  PictureRecorder recorder = PictureRecorder();</span><br><span class="line">  <span class="comment">// 初始化 Canvas 时，传入 PictureRecorder 实例</span></span><br><span class="line">  <span class="comment">// 用于记录发生在该 canvas 上的所有操作</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  Canvas canvas = Canvas(recorder);</span><br><span class="line"></span><br><span class="line">  Paint circlePaint= Paint();</span><br><span class="line">  circlePaint.color = Colors.blueAccent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 Canvas 的绘制接口，画一个圆形</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  canvas.drawCircle(Offset(<span class="number">400</span>, <span class="number">400</span>), <span class="number">300</span>, circlePaint);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绘制结束，生成Picture</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  Picture picture = recorder.endRecording();</span><br><span class="line"></span><br><span class="line">  SceneBuilder sceneBuilder = SceneBuilder();</span><br><span class="line">  sceneBuilder.pushOffset(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 将 picture 送入 SceneBuilder</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  sceneBuilder.addPicture(Offset(<span class="number">0</span>, <span class="number">0</span>), picture);</span><br><span class="line">  sceneBuilder.pop();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成 Scene</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  Scene scene = sceneBuilder.build();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.onDrawFrame = () &#123;</span><br><span class="line">    <span class="comment">// 将 scene 送入 Engine 层进行渲染显示</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">window</span>.render(scene);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">window</span>.scheduleFrame();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="PaintingContext"><a href="#PaintingContext" class="headerlink" title="PaintingContext"></a>PaintingContext</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintingContext</span> <span class="keyword">extends</span> <span class="title">ClipContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  PaintingContext(<span class="keyword">this</span>._containerLayer, <span class="keyword">this</span>.estimatedBounds);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ContainerLayer _containerLayer;<span class="comment">//Layer树的根节点</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Rect estimatedBounds;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> repaintCompositedChild(RenderObject child, &#123; <span class="built_in">bool</span> debugAlsoPaintedParent = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">    _repaintCompositedChild(</span><br><span class="line">      child,</span><br><span class="line">      debugAlsoPaintedParent: debugAlsoPaintedParent,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _repaintCompositedChild(</span><br><span class="line">    RenderObject child, &#123;</span><br><span class="line">    <span class="built_in">bool</span> debugAlsoPaintedParent = <span class="keyword">false</span>,</span><br><span class="line">    PaintingContext? childContext,</span><br><span class="line">  &#125;) &#123;</span><br><span class="line">    OffsetLayer? childLayer = child._layerHandle.layer <span class="keyword">as</span> OffsetLayer?;</span><br><span class="line">    <span class="keyword">if</span> (childLayer == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">final</span> OffsetLayer layer = child.updateCompositedLayer(oldLayer: <span class="keyword">null</span>);<span class="comment">//创建layer</span></span><br><span class="line">      child._layerHandle.layer = childLayer = layer;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Offset? debugOldOffset;</span><br><span class="line">      childLayer.removeAllChildren();</span><br><span class="line">      <span class="keyword">final</span> OffsetLayer updatedLayer = child.updateCompositedLayer(oldLayer: childLayer);</span><br><span class="line">    &#125;</span><br><span class="line">    child._needsCompositedLayerUpdate = <span class="keyword">false</span>;</span><br><span class="line">    childContext ??= PaintingContext(childLayer, child.paintBounds);</span><br><span class="line">    child._paintWithContext(childContext, Offset.zero);</span><br><span class="line"></span><br><span class="line">    childContext.stopRecordingIfNeeded();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> updateLayerProperties(RenderObject child) &#123;</span><br><span class="line">    <span class="keyword">final</span> OffsetLayer childLayer = child._layerHandle.layer! <span class="keyword">as</span> OffsetLayer;</span><br><span class="line">    Offset? debugOldOffset;</span><br><span class="line">    <span class="keyword">final</span> OffsetLayer updatedLayer = child.updateCompositedLayer(oldLayer: childLayer);</span><br><span class="line">    child._needsCompositedLayerUpdate = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> debugInstrumentRepaintCompositedChild(</span><br><span class="line">    RenderObject child, &#123;</span><br><span class="line">    <span class="built_in">bool</span> debugAlsoPaintedParent = <span class="keyword">false</span>,</span><br><span class="line">    <span class="keyword">required</span> PaintingContext customContext,</span><br><span class="line">  &#125;) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> paintChild(RenderObject child, Offset offset) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.isRepaintBoundary) &#123;</span><br><span class="line">      stopRecordingIfNeeded();</span><br><span class="line">      _compositeChild(child, offset);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child._wasRepaintBoundary) &#123;</span><br><span class="line">      child._layerHandle.layer = <span class="keyword">null</span>;</span><br><span class="line">      child._paintWithContext(<span class="keyword">this</span>, offset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      child._paintWithContext(<span class="keyword">this</span>, offset);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _compositeChild(RenderObject child, Offset offset) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a layer for our child, and paint the child into it.</span></span><br><span class="line">    <span class="keyword">if</span> (child._needsPaint || !child._wasRepaintBoundary) &#123;</span><br><span class="line">      repaintCompositedChild(child, debugAlsoPaintedParent: <span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (child._needsCompositedLayerUpdate) &#123;</span><br><span class="line">        updateLayerProperties(child);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> OffsetLayer childOffsetLayer = child._layerHandle.layer! <span class="keyword">as</span> OffsetLayer;</span><br><span class="line">    childOffsetLayer.offset = offset;</span><br><span class="line">    appendLayer(childOffsetLayer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="keyword">void</span> appendLayer(Layer layer) &#123;</span><br><span class="line">    layer.remove();</span><br><span class="line">    _containerLayer.append(layer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> _isRecording &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span> hasCanvas = _canvas != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> hasCanvas;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// <span class="language-markdown">用于具体的绘制操作</span></span></span><br><span class="line">  PictureLayer? _currentLayer;</span><br><span class="line">  ui.PictureRecorder? _recorder;</span><br><span class="line">  Canvas? _canvas;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Canvas <span class="keyword">get</span> canvas &#123;</span><br><span class="line">    <span class="keyword">if</span> (_canvas == <span class="keyword">null</span>) &#123;</span><br><span class="line">      _startRecording();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _canvas!;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> _startRecording() &#123;</span><br><span class="line">    _currentLayer = PictureLayer(estimatedBounds);</span><br><span class="line">    _recorder = ui.PictureRecorder();</span><br><span class="line">    _canvas = Canvas(_recorder!);</span><br><span class="line">    _containerLayer.append(_currentLayer!);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  VoidCallback addCompositionCallback(CompositionCallback callback) &#123;</span><br><span class="line">    <span class="keyword">return</span> _containerLayer.addCompositionCallback(callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  <span class="meta">@mustCallSuper</span></span><br><span class="line">  <span class="keyword">void</span> stopRecordingIfNeeded() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_isRecording) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _currentLayer!.picture = _recorder!.endRecording();</span><br><span class="line">    _currentLayer = <span class="keyword">null</span>;</span><br><span class="line">    _recorder = <span class="keyword">null</span>;</span><br><span class="line">    _canvas = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> setIsComplexHint() &#123;</span><br><span class="line">    _currentLayer?.isComplexHint = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> setWillChangeHint() &#123;</span><br><span class="line">    _currentLayer?.willChangeHint = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> addLayer(Layer layer) &#123;</span><br><span class="line">    stopRecordingIfNeeded();</span><br><span class="line">    appendLayer(layer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> pushLayer(ContainerLayer childLayer, PaintingContextCallback painter, Offset offset, &#123; Rect? childPaintBounds &#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (childLayer.hasChildren) &#123;</span><br><span class="line">      childLayer.removeAllChildren();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在 append sub layer 前先终止现有的绘制操作</span></span><br><span class="line">    <span class="comment">// stopRecordingIfNeeded 所执行的操作见上文</span></span><br><span class="line">    stopRecordingIfNeeded();</span><br><span class="line">    appendLayer(childLayer);</span><br><span class="line">      <span class="comment">// 为 childLayer 创建新的 PaintingContext，以便独立进行绘制操作</span></span><br><span class="line">    <span class="keyword">final</span> PaintingContext childContext = createChildContext(childLayer, childPaintBounds ?? estimatedBounds);</span><br><span class="line"></span><br><span class="line">    painter(childContext, offset);</span><br><span class="line">    childContext.stopRecordingIfNeeded();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@protected</span></span><br><span class="line">  PaintingContext createChildContext(ContainerLayer childLayer, Rect bounds) &#123;</span><br><span class="line">    <span class="keyword">return</span> PaintingContext(childLayer, bounds);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ClipRectLayer? pushClipRect(<span class="built_in">bool</span> needsCompositing, Offset offset, Rect clipRect, PaintingContextCallback painter, &#123; Clip clipBehavior = Clip.hardEdge, ClipRectLayer? oldLayer &#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (clipBehavior == Clip.none) &#123;</span><br><span class="line">      painter(<span class="keyword">this</span>, offset);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Rect offsetClipRect = clipRect.shift(offset);</span><br><span class="line">    <span class="keyword">if</span> (needsCompositing) &#123;</span><br><span class="line">      <span class="keyword">final</span> ClipRectLayer layer = oldLayer ?? ClipRectLayer();</span><br><span class="line">      layer</span><br><span class="line">        ..clipRect = offsetClipRect</span><br><span class="line">        ..clipBehavior = clipBehavior;</span><br><span class="line">      pushLayer(layer, painter, offset, childPaintBounds: offsetClipRect);</span><br><span class="line">      <span class="keyword">return</span> layer;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      clipRectAndPaint(offsetClipRect, clipBehavior, offsetClipRect, () =&gt; painter(<span class="keyword">this</span>, offset));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ClipRRectLayer? pushClipRRect(<span class="built_in">bool</span> needsCompositing, Offset offset, Rect bounds, RRect clipRRect, PaintingContextCallback painter, &#123; Clip clipBehavior = Clip.antiAlias, ClipRRectLayer? oldLayer &#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (clipBehavior == Clip.none) &#123;</span><br><span class="line">      painter(<span class="keyword">this</span>, offset);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Rect offsetBounds = bounds.shift(offset);</span><br><span class="line">    <span class="keyword">final</span> RRect offsetClipRRect = clipRRect.shift(offset);</span><br><span class="line">    <span class="keyword">if</span> (needsCompositing) &#123;</span><br><span class="line">      <span class="keyword">final</span> ClipRRectLayer layer = oldLayer ?? ClipRRectLayer();</span><br><span class="line">      layer</span><br><span class="line">        ..clipRRect = offsetClipRRect</span><br><span class="line">        ..clipBehavior = clipBehavior;</span><br><span class="line">      pushLayer(layer, painter, offset, childPaintBounds: offsetBounds);</span><br><span class="line">      <span class="keyword">return</span> layer;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      clipRRectAndPaint(offsetClipRRect, clipBehavior, offsetBounds, () =&gt; painter(<span class="keyword">this</span>, offset));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ClipPathLayer? pushClipPath(<span class="built_in">bool</span> needsCompositing, Offset offset, Rect bounds, Path clipPath, PaintingContextCallback painter, &#123; Clip clipBehavior = Clip.antiAlias, ClipPathLayer? oldLayer &#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (clipBehavior == Clip.none) &#123;</span><br><span class="line">      painter(<span class="keyword">this</span>, offset);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Rect offsetBounds = bounds.shift(offset);</span><br><span class="line">    <span class="keyword">final</span> Path offsetClipPath = clipPath.shift(offset);</span><br><span class="line">    <span class="keyword">if</span> (needsCompositing) &#123;</span><br><span class="line">      <span class="keyword">final</span> ClipPathLayer layer = oldLayer ?? ClipPathLayer();</span><br><span class="line">      layer</span><br><span class="line">        ..clipPath = offsetClipPath</span><br><span class="line">        ..clipBehavior = clipBehavior;</span><br><span class="line">      pushLayer(layer, painter, offset, childPaintBounds: offsetBounds);</span><br><span class="line">      <span class="keyword">return</span> layer;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      clipPathAndPaint(offsetClipPath, clipBehavior, offsetBounds, () =&gt; painter(<span class="keyword">this</span>, offset));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ColorFilterLayer pushColorFilter(Offset offset, ColorFilter colorFilter, PaintingContextCallback painter, &#123; ColorFilterLayer? oldLayer &#125;) &#123;</span><br><span class="line">    <span class="keyword">final</span> ColorFilterLayer layer = oldLayer ?? ColorFilterLayer();</span><br><span class="line">    layer.colorFilter = colorFilter;</span><br><span class="line">    pushLayer(layer, painter, offset);</span><br><span class="line">    <span class="keyword">return</span> layer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  TransformLayer? pushTransform(<span class="built_in">bool</span> needsCompositing, Offset offset, Matrix4 transform, PaintingContextCallback painter, &#123; TransformLayer? oldLayer &#125;) &#123;</span><br><span class="line">    <span class="keyword">final</span> Matrix4 effectiveTransform = Matrix4.translationValues(offset.dx, offset.dy, <span class="number">0.0</span>)</span><br><span class="line">      ..multiply(transform)..translate(-offset.dx, -offset.dy);</span><br><span class="line">    <span class="keyword">if</span> (needsCompositing) &#123;</span><br><span class="line">      <span class="keyword">final</span> TransformLayer layer = oldLayer ?? TransformLayer();</span><br><span class="line">      layer.transform = effectiveTransform;</span><br><span class="line">      pushLayer(</span><br><span class="line">        layer,</span><br><span class="line">        painter,</span><br><span class="line">        offset,</span><br><span class="line">        childPaintBounds: MatrixUtils.inverseTransformRect(effectiveTransform, estimatedBounds),</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span> layer;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      canvas</span><br><span class="line">        ..save()</span><br><span class="line">        ..transform(effectiveTransform.storage);</span><br><span class="line">      painter(<span class="keyword">this</span>, offset);</span><br><span class="line">      canvas.restore();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  OpacityLayer pushOpacity(Offset offset, <span class="built_in">int</span> alpha, PaintingContextCallback painter, &#123; OpacityLayer? oldLayer &#125;) &#123;</span><br><span class="line">    <span class="keyword">final</span> OpacityLayer layer = oldLayer ?? OpacityLayer();</span><br><span class="line">    layer</span><br><span class="line">      ..alpha = alpha</span><br><span class="line">      ..offset = offset;</span><br><span class="line">    pushLayer(layer, painter, Offset.zero);</span><br><span class="line">    <span class="keyword">return</span> layer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">String</span> toString() =&gt; <span class="string">&#x27;<span class="subst">$&#123;objectRuntimeType(<span class="keyword">this</span>, <span class="string">&#x27;PaintingContext&#x27;</span>)&#125;</span>#<span class="subst">$hashCode</span>(layer: <span class="subst">$_containerLayer</span>, canvas bounds: <span class="subst">$estimatedBounds</span>)&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绘制流程"><a href="#绘制流程" class="headerlink" title="绘制流程"></a>绘制流程</h2><p><img src="/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/PaintingContext/RenderObject_2.png"></p><h2 id="Compositing"><a href="#Compositing" class="headerlink" title="Compositing"></a>Compositing</h2><p>Compositing，合成，属于 Rendering Pipeline 中的一环，表示是否要生成新的 Layer 来实现某些特定的图形效果</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zxfcumtcs.github.io/2020/05/23/deepinto-flutter-paintingcontext/">深入浅出 Flutter Framework 之 PaintingContext</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/PaintingC</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Layout过程</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Layout%E8%BF%87%E7%A8%8B/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Layout%E8%BF%87%E7%A8%8B/</id>
    <published>2024-07-25T13:33:15.216Z</published>
    <updated>2024-07-25T15:04:04.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h3><p>markNeedsLayout方法会将当前节点标记为需要Layout。markNeedsLayout方法在很多地方都会被触发，比如UI的高宽发生变化，字体属性发生变化等。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> </span>&#123;</span><br><span class="line"> <span class="keyword">void</span> markNeedsLayout() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_needsLayout) &#123;<span class="comment">//已经标记过</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_relayoutBoundary == <span class="keyword">null</span>) &#123;<span class="comment">//当前节点不是布局边界，父节点受此影响，也需要被标记</span></span><br><span class="line">      _needsLayout = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        markParentNeedsLayout();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">this</span>) &#123;</span><br><span class="line">      markParentNeedsLayout();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      _needsLayout = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (owner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        owner!._nodesNeedingLayout.add(<span class="keyword">this</span>);</span><br><span class="line">        owner!.requestVisualUpdate();<span class="comment">//请求刷新</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> markParentNeedsLayout() &#123;</span><br><span class="line">    _needsLayout = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> RenderObject parent = <span class="keyword">this</span>.parent! <span class="keyword">as</span> RenderObject;</span><br><span class="line">    <span class="keyword">if</span> (!_doingThisLayoutWithCallback) &#123;</span><br><span class="line">      parent.markNeedsLayout();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Flush阶段"><a href="#Flush阶段" class="headerlink" title="Flush阶段"></a>Flush阶段</h3><p>Layout开始于drawFrame的flushLayout，Layout过程也跟Build类似，先标记再处理。Layout是相对Render Tree而言的</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PipelineOwner</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> flushLayout() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (_nodesNeedingLayout.isNotEmpty) &#123;<span class="comment">//存在需要更新Layout信息的节点</span></span><br><span class="line">        <span class="keyword">final</span> <span class="built_in">List</span>&lt;RenderObject&gt; dirtyNodes = _nodesNeedingLayout;</span><br><span class="line">        _nodesNeedingLayout = &lt;RenderObject&gt;[];</span><br><span class="line">        dirtyNodes.sort((RenderObject a, RenderObject b) =&gt; a.depth - b.depth);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; dirtyNodes.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (_shouldMergeDirtyNodes) &#123;</span><br><span class="line">            _shouldMergeDirtyNodes = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (_nodesNeedingLayout.isNotEmpty) &#123;</span><br><span class="line">              _nodesNeedingLayout.addAll(dirtyNodes.getRange(i, dirtyNodes.length));</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">final</span> RenderObject node = dirtyNodes[i];</span><br><span class="line">          <span class="keyword">if</span> (node._needsLayout &amp;&amp; node.owner == <span class="keyword">this</span>) &#123;</span><br><span class="line">            node._layoutWithoutResize();<span class="comment">//真正的Layout逻辑</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _shouldMergeDirtyNodes = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> PipelineOwner child <span class="keyword">in</span> _children) &#123;<span class="comment">//更新子节点</span></span><br><span class="line">        child.flushLayout();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      _shouldMergeDirtyNodes = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> _layoutWithoutResize() &#123;</span><br><span class="line">    RenderObject? debugPreviousActiveLayout;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      performLayout();<span class="comment">//用于开始具体的Layout逻辑，这个方法中会调用markNeedsPaint进行标记需要进行paint</span></span><br><span class="line">      markNeedsSemanticsUpdate();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      _reportException(<span class="string">&#x27;performLayout&#x27;</span>, e, stack);</span><br><span class="line">    &#125;</span><br><span class="line">    _needsLayout = <span class="keyword">false</span>;</span><br><span class="line">    markNeedsPaint();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><p>drawFrame–&gt;flushLayout–&gt;performLayout–&gt;markNeedsPaint</p><h3 id="具体示例"><a href="#具体示例" class="headerlink" title="具体示例"></a>具体示例</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> performLayout() &#123;</span><br><span class="line">    _size = configuration.size;</span><br><span class="line">    <span class="keyword">if</span> (child != <span class="keyword">null</span>) &#123;</span><br><span class="line">      child!.layout(BoxConstraints.tight(_size));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> layout(Constraints constraints, &#123; <span class="built_in">bool</span> parentUsesSize = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!kReleaseMode &amp;&amp; debugProfileLayoutsEnabled) &#123;</span><br><span class="line">      <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;? debugTimelineArguments;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span> isRelayoutBoundary = !parentUsesSize || sizedByParent || constraints.isTight || parent <span class="keyword">is</span>! RenderObject;</span><br><span class="line">    <span class="keyword">final</span> RenderObject relayoutBoundary = isRelayoutBoundary ? <span class="keyword">this</span> : (parent! <span class="keyword">as</span> RenderObject)._relayoutBoundary!;</span><br><span class="line">    <span class="keyword">if</span> (!_needsLayout &amp;&amp; constraints == _constraints) &#123;</span><br><span class="line">      <span class="keyword">if</span> (relayoutBoundary != _relayoutBoundary) &#123;</span><br><span class="line">        _relayoutBoundary = relayoutBoundary;</span><br><span class="line">        visitChildren(_propagateRelayoutBoundaryToChild);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _constraints = constraints;</span><br><span class="line">    <span class="keyword">if</span> (_relayoutBoundary != <span class="keyword">null</span> &amp;&amp; relayoutBoundary != _relayoutBoundary) &#123;</span><br><span class="line">      visitChildren(_cleanChildRelayoutBoundary);</span><br><span class="line">    &#125;</span><br><span class="line">    _relayoutBoundary = relayoutBoundary;</span><br><span class="line">    <span class="keyword">if</span> (sizedByParent) &#123;<span class="comment">//子节点大小完全取决于父节点</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        performResize();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RenderObject? debugPreviousActiveLayout;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      performLayout();<span class="comment">//子节点自身实现布局逻辑</span></span><br><span class="line">      markNeedsSemanticsUpdate();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e, stack) &#123;</span><br><span class="line">      _reportException(<span class="string">&#x27;performLayout&#x27;</span>, e, stack);</span><br><span class="line">    &#125;</span><br><span class="line">    _needsLayout = <span class="keyword">false</span>;</span><br><span class="line">    markNeedsPaint();<span class="comment">//标记当前节点需要重绘</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="布局过程"><a href="#布局过程" class="headerlink" title="布局过程"></a>布局过程</h3><ol><li>父节点向子节点传递约束（constraints）信息，限制子节点的最大和最小宽高。</li><li>子节点根据约束信息确定自己的大小。</li><li>父节点根据特定布局规则确定每一个子节点在父节点布局控件中的位置，用偏移offset表示。</li><li>递归整个过程，确定出每一个节点的大小和位置。</li></ol><h3 id="layout流程"><a href="#layout流程" class="headerlink" title="layout流程"></a>layout流程</h3><ol><li>确定当前组件的布局边界。</li><li>判断是否需要重新布局，如果没必要会直接返回，反之才需要重新布局。不需要布局要同时满足以下三个条件：<ol><li>当前组件没有被标记为需要重新布局。</li><li>父组件传递的约束没有发生变化。</li><li>当前组件的布局边界没有发生变化。</li></ol></li><li>调用performLayout进行布局，其内部会调用子组件的layout方法。</li><li>请求绘制。</li></ol><h3 id="performLayout流程"><a href="#performLayout流程" class="headerlink" title="performLayout流程"></a>performLayout流程</h3><ol><li>如果有子组件，则对子组件进行递归布局。</li><li>确定当前组件的大小，通常会依赖子组件的大小。</li><li>确定子组件在当前组件中的起始偏移。</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="keyword">void</span> layout(Constraints constraints, &#123; <span class="built_in">bool</span> parentUsesSize = <span class="keyword">false</span> &#125;) &#123;</span><br><span class="line">  RenderObject? relayoutBoundary;</span><br><span class="line">  <span class="comment">// 先确定当前组件的布局边界</span></span><br><span class="line">  <span class="keyword">if</span> (!parentUsesSize || sizedByParent || constraints.isTight || parent <span class="keyword">is</span>! RenderObject) &#123;</span><br><span class="line">    relayoutBoundary = <span class="keyword">this</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    relayoutBoundary = (parent! <span class="keyword">as</span> RenderObject)._relayoutBoundary;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// _needsLayout 表示当前组件是否被标记为需要布局</span></span><br><span class="line">  <span class="comment">// _constraints 是上次布局时父组件传递给当前组件的约束</span></span><br><span class="line">  <span class="comment">// _relayoutBoundary 为上次布局时当前组件的布局边界</span></span><br><span class="line">  <span class="comment">// 所以，当当前组件没有被标记为需要重新布局，且父组件传递的约束没有发生变化，</span></span><br><span class="line">  <span class="comment">// 且布局边界也没有发生变化时则不需要重新布局，直接返回即可。</span></span><br><span class="line">  <span class="keyword">if</span> (!_needsLayout &amp;&amp; constraints == _constraints &amp;&amp; relayoutBoundary == _relayoutBoundary) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果需要布局，缓存约束和布局边界</span></span><br><span class="line">  _constraints = constraints;</span><br><span class="line">  _relayoutBoundary = relayoutBoundary;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sizedByParent表示当前的Widget虽然不是isTight，但是通过其他约束属性，也可以明确的知道size，比如Expanded，并不一定需要明确的size</span></span><br><span class="line">  <span class="keyword">if</span> (sizedByParent) &#123;</span><br><span class="line">    performResize();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行布局</span></span><br><span class="line">  performLayout();</span><br><span class="line">  <span class="comment">// 布局结束后将 _needsLayout 置为 false</span></span><br><span class="line">  _needsLayout = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">// 将当前组件标记为需要重绘（因为布局发生变化后，需要重新绘制）</span></span><br><span class="line">  markNeedsPaint();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="命中测试"><a href="#命中测试" class="headerlink" title="命中测试"></a>命中测试</h2><p>命中测试用来判断某个组件是否需要响应一个点击事件，其入口是RenderObject Tree的根节点RenderView的hitTest函数</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> hitTest(HitTestResult result, &#123; Offset position &#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">    child.hitTest(BoxHitTestResult.wrap(result), position: position);<span class="comment">//child为RenderView</span></span><br><span class="line">  result.add(HitTestEntry(<span class="keyword">this</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看RenderView源码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> hitTest(BoxHitTestResult result, &#123; <span class="meta">@required</span> Offset position &#125;) &#123;</span><br><span class="line">  <span class="keyword">if</span> (_size.contains(position)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hitTestChildren(result, position: position) || hitTestSelf(position)) &#123;</span><br><span class="line">      result.add(BoxHitTestEntry(<span class="keyword">this</span>, position));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果点击事件位置处于RenderObject之内，如果在其内，并且hitTestSelf或者hitTestChildren返回true，则表示RenderObject通过了命中测试，需要响应事件，此时需要将被点击的RenderObject加入BoxHitTestResult列表，同时点击事件不再向下传递。否则认为没有通过命中测试，事件继续向下传递。其中，hitTestSelf函数表示节点是否通过命中测试，hitTestChildren表示子节点是否通过命中测试。</p><ol><li>父节点向子节点传递约束（constraints）信息，限制子节点的最大和最小宽高。</li><li>子节点根据约束信息确定自己的大小（size）。</li><li>父节点根据特定布局规则（不同布局组件会有不同的布局算法）确定每一个子节点在父节点布局空间中的位置，用偏移 offset 表示。</li><li>递归整个过程，确定出每一个节点的大小和位置。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;过程&quot;&gt;&lt;a href=&quot;#过程&quot; class=&quot;headerlink&quot; title=&quot;过程&quot;&gt;&lt;/a&gt;过程&lt;/h2&gt;&lt;h3 id=&quot;标记阶段&quot;&gt;&lt;a href=&quot;#标记阶段&quot; class=&quot;headerlink&quot; title=&quot;标记阶段&quot;&gt;&lt;/a&gt;标记阶段&lt;/h</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="源码分析" scheme="http://airshu.github.io/categories/Flutter/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Key、ValueKey、ObjectKey、UniqueKey、PageStorageKey、GlobalKey</title>
    <link href="http://airshu.github.io/wiki/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/framework/Key/"/>
    <id>http://airshu.github.io/wiki/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/framework/Key/</id>
    <published>2024-07-25T13:33:15.214Z</published>
    <updated>2024-07-25T13:33:15.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Key的分类</p><ul><li>ValueKey:以一个值为key。</li><li>ObjectKey:以一个对象为key。</li><li>UniqueKey:生成唯一的随机数作为key。</li><li>PageStorageKey:专用于存储页面滚动位置的key。</li><li>GlobalKey:整个应用内唯一的key，有以下属性<ul><li>currentContext: 可以找到包括renderBox在内的各种element有关的东西</li><li>currentWidget: 可以得到widget的属性</li><li>currentState: 可以得到state里面的变量.</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Key的分类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ValueKey:以一个值为key。&lt;/li&gt;
&lt;li&gt;ObjectKey:以一个对象为key。&lt;/</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="UI" scheme="http://airshu.github.io/categories/Flutter/UI/"/>
    
    <category term="标准库" scheme="http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
    <category term="widgets" scheme="http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/"/>
    
    <category term="framework" scheme="http://airshu.github.io/categories/Flutter/UI/%E6%A0%87%E5%87%86%E5%BA%93/widgets/framework/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>setState具体做了什么</title>
    <link href="http://airshu.github.io/wiki/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/setState%E5%85%B7%E4%BD%93%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://airshu.github.io/wiki/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/setState%E5%85%B7%E4%BD%93%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2024-07-25T13:33:15.214Z</published>
    <updated>2024-07-25T15:27:10.316Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/wiki/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/setState%E5%85%B7%E4%BD%93%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/lifecycle_1.png"></p><h2 id="setState流程"><a href="#setState流程" class="headerlink" title="setState流程"></a>setState流程</h2><ol><li>标脏，将对应element添加到dirtyElement队列中</li><li>触发vsync</li><li>下一帧drawFrame</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> drawFrame() &#123;</span><br><span class="line">  <span class="comment">//WidgetBinding</span></span><br><span class="line">  buildOwner!.buildScope(renderViewElement!); <span class="comment">//重新构建widget树</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//RenderBinding</span></span><br><span class="line">  pipelineOwner.flushLayout(); <span class="comment">// 更新布局</span></span><br><span class="line">  pipelineOwner.flushCompositingBits(); <span class="comment">//更新合成信息</span></span><br><span class="line">  pipelineOwner.flushPaint(); <span class="comment">// 更新绘制</span></span><br><span class="line">  <span class="keyword">if</span> (sendFramesToEngine) &#123;</span><br><span class="line">    renderView.compositeFrame(); <span class="comment">// 上屏，会将绘制出的bit数据发送给GPU</span></span><br><span class="line">    pipelineOwner.flushSemantics(); <span class="comment">// this also sends the semantics to the OS.</span></span><br><span class="line">    _firstFrameSent = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>buildScope<ul><li>rebuild<ul><li>performRebuild<ul><li>didChangeDependencies</li><li>build</li></ul></li></ul></li></ul></li></ul><h3 id="updateChild"><a href="#updateChild" class="headerlink" title="updateChild"></a>updateChild</h3><p>调用setState()之后，它所有的子节点调用updateChild(Element child, Widget newWidget, dynamic newSlot)：</p><ul><li>如果之前的位置child为null<ul><li>如果newWidget为null的话，说明这个位置始终没有子节点，直接返回null即可。</li><li>如果newWidget不为null，说明这个位置新增加了子节点调用inflateWidget(newWidget, newSlot)生成一个新的Element返回</li></ul></li><li>如果之前的child不为null<ul><li>如果newWidget为null的话，说明这个位置需要移除以前的节点，调用deactivateChild(child)移除并且返回nullD、如果newWidget不为null的话，先调用Widget.canUpdate(child.widget, newWidget)对比是否能更新。这个方法会对比两个Widget的runtimeType和key，<ol><li>如果一致则说明子Widget没有改变，只是需要根据newWidget(配置清单)更新下当前节点的数据child.update(newWidget)；</li><li>如果不一致说明这个位置发生变化，则<strong>deactivateChild(child)<strong>后返回</strong>inflateWidget(newWidget, newSlot)</strong>;</li></ol></li></ul></li></ul><h3 id="GlobalKey"><a href="#GlobalKey" class="headerlink" title="GlobalKey"></a>GlobalKey</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/6908574202253541389">面试官问我State的生命周期，该怎么回答</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/wiki/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/setState%E5%85%B7%E4%BD%93%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/lifecycle_1.png&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Flutter" scheme="http://airshu.github.io/categories/Flutter/"/>
    
    <category term="未分类" scheme="http://airshu.github.io/categories/Flutter/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
    <category term="Flutter" scheme="http://airshu.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>酒</title>
    <link href="http://airshu.github.io/wiki/%E9%9A%8F%E7%AC%94/%E9%85%92/"/>
    <id>http://airshu.github.io/wiki/%E9%9A%8F%E7%AC%94/%E9%85%92/</id>
    <published>2024-07-21T01:55:46.181Z</published>
    <updated>2024-07-21T01:55:46.181Z</updated>
    
    <content type="html"><![CDATA[<p>不记得从什么时候开始喜欢上了酒，虽然酒量还是一般，但是喜欢上了酒的味道，喜欢上了微醺的感觉。</p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="酱香"><a href="#酱香" class="headerlink" title="酱香"></a>酱香</h2><h2 id="浓香"><a href="#浓香" class="headerlink" title="浓香"></a>浓香</h2><h2 id="清香"><a href="#清香" class="headerlink" title="清香"></a>清香</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不记得从什么时候开始喜欢上了酒，虽然酒量还是一般，但是喜欢上了酒的味道，喜欢上了微醺的感觉。&lt;/p&gt;
&lt;h2 id&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h2 id=&quot;酱香&quot;&gt;&lt;a href=&quot;#酱香&quot; class=&quot;</summary>
      
    
    
    
    <category term="随笔" scheme="http://airshu.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>TypeScript入门</title>
    <link href="http://airshu.github.io/wiki/JavaScript/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://airshu.github.io/wiki/JavaScript/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-07-21T01:55:46.180Z</published>
    <updated>2024-07-21T01:55:46.180Z</updated>
    
    <content type="html"><![CDATA[<p>在JavaScript的基础上添加了类型系统，可以在编译时检查类型，提高代码的可读性和可维护性。</p><p>约定使用 TypeScript 编写的文件以 .ts 为后缀，用 TypeScript 编写 React 时，以 .tsx 为后缀。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">全局安装typescript</span></span><br><span class="line">npm install -g typescript</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">编译</span></span><br><span class="line">tsc xxx.ts</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">运行</span></span><br><span class="line">node xxx.js</span><br></pre></td></tr></table></figure><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>JavaScript的类型分为：</p><ul><li>原始数据类型：布尔值、数值、字符串、null、undeined、Symbol、BigInt</li><li>对象类型<ul><li>接口</li><li>数组</li></ul></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">x</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">y</span>: <span class="built_in">string</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">z</span>: <span class="built_in">number</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: <span class="built_in">bigint</span> = <span class="number">123n</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="attr">c</span>: <span class="built_in">object</span> = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">d</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span>;<span class="comment">//表示为定义，以后可能会有定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">d</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="string">&#x27;hello&#x27;</span>; <span class="comment">//值类型</span></span><br><span class="line"></span><br><span class="line">x = <span class="string">&#x27;hello&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="string">&#x27;world&#x27;</span>; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>:<span class="built_in">string</span>|<span class="built_in">number</span>; <span class="comment">//联合类型</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">123</span>; <span class="comment">// 正确</span></span><br><span class="line">x = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交叉类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>:</span><br><span class="line">  &#123; <span class="attr">foo</span>: <span class="built_in">string</span> &#125; &amp;</span><br><span class="line">  &#123; <span class="attr">bar</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"></span><br><span class="line">obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="string">&#x27;world&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A = &#123; <span class="attr">foo</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = A &amp; &#123; <span class="attr">bar</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>:<span class="title class_">Age</span> = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#x27;hello&#x27; // 字面量</span></span><br><span class="line"><span class="comment">// new String(&#x27;hello&#x27;) // 包装对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 接口</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口类型</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>; <span class="comment">//?表示可选属性</span></span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="built_in">number</span>; <span class="comment">//只读属性</span></span><br><span class="line">  [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">//任意属性，TypeScript 实际上会关闭这个变量的类型检查。即使有明显的类型错误，只要句法正确，都不会报错</span></span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">unknown</span>; <span class="comment">//未知类型，为了解决any的污染问题，unknown类型只能赋值给unknown和any类型，但是不能赋值给其他类型；不能直接调用unknown类型变量的方法和属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tom</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">89757</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: (<span class="built_in">number</span>|<span class="built_in">string</span>)[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">t</span>:[<span class="built_in">number</span>] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//元组的成员可以添加成员名，这个成员名是说明性的，可以任意取名，没有实际作用。</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Color</span> = [</span><br><span class="line">  <span class="attr">red</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">green</span>: <span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">blue</span>: <span class="built_in">number</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">c</span>:<span class="title class_">Color</span> = [<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h3><p>声明文件必需以 .d.ts 为后缀。</p><p>库的使用场景主要有以下几种：</p><ul><li>全局变量：通过 <script> 标签引入第三方库，注入全局变量</li><li>npm 包：通过 import foo from 'foo' 导入，符合 ES6 模块规范</li><li>UMD 库：既可以通过 <script> 标签引入，又可以通过 import 导入</li><li>直接扩展全局变量：通过 <script> 标签引入后，改变一个全局变量的结构</li><li>在 npm 包或 UMD 库中扩展全局变量：引用 npm 包或 UMD 库后，改变一个全局变量的结构</li><li>模块插件：通过 <script> 或 import 导入后，改变另一个模块的结构</li></ul><p>在 ES6 模块系统中，使用 export default 可以导出一个默认值，使用方可以用 import foo from 'foo' 而不是 import { foo } from 'foo' 来导入这个默认值</p><p>注意，只有 function、class 和 interface 可以直接默认导出，其他的变量需要先定义出来，再默认导出</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">var</span> 声明全局变量</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> 声明全局方法</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">class</span> 声明全局类</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> 声明全局枚举类型</span><br><span class="line"><span class="keyword">declare</span> namespace 声明（含有子属性的）全局对象</span><br><span class="line"><span class="keyword">interface</span> 和 type 声明全局类型</span><br><span class="line">export 导出变量</span><br><span class="line">export namespace 导出（含有子属性的）对象</span><br><span class="line">export default <span class="title class_">ES6</span> 默认导出</span><br><span class="line">export = commonjs 导出模块</span><br><span class="line">export as namespace UMD 库声明全局变量</span><br><span class="line">declare global 扩展全局变量</span><br><span class="line">declare module 扩展模块</span><br><span class="line">/// &lt;reference /&gt; 三斜线指令</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//变量被赋值为一个函数的写法</span></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> hello = <span class="keyword">function</span> (<span class="params"><span class="attr">txt</span>:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + txt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">hello</span>:</span><br><span class="line">  <span class="function">(<span class="params"><span class="attr">txt</span>:<span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">= <span class="keyword">function</span> (<span class="params">txt</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + txt);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyFunc</span> = <span class="function">(<span class="params"><span class="attr">txt</span>:<span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">hello</span>:<span class="title class_">MyFunc</span> = <span class="keyword">function</span> (<span class="params">txt</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello &#x27;</span> + txt);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性类型以分号结尾</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性类型以逗号结尾</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyObj</span> = &#123;</span><br><span class="line">  <span class="attr">x</span>:<span class="built_in">number</span>,</span><br><span class="line">  <span class="attr">y</span>:<span class="built_in">number</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><h2 id="import中-的作用"><a href="#import中-的作用" class="headerlink" title="import中@的作用"></a>import中@的作用</h2><p>路径映射，可以在tsconfig.json中配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;@nui/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/*&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">YYYY</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nui/xxx&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="扩展全局变量的类型"><a href="#扩展全局变量的类型" class="headerlink" title="扩展全局变量的类型"></a>扩展全局变量的类型</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是扩展，不是覆盖，所以放心使用</span></span><br><span class="line">    <span class="title function_">double</span>(): <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">double</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span> + <span class="string">&#x27;+&#x27;</span> + <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>.<span class="title function_">double</span>());</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="www.typescriptlang.org/docs/handbook/basic-types.html">官方手册</a></p></li><li><p><a href="https://wangdoc.com/typescript/">阮一峰TypeScript教程</a></p></li><li><p><a href="https://ts.xcatliu.com/">TypeScript 入门教程</a></p></li></ul></script></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在JavaScript的基础上添加了类型系统，可以在编译时检查类型，提高代码的可读性和可维护性。&lt;/p&gt;
&lt;p&gt;约定使用 TypeScript 编写的文件以 .ts 为后缀，用 TypeScript 编写 React 时，以 .tsx 为后缀。&lt;/p&gt;
&lt;figure cl</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://airshu.github.io/categories/JavaScript/"/>
    
    
    <category term="TypeScript JavaScript" scheme="http://airshu.github.io/tags/TypeScript-JavaScript/"/>
    
  </entry>
  
</feed>
