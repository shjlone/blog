---
title: 基础语法
toc: true
tags:
---



## open关键字

Kotlin 的类，默认是不允许继承的，除非这个类明确被 open 关键字修饰了。另外，对于被 open 修饰的普通类，它内部的方法和属性，默认也是不允许重写的，除非它们也被 open 修饰了

## inner关键字

默认情况下，kotlin中的嵌套类是静态内部类，不会持有外部类饮用。inner修饰时才能引用外部成员，才可能出现内存泄漏，所以加上inner之后就要注意风险了

## sealed

```java
println(Human.MAN == Human.MAN)
println(Human.MAN === Human.MAN)

输出
true
true
```

加强版的枚举。每一个枚举的值，它在内存当中始终都是同一个对象引用。如果想要枚举的值拥有不一样的对象引用，就需要密封类

基础类型Java、Kotlin转换规则：

- 只要基础类型的变量可能为空，那么这个变量就会被转换成 Java 的包装类型。
- 反之，只要基础类型的变量不可能为空，那么这个变量就会被转换成 Java 的原始类型。

## object

### 匿名内部类

在使用 object 定义匿名内部类的时候，其实还可以在继承一个抽象类的同时，来实现多个接口。

```java
image.setOnClickListener(object: View.OnClickListener {
    override fun onClick(v: View?) {
        gotoPreview()
    }
})


interface A {
    fun funA()
}

interface B {
    fun funB()
}

abstract class Man {
    abstract fun findMan()
}

fun main() {
    // 这个匿名内部类，在继承了Man类的同时，还实现了A、B两个接口
    val item = object : Man(), A, B{
        override fun funA() {
            // do something
        }
        override fun funB() {
            // do something
        }
        override fun findMan() {
            // do something
        }
    }
}
```

### 单例模式

```java
object UserManager { 
  fun login() {}
}
```


### 伴生对象

Kotlin中没有static关键字，通过伴生对象来实现静态方法和变量

```java
class Person {
    companion object InnerSingleton {
      //变成静态方法
        @JvmStatic
        fun foo() {}
    }
}

```



## 扩展函数、属性

本质上生成一个静态方法